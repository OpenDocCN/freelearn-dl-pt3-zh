<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Getting Started with TensorFlow.js</h1>
                </header>
            
            <article>
                
<p>So far, we have gently introduced ourselves to the wonderful world of deep learning and we have got a fair sense of what deep learning has to offer in terms of making today<span>'</span>s web applications more intelligent. In <a href="f97d928f-3614-4d12-ad37-d5736008f542.xhtml" target="_blank" rel="noopener noreferrer">Chapter 1</a>, <em>Demystifying Artificial Intelligence and Fundamentals of Machine Learning</em>, we saw a detailed overview of the web applications before and after AI breakout. In <a href="a33bccdc-8664-4ae7-be82-b066e5b64850.xhtml" target="_blank" rel="noopener noreferrer">Chapter 3</a>, <em>Creating Your First Deep Learning Web Application</em>, we built ourselves a simple image classifier-based web application using a simple neural network.</p>
<p>Web applications are all around us and they have easily become inseparable parts of our day-to-day lives. When it comes to building web applications, the use of JavaScript is too hard to ignore. So, what if we built an intelligent web application using JavaScript and no other scripting language? In this chapter, we are going to see how we can use a JavaScript library, called <strong>TensorFlow.js</strong> (<strong>TF.js</strong>), to build a deep learning-enabled web application—we are going to do all of this in a web browser.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li style="font-weight: 400;">The fundamentals of TF.js and its offerings</li>
<li style="font-weight: 400;">Developing a deep learning model with TF.js and making inferences</li>
<li style="font-weight: 400;">Using the pretrained models directly in the browser</li>
<li style="font-weight: 400;">Building a web application to recognize flower species</li>
<li style="font-weight: 400;">Advantages and limitations of TF.js</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You can access the code used in this chapter at <a href="https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter4">https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter4</a>.</p>
<p>To work on this chapter, you'll need the following software: </p>
<ul>
<li>TF.js 0.15.1+</li>
<li>The <kbd>@tensorflow/tfjs-node</kbd> 0.3.0+ package from the NPM repository</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The fundamentals of TF.js</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to briefly review some of the fundamental concepts of TF.js. We will start off by introducing TensorFlow and then we will proceed to study different components of TF.js. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is TensorFlow?</h1>
                </header>
            
            <article>
                
<p>Before we can begin discussing TF.js, we must understand what TensorFlow is. TensorFlow is an open source library that is developed and maintained by Google. It is built on a data structure called tensors. Tensors are the generalized form of scalar and vector. TensorFlow provides a lot of efficient utilities for high-performance numerical computing across a wide range of scientific domains. TensorFlow also provides a very flexible suite of utilities for carrying out machine learning and deep learning development and research. You are encouraged to visit TensorFlow<span>'</span>s official website at <a href="https://www.tensorflow.org/">https://www.tensorflow.org/</a> for more information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is TF.js?</h1>
                </header>
            
            <article>
                
<p>TF.js is a JavaScript library that provides an ecosystem to build and deploy machine learning models. It offers the following functionalities:</p>
<ul>
<li style="font-weight: 400;">Developing machine learning models with JavaScript</li>
<li style="font-weight: 400;">Using pretrained machine learning models</li>
<li style="font-weight: 400;">Deploying machine learning models</li>
</ul>
<p>TF.js provides you with all the elements required for a machine learning project. It has dedicated modules for data preprocessing, tensor handling, model building, model evaluation, and much more, but all in JavaScript. Before we move on to digging deeper into this, let<span>'</span>s quickly understand the need for TF.js.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why TF.js?</h1>
                </header>
            
            <article>
                
<p>As we saw in the previous chapter, it is quite easy and intuitive to simply train and host a model online, wrap it up in a REST API, and then use the API on any frontend to display our results. Why, then, would the need to use TF.js arise?</p>
<p>A simple answer to this question would be if there is an AI in the browser! Think of a game that requires the use of an AI agent that learns from the human player<span>'</span>s method of playing to become tougher or easier as the game progresses. Now, this would be overkill if, at every split second, the game kept sending requests to the server to transfer data to and from the game and the server. What's more, it might easily result in a <strong>Denial of Service</strong> (<strong>DoS</strong>) attack.</p>
<p>So, having an AI that can live and learn in the browser itself makes sense when the agent has to keep learning in real time. It could also be a hybrid in two ways:</p>
<ul>
<li style="font-weight: 400;">If a pretrained model is loaded during the rendering of the agent and, from there, it begins learning and updating the model on the server at intervals.</li>
<li style="font-weight: 400;">If multiple versions of the AI agent run on several systems at once and they learn from interaction on the system on which they run. Also, if their collective learning is assimilated on the server and the agents fetch updates from the server at intervals.</li>
</ul>
<p>So, using TF.js greatly reduces strong dependence on the page that the human user will interact with to communicate with the server at every step.</p>
<p>We can now build a mini project that shows the power of TF.js. Don<span>'</span>t worry about the TF.js ecosystem for now—we will cover all the elements of the project as we go along.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The basic concepts of TF.js</h1>
                </header>
            
            <article>
                
<p>The following are the components of TF.js that we will be using in our project:</p>
<ul>
<li>Tensors</li>
<li>Variables</li>
</ul>
<ul>
<li>Operations</li>
<li>Models</li>
<li>Layers</li>
</ul>
<p>Let's look at each of them in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tensors</h1>
                </header>
            
            <article>
                
<p>Like TensorFlow, the central data processing unit in TF.js is tensors. Goodfellow et al. (in their book on deep learning) make the following observation:</p>
<div class="packt_quote">In the general case, an array of numbers arranged on a regular grid with a variable number of axes is known as a tensor.</div>
<p>Simply described, a tensor is a container of one- or multi-dimensional arrays. The following are some examples of tensors that you may already know:</p>
<ul>
<li style="font-weight: 400;">Scalar (a rank zero tensor)</li>
<li style="font-weight: 400;">Vector (a one-dimensional or rank-one tensor)</li>
<li style="font-weight: 400;">Matrix (a two-dimensional or rank-two tensor)</li>
</ul>
<p>We can create a tensor with respect to a given shape in TF.js as shown:</p>
<pre>const shape = [2, 3]; // 2 rows, 3 columns<br/>const a = tf.tensor([4.0, 2.0, 5.0, 15.0, 19.0, 27.0], shape);</pre>
<p><kbd>a</kbd> is a tensor that was created and its contents can be printed using the following command:</p>
<pre class="mce-root">a.print()</pre>
<p>The following output is printed:</p>
<pre class="mce-root"><strong>Output: [[4 , 2 , 5 ],</strong><br/><strong>       [15, 19, 27]]</strong></pre>
<p><kbd>a</kbd> is a matrix (a rank-two tensor). TF.js also provides dedicated functions, such as <kbd>tf.scalar</kbd>, <kbd>tf.tensor1d</kbd>, <kbd>tf.tensor2d</kbd>, <kbd>tf.tensor3d</kbd>, and <kbd>tf.tensor4d</kbd> to create tensors of specific shapes without having to specify the <kbd>shape</kbd> argument explicitly. It also provides better readability. Tensors are immutable in TF.js.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variables</h1>
                </header>
            
            <article>
                
<p>Unlike tensors, variables are mutable in TF.js. Variables are particularly useful during the training of a neural network as they consist of lots of intermediate data stores and updates. The following is an example of how variables can be used in TF.js:</p>
<pre>const initialValues = tf.ones([5]);<br/>const weights = tf.variable(initialValues); // initialize weights<br/>weights.print(); // output: [1, 1, 1, 1, 1]<br/>const updatedValues = tf.tensor1d([0, 1, 0, 1, 0]);<br/>weights.assign(updatedValues); // update values of weights<br/>weights.print(); // output: [0, 1, 0, 1, 0]</pre>
<p>Let's now look at operators.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Operators</h1>
                </header>
            
            <article>
                
<p class="mce-root">Operators let you perform mathematical operations on data. TF.js provides various operations for manipulating tensors. As tensors are immutable in nature, operators don<span>'</span>t change the data contained in the tensors—they return new tensors as results instead. You can perform binary operations, such as addition, multiplication, and subtraction, on tensors. You can even chain multiple operations. The following example shows the use of two different operators in TF.js using chaining:</p>
<pre class="mce-root">const e = tf.tensor2d([[1.0, 2.0], [3.0, 4.0]]); <br/>const f = tf.tensor2d([[3.0, 4.0], [5.0, 6.0]]); <br/>const sq_sum = tf.square(tf.add(e, f));<br/>sq_sum.print();</pre>
<p><span><span>We first created two two-dimensional tensors and assigned them to <kbd>e</kbd> and <kbd>f</kbd>. We then added them and took their squares. </span></span></p>
<p>This produces the following output:</p>
<pre class="mce-root"><strong>// Output: [[16 , 36],</strong><br/><strong>// [64, 100]]</strong></pre>
<p>Next, we will cover models and layers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Models and layers</h1>
                </header>
            
            <article>
                
<p class="mce-root">In deep learning literature, a model refers to the neural network itself, specifically, the neural network architecture. As discussed in <a href="9a68dbce-f50e-4c5a-80e2-2b7f40e082ca.xhtml" target="_blank" rel="noopener noreferrer">Chapter 2</a>, <em>Getting Started With Deep Learning Using Python</em>, a neural network consists of basic components, such as layers, neurons, and connections, in between layers. TF.js provides two functions with which to create these models—<kbd>tf.model</kbd> and <kbd>tf.sequential</kbd>. <kbd>tf.model</kbd> helps you to get more sophisticated architectures, such as skipping certain layers, whereas <kbd>tf.sequential</kbd> provides a way to create linear stacks of layers without skipping, branching, and so on.</p>
<p class="mce-root">TF.js provides different types of dedicated layers for different types of tasks—<kbd>tf.layers.dense</kbd>, <kbd>tf.layers.dropout</kbd>, <kbd>tf.layers.conv1d</kbd>, <kbd>tf.layers.simpleRNN</kbd>, <kbd>tf.layers.gru</kbd>, and <kbd>tf.layers.lstm</kbd>. The following example demonstrates a simple neural network model with the help of <kbd>tf.sequential</kbd> and <kbd>tf.layers.dense</kbd>:</p>
<pre class="mce-root">const model = tf.sequential();<br/>model.add(tf.layers.dense({units: 4, inputShape: [4], activation: 'relu'}));<br/>model.add(tf.layers.dense({units: 1, activation: sigmoid}));</pre>
<p class="mce-root">The preceding example creates a simple neural network that has the following:</p>
<ul>
<li class="mce-root">Two layers (remember, we don<span>'</span>t consider the input layer when counting the total number of layers). The network takes an input that has four features (the <kbd>inputShape</kbd> argument helps to specify that).</li>
<li class="mce-root">The first layer contains four neurons (hence <kbd>units: 4</kbd>). The second layer (the output layer) has only one neuron.</li>
<li class="mce-root">The <kbd>relu</kbd> activation function is used for the first layer, and the <kbd>sigmoid</kbd> activation function is used for the output layer.</li>
</ul>
<div class="mce-root packt_infobox">You are encouraged to go to <a href="https://js.tensorflow.org/api/latest/index.html">https://js.tensorflow.org/api/latest/index.html</a> to learn more about the preceding components of TF.js.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A case study using TF.js</h1>
                </header>
            
            <article>
                
<p>We will follow all the steps that are typically involved in a machine learning project (which we discussed in <a href="f97d928f-3614-4d12-ad37-d5736008f542.xhtml" target="_blank" rel="noopener noreferrer">Chapter 1</a>, <em>Demystifying Artificial Intelligence and Fundamentals of Machine Learning</em>). A good project starts with a well-defined problem statement. So, let<span>'</span>s quickly take a look at that and decide the subsequent steps accordingly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A problem statement for our TF.js mini-project</h1>
                </header>
            
            <article>
                
<p>The problem we will look at here is probably one of the most famous challenges you will come across when starting your journey in machine learning—classifying and predicting the type of an Iris flower by learning its features from the Iris flower dataset. Training, as well as the prediction, will be performed in the browser itself.</p>
<p>We have defined the problem statement for our project. What will follow is the data preparation step. The data is already available to us, so we don<span>'</span>t need to collect it ourselves. But, before we prepare the data, it would be good to know a bit more about the data itself.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Iris flower dataset</h1>
                </header>
            
            <article>
                
<p>Introduced by<span> </span><span>Ronald Fisher, the</span><span> statistician and biologist, in 1936, the Iris flower dataset contains 150 rows of data and about 3 different varieties of the Iris flower. The columns are as follows:</span></p>
<ul>
<li style="font-weight: 400;">Sepal length (cm)</li>
<li style="font-weight: 400;">Sepal width (cm)</li>
<li style="font-weight: 400;">Petal length (cm)</li>
<li style="font-weight: 400;">Petal width (cm)</li>
<li style="font-weight: 400;">Variety:
<ul>
<li style="font-weight: 400;">Setosa</li>
<li style="font-weight: 400;">Versicolour</li>
<li style="font-weight: 400;">Virginica</li>
</ul>
</li>
</ul>
<div class="packt_infobox"><br/>
You can get the raw dataset and learn more about it at <a href="http://archive.ics.uci.edu/ml/datasets/Iris">http://archive.ics.uci.edu/ml/datasets/Iris</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Your first deep learning web application with TF.js</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to develop a web application with the help of TF.js. This application will include the steps for a standard, full stack, deep learning-enabled web project. We will begin by preparing the data, we will then study the project architecture briefly, and then, we will proceed toward building the required components as we go.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing the dataset</h1>
                </header>
            
            <article>
                
<p>The Iris flower dataset, in its original form, is a CSV file containing the data of 150 rows split into 5 columns in a comma-separated format, with each entry separated by a new line.</p>
<p>However, we will be using a JSON format of the data for easier operability with JavaScript. The dataset in JSON format can be downloaded from <a href="https://gist.github.com/xprilion/33cc85952d317644c944274ee6071547">https://gist.github.com/xprilion/33cc85952d317644c944274ee6071547</a>.</p>
<p>You can use simple functions in any language to convert a CSV file into a JSON file, with the column names changed as per the following conventions:</p>
<ul>
<li style="font-weight: 400;">Sepal length: <kbd>sepal_length</kbd></li>
<li style="font-weight: 400;">Sepal width: <kbd>sepal_width</kbd></li>
<li style="font-weight: 400;">Petal length: <kbd>petal_length</kbd></li>
<li style="font-weight: 400;">Petal width: <kbd>petal_width</kbd></li>
<li style="font-weight: 400;">Variety: <kbd>species</kbd></li>
</ul>
<p>We will use these property names in JSON while developing the tensors for model building.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project architecture</h1>
                </header>
            
            <article>
                
<p>We will be using Node.js in this project to create a server. This is done so that we get the benefits of faster computational performance of TF.js when used through the Node.js backend. We will create a very basic frontend that will be able to issue a command to perform the training of the neural network built using TF.js and another button to issue a command to predict the class of a hypothetical feature vector of an Iris flower based on input provided by the user.</p>
<p>The following diagram shows the components of the project, along with their interactions:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1222 image-border" src="assets/8e47dac3-cf66-406f-8222-dbf2905cd686.png" style="width:40.33em;height:24.50em;"/></p>
<p>Now that we know about the architecture, let's start with the project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting up the project</h1>
                </header>
            
            <article>
                
<p>To start working on the project, you first need to install the latest versions of Node.js and <strong>Node Package Manager</strong> (<strong><span>NPM</span></strong>). While a standard way to do this would be to read the documentation provided on the Node.js website, we would suggest installing Node.js and NPM using <strong>Node Version Manager</strong> (<strong>NVM</strong>).</p>
<div class="packt_infobox">The setup instructions and files can be found at <a href="https://github.com/creationix/nvm">https://githu</a><a href="https://github.com/creationix/nvm">b.com/creationix/nvm</a><a href="https://github.com/creationix/nvm">.</a></div>
<p>Once Node.js and NPM are installed, we<span>'</span>re ready to start working on the project itself:</p>
<ol>
<li>Create a folder called <kbd>tfjs-iris</kbd>.</li>
<li>Open up a Terminal and use the following command to initiate the package manager for this project:</li>
</ol>
<pre style="padding-left: 60px;"><strong>npm init -y</strong></pre>
<p style="padding-left: 60px;">This should create a file, <kbd>package.json</kbd>, in your project directory. The output for the preceding command is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1223 image-border" src="assets/d566a0e8-10d6-4418-9e82-a59447d8f27a.png" style="width:35.50em;height:21.08em;"/></p>
<p style="padding-left: 60px;">Notice that the output is in JSON format. The <kbd>main</kbd><span> </span><span>key</span><span> defines the file that will be the entry point for the program if it is imported as a module. The value for <kbd>main</kbd> in this project is set, </span><span>by default,</span><span> </span><span>to</span> <kbd>index.js</kbd><span>. However, this file is not yet created. Let's work on the </span><kbd>index.js</kbd><span> </span><span>file</span><span>.</span></p>
<p style="padding-left: 60px;">We will be using the <kbd>express</kbd> module of Node.js to create our server. You can read more about <kbd>express</kbd> at <a href="https://expressjs.com/">https://expressjs.com.</a></p>
<ol start="3">
<li>To use <kbd>express</kbd>, we will need to add the module to our project. To do this, use the following code:</li>
</ol>
<pre style="padding-left: 60px;"><strong>npm install express --save</strong></pre>
<p class="mce-root"/>
<p style="padding-left: 60px;">This will add the <kbd>express</kbd> module dependency to the <kbd>package.json</kbd> file and install it in the <kbd>node_modules</kbd> directory inside the working directory of the project.</p>
<ol start="4">
<li>Create a file called <kbd>index.js</kbd> in the root directory of the project repository and add the following code:</li>
</ol>
<pre style="padding-left: 60px;">var express = require('express');<br/>var app = express(); </pre>
<p style="padding-left: 60px;">This creates an <kbd>express</kbd> application object. We will now be adding TF.js to the project. The simplest way to do this is to install it via NPM. The complete setup instructions can be found at <a href="https://js.tensorflow.org/setup/">https://js.tensorflow.org/setup/</a>.</p>
<ol start="5">
<li>Use the following command to install the <kbd>TF.js</kbd> module in the Terminal:</li>
</ol>
<pre style="padding-left: 60px;"><strong>npm install @tensorflow/tfjs --save</strong></pre>
<ol start="6">
<li>We can now proceed to add the module to our <kbd>index.js</kbd> file:</li>
</ol>
<pre style="padding-left: 60px;">const tf = require('@tensorflow/tfjs');</pre>
<ol start="7">
<li>We will also require the <kbd>body-parser</kbd> module from Express.js to handle the incoming query data from the client side, which will be sent via AJAX <kbd>POST</kbd> requests. To do so, we use the following command:</li>
</ol>
<pre style="padding-left: 60px;"><strong>npm install body-parser --save</strong></pre>
<ol start="8">
<li>We now create a <kbd>body-parser</kbd> object and bind it to the application using the following code:</li>
</ol>
<pre style="padding-left: 60px;">var bodyParser = require('body-parser');<br/>app.use(bodyParser.urlencoded({ extended: false }));</pre>
<p><span>At this stage, <kbd>package.json</kbd> should contain the following snippet that lists the dependencies of your project:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1472 image-border" src="assets/64f57e1d-2a8d-481d-b2bc-27ed8c7d89fd.png" style="width:22.58em;height:7.58em;"/></p>
<p>Note that the preceding versions may change. We can now import the <kbd>iris.json</kbd><span> </span><span>file, </span><span>which we will be training our model on:</span></p>
<pre>const iris = require('./iris.json');</pre>
<p>With the initial setup done, we can now proceed to write the TF.js code to train on the available dataset.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a TF.js model</h1>
                </header>
            
            <article>
                
<p>Let's begin by reading the data we have stored in the <kbd>iris</kbd> variable to a <kbd>tensor2d</kbd> object:</p>
<ol>
<li>In your <kbd>index.js</kbd> file, add the following code:</li>
</ol>
<pre style="padding-left: 60px;">const trainingData = tf.tensor2d(iris.map(item=&gt; [<br/>    item.sepal_length, item.sepal_width, item.petal_length, item.petal_width<br/>]),[144,4])</pre>
<p style="padding-left: 60px;">We do not have any test data yet; this will be provided by the user.</p>
<ol start="2">
<li>Next, we create a one-hot encoding of the possible three varieties of flowers:</li>
</ol>
<pre style="padding-left: 60px;">const outputData = tf.tensor2d(iris.map(item =&gt; [<br/>    item.species === 'setosa' ? 1 : 0,<br/>    item.species === 'virginica' ? 1 : 0,<br/>    item.species === 'versicolor' ? 1 : 0<br/>]), [144,3])</pre>
<p style="padding-left: 60px;">We are now ready to create the model for training. The following code might remind you of the code we used in the previous chapter when we were creating a model for the MNIST handwritten digits dataset. This is simply due to the fact that we are still using the concepts of TensorFlow, only in a different language!</p>
<ol start="3">
<li>We first declare a sequential TensorFlow model:</li>
</ol>
<pre style="padding-left: 60px;">const model = tf.sequential();</pre>
<ol start="4">
<li>Next, let's add a layer of neurons to the model:</li>
</ol>
<pre style="padding-left: 60px;">model.add(tf.layers.dense({<br/>    inputShape: 4, <br/>    activation: 'sigmoid', <br/>    units: 10<br/> }));</pre>
<p style="padding-left: 60px;">The <kbd>inputShape</kbd> parameter indicates the shape of the input that will be added to this layer. The <kbd>units</kbd> parameter sets the number of neurons to be used in this layer. The <kbd>activation</kbd> function we are using is the <kbd>sigmoid</kbd> function.</p>
<ol start="5">
<li>Let's now add the output layer: </li>
</ol>
<pre style="padding-left: 60px;">model.add(tf.layers.dense({<br/>    inputShape: 10, <br/>    units: 3, <br/>    activation: 'softmax'<br/>}));</pre>
<p style="padding-left: 60px;">Here, we will have 3 neurons in the output layer, and the input to be expected at this layer is 10, which matches the number of neurons in the previous layer.</p>
<div class="packt_infobox">Apart from the input layer, we just<span> have one hidden layer and the output layer. This is acceptable in this application because the dataset is small and the prediction is simple. Note that we used the </span><kbd>softmax</kbd> <span>activation function here, which produces class probabilities as outputs.</span></div>
<p style="padding-left: 60px;">This is particularly useful in our case as the problem is a multi-class classification problem.  </p>
<ol start="6">
<li>With this done, we are now ready to compile our model. To do this, we use the following code: </li>
</ol>
<pre style="padding-left: 60px;">model.compile({<br/>    loss: "categoricalCrossentropy",<br/>    optimizer: tf.train.adam()<br/>});</pre>
<p style="padding-left: 60px;">Since we have a classification problem at hand where there are multiple possible labels, we use <kbd>categoricalCrossentropy</kbd> as the <kbd>loss</kbd> function. For optimization, the <kbd>adam</kbd> optimizer is used. You are encouraged to experiment with other hyperparameter values. </p>
<ol start="7">
<li>We can generate a summary of the model using the following code:</li>
</ol>
<pre style="padding-left: 60px;">model.summary();</pre>
<p>Next, we will train our TF.js model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Training the TF.js model</h1>
                </header>
            
            <article>
                
<p>We will now write an <kbd>async</kbd> function. The reason for doing this is so that the JavaScript on the client side that invokes our function doesn't get stuck waiting for the result. A function that will take time to complete in our program is the <kbd>train_data()</kbd> function. This function <span><span>performs </span></span>the training of the model:</p>
<pre>async function train_data(){<br/>    console.log("Training Started");<br/>    for(let i=0;i&lt;50;i++){<br/>        let res = await model.fit(trainingData, outputData, {epochs: 50});<br/>        console.log(`Iteration ${i}: ${res.history.loss[0]}`);<br/>    }<br/>    console.log("Training Complete");<br/>}</pre>
<p>The <kbd>train_data()</kbd> function can be run asynchronously. It also prints out the loss at every epoch of training to the console where we will run the server from. Let's now create an API that will invoke the <kbd>train_data()</kbd> function.</p>
<p>First, we create a <em>middleware</em> called <kbd>doTrain</kbd>, which will be run before the API for training and will return any data.</p>
<div class="packt_infobox">You can read more about middlewares at <a href="https://expressjs.com/en/guide/using-middleware.html">https://expressjs.com/en/guide/using-middleware.html</a>.</div>
<p>The <kbd>doTrain()</kbd><span> </span><span>middleware </span><span>accepts, in its arguments, the request made to the Node.js server, the variable for making the response, and the name of the function that will be used to forward the execution of the program after executing the block of code defined in the middleware:</span></p>
<pre>var doTrain = async function (req, res, next) {<br/>    await train_data();<br/>    next();<br/>}</pre>
<p>The <kbd>doTrain</kbd> middleware calls the <kbd>train_data()</kbd> function and awaits its result. The <kbd>train_data()</kbd> function returns a <em>Promise</em> so that the execution continues without freezing. The <kbd>next()</kbd> function runs right after the <kbd>train_data()</kbd> function is complete and it merely passes the execution of the program to the function that is <em>chained</em> next to the middleware, as shown:</p>
<pre class="mce-root">app.use(doTrain).post('/train', function(req, res) {<br/>    res.send("1");<br/>});</pre>
<p>We now bind the <kbd>'/train'</kbd> route to the <kbd>express</kbd> app and then chain the <kbd>doTrain</kbd> middleware to it. Now, for every call made to the <kbd>'/train'</kbd> API, the middleware runs first and then the execution passes to the main block of code for the API. This block of code simply returns any arbitrary value to denote the completion of training.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Predicting using the TF.js model</h1>
                </header>
            
            <article>
                
<p>After the training is done, we also need to create an API to invoke the prediction function and return the predicted result. We bind the API to the <kbd>'/predict'</kbd> route with a <kbd>POST</kbd> method to make a request to this API, as shown:</p>
<pre>app.post('/predict', function(req, res) {<br/>    var test = tf.tensor2d([parseFloat(req.body.sepLen), parseFloat(req.body.sepWid),                                 parseFloat(req.body.petLen), parseFloat(req.body.petWid)], [1,4]);<br/>    var out = model.predict(test);<br/>    var maxIndex = 0;<br/>    for (let i=1;i&lt;out.size; i++){<br/>        if (out.buffer().get(0, i) &gt; out.buffer().get(0, maxIndex)){<br/>            maxIndex = i;<br/>        }<br/>    }<br/>    <br/>    ans = "Undetermined";<br/>    switch(maxIndex) {<br/>        case 0:<br/>            ans = "Setosa"; <br/>        break;<br/>        case 1:<br/>            ans = "Virginica"; <br/>        break;<br/>        case 2:<br/>            ans = "Versicolor"; <br/>        break; <br/>    }<br/>    console.log(ans);<br/>    res.send(ans);<br/>});</pre>
<p>It is very simple to understand the code for the prediction API. Let's discuss it in parts:</p>
<pre>app.post('/predict', function(req, res) {</pre>
<p>This line binds the <kbd>'/predict'</kbd> route to the <kbd>POST</kbd> request method and opens the block of code for the statements that will handle requests made to this route:</p>
<pre>    var test = tf.tensor2d([parseFloat(req.body.sepLen), parseFloat(req.body.sepWid),                                     parseFloat(req.body.petLen), parseFloat(req.body.petWid)], [1,4]);<br/>    var output = model.predict(test);</pre>
<p>These lines create a TF.js <kbd>tensor2d</kbd> object from the data, which is received from the client side. It then runs the <kbd>predict</kbd> method on the model and stores the result in the output variable:</p>
<pre>    var maxIndex = 0;<br/>    for (let i=1;i&lt;out.size; i++){<br/>        if (out.buffer().get(0, i) &gt; out.buffer().get(0, maxIndex)){<br/>            maxIndex = i;<br/>        }<br/>    }</pre>
<p>This block of code merely finds the index that corresponds to the element in the <kbd>tensor2d</kbd> variable output that is highest. Remember that in a <kbd>softmax</kbd> activation output, the highest value corresponds to the predicted index. </p>
<p>After determining the maximum index from the output, we use a simple switch-case statement to decide what output is to be sent to the client from the API. The request data is also logged to the console visible on the server. Finally, we bind our Node.js application to listen to port <kbd>3000</kbd> using the following code:</p>
<pre>app.listen(3000);</pre>
<p>We will now create a simple client in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a simple client</h1>
                </header>
            
            <article>
                
<p>To handle the <kbd>'/'</kbd> route in our application, we add the following lines of code to <kbd>index.js</kbd>, which merely renders a static file, <kbd>index.html</kbd>, which is placed in the public folder:</p>
<pre>app.use(express.static('./public')).get('/', function (req, res) {<br/>    res.sendFile('./index.html');<br/>});</pre>
<p>Now, let's create the static <kbd>index.html</kbd> file by following these steps:</p>
<ol>
<li>First, create a folder, <kbd>public</kbd>, and inside it, create <kbd>index.html.</kbd> Add the following code to the <kbd>index.html</kbd> file:</li>
</ol>
<pre style="padding-left: 60px;">&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;TF.js Example - Iris Flower Classficiation&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;h1&gt; TF.js Example - Iris Flower Classification &lt;/h1&gt;<br/>    &lt;hr&gt;<br/>    &lt;p&gt;<br/>      First, train the model. Then, use the text boxes to try any dummy data.<br/>    &lt;/p&gt;<br/><br/>    &lt;button id="train-btn"&gt;Train&lt;/button&gt;<br/><br/>    &lt;hr&gt;&lt;br&gt;<br/>    &lt;label for="sepLen"&gt;Sepal Length: &lt;/label&gt;<br/>    &lt;input type="number" id="sepLen" value="1" /&gt;&lt;br&gt;<br/>    &lt;label for="sepWid"&gt;Sepal Width:&amp;nbsp;&amp;nbsp;&lt;/label&gt;<br/>    &lt;input type="number" id="sepWid" value="1" /&gt;&lt;br&gt;<br/>    &lt;label for="petLen"&gt;Petal Length: &lt;/label&gt;<br/>    &lt;input type="number" id="petLen" value="1" /&gt;&lt;br&gt;<br/>    &lt;label for="petWid"&gt;Petal Width:&amp;nbsp;&amp;nbsp;&lt;/label&gt;<br/>    &lt;input type="number" id="petWid" value="1" /&gt;&lt;br&gt;<br/>    &lt;br&gt;<br/>    &lt;button id="send-btn" disabled="="true"&gt;Predict!&lt;/button&gt;<br/>    &lt;hr&gt;<br/>    &lt;h3&gt; Result &lt;/h3&gt;<br/>    &lt;h4 id="res"&gt;&lt;/h4&gt;<br/><br/>    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;</pre>
<ol start="2">
<li>After setting a simple UI to the client developed to call the APIs we have created using TF.js, we are ready to define the functions to deploy them from the client side. Notice that both the <kbd>"/train"</kbd> and <kbd>"/predict"</kbd> APIs will be called by a <kbd>POST</kbd> request:</li>
</ol>
<pre>    &lt;script&gt;<br/><br/>      $('#train-btn').click(function(){<br/>        $('#train-btn').prop('disabled', true);<br/>        $('#train-btn').empty().append("Training...");<br/>        $.ajax({<br/>          type: 'POST',<br/>          url: "/train",<br/>          success: function(result) {<br/>            console.log(result);<br/>            $('#send-btn').prop('disabled', false);<br/>            $('#train-btn').empty().append("Trained!");<br/>          }<br/>        });<br/>      });<br/><br/>      $('#send-btn').click(function(){<br/>        var sepLen = $('#sepLen').val();<br/>        var sepWid = $('#sepWid').val();<br/>        var petLen = $('#petLen').val();<br/>        var petWid = $('#petWid').val();<br/>        $.ajax({<br/>          type: 'POST',<br/>          url: "/predict",<br/>          data: {sepLen: sepLen, sepWid: sepWid, petLen: petLen, petWid: petWid},<br/>          success: function(result) {<br/>            console.log(result);<br/>            $('#res').empty().append(result);<br/>          }<br/>        });<br/>      });<br/>    &lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>Let's now run the TF.js web app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the TF.js web app</h1>
                </header>
            
            <article>
                
<p>With all the application coded, we are now ready to run our application. First, open a Terminal and make the <kbd>tfjs-iris</kbd><span> </span><span>folder</span><span> containing the</span> <kbd>package.json</kbd> <span>file as your working directory in it.</span></p>
<p>Run the following line of code to start the Node.js server:</p>
<pre>node index.js</pre>
<p>The command produces an output that resembles the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1225 image-border" src="assets/36c2cc46-bbf1-471e-beb4-5bde0c30efe1.png" style="width:39.58em;height:23.67em;"/></p>
<p>Now, along with this output, the server starts at port <kbd>3000</kbd><span> </span><span>and we can view the same in the browser. Open a browser and type</span> <kbd>http://localhost:3000/</kbd> <span>in the address bar to bring up the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1226 image-border" src="assets/d9ca1b9a-3a54-4848-be67-d133f21e5e88.png" style="width:42.50em;height:24.25em;"/></p>
<p>First, you must click on the <span class="packt_screen">Train</span> button to invoke the <kbd>'/train'</kbd> API, which begins the training, and the button changes to a disabled state. Once the <span class="packt_screen">Predict!</span><span> </span><span>button</span><span> is enabled, the training is complete and the user can send dummy data to the server to make predictions. Say we choose the 50<sup>th</sup> row of data</span><span> </span><span>from the dataset</span><span> and send it to the server with an expected output of</span> <kbd>Setosa</kbd><span>. </span></p>
<p>The following screenshot shows a small section of the final version of our project:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1227 image-border" src="assets/89c50dc0-72c8-4ccf-83db-1e588b47c268.png" style="width:74.75em;height:45.92em;"/></p>
<p>We see that the correct output is generated for the input provided. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advantages and limitations of TF.js</h1>
                </header>
            
            <article>
                
<p>Let's now summarize some of the advantages TF.js brings over TensorFlow, besides the ones we have already talked about in this chapter:</p>
<ul>
<li><strong>Automatic GPU support</strong>: You don't need to install CUDA or GPU drivers separately with TF.js to benefit from the GPUs present on the system. This is because the browser itself implements GPU support. </li>
<li><strong>Integration</strong>: It is fairly simple to integrate TF.js into a web development project using Node.js and then import pretrained models to the project and run them in the browser.</li>
</ul>
<p>However, it also has several disadvantages that have to be kept in mind whenever developing for production. Some of these are as follows:</p>
<ul>
<li><strong>Speed</strong>: TF.js is suitable for small datasets. On large-scale datasets, the computation speed suffers heavily and is nearly 10x slower.</li>
<li><strong>Lack of a tensor board</strong>: This great tool, which enables TensorFlow models to be visualized, is missing in the JavaScript port of the framework since TF.js is only an API. </li>
<li><strong>Incomplete support of APIs</strong>: Not all of the TensorFlow APIs are available on TF.js, and so you might have to rethink the code logic or create your own functions to use certain features while developing with TF.js.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how easy it is to create models with TF.js. You not only get the whole JavaScript ecosystem to work with, but you <span>also</span><span> </span><span>get all the pretrained TensorFlow models within TF.js. We developed a simple web application using the Iris dataset and, along the way, we learned about several components that TF.js has to offer. By now, we have </span><span>already</span><span> </span><span>built two simple end-to-end deep learning-based web applications. </span></p>
<p>Our progress is indeed apparent. In the upcoming chapters, we will be building our own deep learning APIs and using them to create intelligent web applications. But before that, let's make ourselves familiar with the whole concept of APIs in the next chapter. </p>


            </article>

            
        </section>
    </body></html>