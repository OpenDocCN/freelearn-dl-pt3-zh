["```\nfrom tensorflow.keras.callbacks import TensorBoard\nmodel_name = 'bitcoin_lstm_v0_run_0'\ntensorboard = TensorBoard(log_dir='logs\\\\{}'.format(model_name)) \\\n                          model.fit(x=X_train, y=Y_validate, \\\n                          batch_size=1, epochs=100, verbose=0, \\\n                          callbacks=[tensorboard])\n```", "```\nmodel.fit(x=X_train, y=Y_ train, \\\n          batch_size=1, epochs=100, verbose=0, \\\n          callbacks=[tensorboard], validation_split=0.1, \\\n          validation_data=(X_validation, Y_validation))\n```", "```\nmodel.evaluate(x=X_test, y=Y_test)\n```", "```\ncombined_set = np.concatenate((train_data, test_data), axis=1) \\\n               evaluated_weeks = []\nfor i in range(0, validation_data.shape[1]):\n    input_series = combined_set[0:,i:i+187]\nX_test = input_series[0:,:-1].reshape(1, \\\n         input_series.shape[1] – 1, ) \\\n         Y_test = input_series[0:,-1:][0]\nresult = B.model.evaluate(x=X_test, y=Y_test, verbose=0) \\\n         evaluated_weeks.append(result)\n```", "```\ncombined_set = np.concatenate((train_data, test_data), \\\n               axis=1) predicted_weeks = []\nfor i in range(0, validation_data.shape[1] + 1): \n    input_series = combined_set[0:,i:i+186]\n    predicted_weeks.append(B.predict(input_series))\n```", "```\ndef denormalize(reference, series, normalized_variable=\\\n                'close_point_relative_normalization', \\\n                denormalized_variable='close'):\n    if('iso_week' in list(series.columns)):\n        week_values = reference[reference['iso_week'] \\\n                      == series['iso_week'].values[0]]\n        last_value = week_values[denormalized_variable].values[0]\n        series[denormalized_variable] = \\\n        last_value * (series[normalized_variable] + 1)\n    return series\npredicted_close = predicted.groupby('iso_week').apply(lambda x: \\\n                  denormalize(observed, x))\n```", "```\ndef mape(A, B):\n    return np.mean(np.abs((A - B) / A)) * 100\ndef rmse(A, B):\n    return np.sqrt(np.square(np.subtract(A, B)).mean())\n```", "```\n    $ jupyter-lab\n    ```", "```\n    $ cd ./Chapter03/Exercise3.01/\n    $ tensorboard --logdir=logs/\n    ```", "```\n    train = pd.read_csv('data/train_dataset.csv')\n    test = pd.read_csv('data/test_dataset.csv')\n    ```", "```\n    result = model.evaluate(x=X_test, y=Y_test, verbose=0)\n    ```", "```\n    predicted_weeks = []\n    for i in range(0, test_data.shape[1]):\n        input_series = combined_set[0:,i:i+186]\n        predicted_weeks.append(model.predict(input_series))\n    ```", "```\n    predicted_close = predicted.groupby('iso_week').apply(\\\n                      lambda x: denormalize(observed, x))\n    ```", "```\n    from scripts.utilities import rmse, mape\n    ```", "```\n    def mape(A, B):\n      return np.mean(np.abs((A - B) / A)) * 100\n    def rmse(A, B):\n      return np.sqrt(np.square(np.subtract(A, B)).mean())\n    ```", "```\n    model = load_model('bitcoin_lstm_v0.h5')\n    ```", "```\n    train_model(model=model, X=X_train, Y=Y_train, \\\n                epochs=10, version=0, run_number=0)\n    ```", "```\nperiod_length = 7\nnumber_of_periods = 186\nbatch_size = 1\nmodel = Sequential() \nmodel.add(LSTM(\nunits=period_length,\nbatch_input_shape=(batch_size, number_of_periods, period_length), \\\n                  input_shape=(number_of_periods, period_length), \\\n                  return_sequences=True, stateful=False))\nmodel.add(LSTM(units=period_length,\\\n               batch_input_shape=(batch_size, number_of_periods, \\\n                                  period_length), \\\n               input_shape=(number_of_periods, period_length), \\\n               return_sequences=False, stateful=False))\nmodel.add(Dense(units=period_length)) \\\nmodel.add(Activation(\"linear\"))\nmodel.compile(loss=\"mse\", optimizer=\"rmsprop\")\n```", "```\nnumber_of_epochs = 10**3 \nmodel.fit(x=X, y=Y, batch_size=1,\\\n          epochs=number_of_epochs, \\\n          verbose=0, \\\n          callbacks=[tensorboard])\n```", "```\nmodel = Sequential() model.add(LSTM(\n                               units=period_length,\\\n                               batch_input_shape=(batch_size, \\\n                               number_of_periods, period_length), \\\n                               input_shape=(number_of_periods, \\\n                                            period_length), \\\n                               return_sequences=True, \\\n                               stateful=False))\nmodel.add(LSTM(units=period_length,\\\n          batch_input_shape=(batch_size, number_of_periods, \\\n                             period_length), \\\n          input_shape=(number_of_periods, period_length), \\\n          return_sequences=False, stateful=False))\nmodel.add(Dense(units=period_length)) \\\nmodel.add(Activation(\"tanh\"))\nmodel.compile(loss=\"mse\", optimizer=\"rmsprop\")\n```", "```\nmodel = Sequential()\nmodel.add(LSTM(\\\n          units=period_length,\\\n          batch_input_shape=(batch_size, number_of_periods, \\\n                             period_length), \\\n          input_shape=(number_of_periods, period_length), \\\n          return_sequences=True, stateful=False))\nmodel.add(Dropout(0.2))\nmodel.add(LSTM(\\\n          units=period_length,\\\n          batch_input_shape=(batch_size, number_of_periods, \\\n                             period_length), \\\n          input_shape=(number_of_periods, period_length), \\\n          return_sequences=False, stateful=False))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(units=period_length))\nmodel.add(Activation(\"tanh\"))\nmodel.compile(loss=\"mse\", optimizer=\"rmsprop\")\n```"]