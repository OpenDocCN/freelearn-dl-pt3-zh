<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating a Deep Learning Workflow</h1>
                </header>
            
            <article>
                
<p>In this chapter, you will learn about the AWS Step Functions service and also create AWS step functions by connecting to AWS Lambda using the AWS Console. You will also learn to create an AWS step function connection using the serverless framework and finally you will look into an example project for a deep learning workflow. </p>
<p>We will cover the following topics: </p>
<ul>
<li><span>Introduction to the AWS Step Functions service</span></li>
<li><span>Creating an AWS Step Functions connection to AWS Lambda using the AWS Console</span></li>
<li><span>Creating an AWS Step Functions connection using the serverless framework</span></li>
<li>Deep learning workflow</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p><span>The technical requirements for this chapter are as follows:</span></p>
<ul>
<li>AWS subscription</li>
<li>Python 3.6</li>
<li>AWS CLI</li>
<li>Serverless framework</li>
<li>You can find all the code at<span> </span><a href="https://github.com/PacktPublishing/Hands-On-Serverless-Deep-Learning-with-TensorFlow-and-AWS-Lambda">https://github.com/PacktPublishing/Hands-On-Serverless-Deep-Learning-with-TensorFlow-and-AWS-Lambda</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to the AWS Step Functions service</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this section, we will cover  the AWS <span>Step Functions</span> service, including its features and also the pricing for using this service. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Processing workflow </h1>
                </header>
            
            <article>
                
<p class="mce-root">The processing workflow is an additional method for interaction between the different services. If you want to build a multi-step process in deep learning, it could mean loading the data, then pre-processing data and running the model on it. While you can put queries between each of these backend nodes, it would be very hard to monitor the processing for a single task. This is where the workflow can be extremely convenient. Basically, the workflow service takes care of the invocation of each node when needed and handles the intermediate state of the processing job. It allows you to have a high-level view of what is happening with each task, and track task failures and timeouts. Finally, it allows you to have very flexible component usage as part of the workflow.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AWS Step Functions</h1>
                </header>
            
            <article>
                
<p class="mce-root">AWS Step Function is an AWS service that allows you to manage the workflow as a state machine. It can be connected to any processing backend and has a native integration with AWS Lambda. It has a pay-as-you-go system, which makes it very convenient.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AWS step function features </h1>
                </header>
            
            <article>
                
<p class="mce-root">We will now look at the specific features of step functions: </p>
<ul>
<li>Step functions are extremely scalable and you don't have to manage neither the scanning nor the workflow.</li>
<li class="mce-root">Step functions have a great visual UI, which enables easy monitoring of the processing jobs.</li>
<li class="mce-root">State management allows you to add complex logic, such as choosing the next node based on the results of previous nodes, and it also allows for running several nodes in parallel.</li>
<li class="mce-root">Some functions have convenient logic for retrying tasks, which enables you to ensure processing.</li>
<li class="mce-root">Built-in error handling allows you to handle cases. For example, when you encounter some exception and you need a way to add logic for error handling, such as marking a task as failed in the database.</li>
<li class="mce-root">Scheduling allows you to run delayed processing tasks, which is very convenient for when you have to wait for another process to complete.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AWS Step Functions pricing </h1>
                </header>
            
            <article>
                
<p class="mce-root">One of the main advantages of step functions is the pay-as-you go system. It is very simple 25 cents per 10,000 requests, of which the  first 4,000 requests are free per month. This makes it perfect for early projects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step functions versus SQS</h1>
                </header>
            
            <article>
                
<p class="mce-root">If we dive deep into how the step functions are different from SQS in terms of features and possible use cases, we can say that SQS is most suitable for short, simple, low-priority tasks that can come in very large volumes (millions of tasks per day). Step functions, on the other hand, are most suitable for cases where we have complex multi-step processes, which can take a lot of time and where we would like to guarantee delivery of every task (thousands of tasks per day). In the next section, you will learn how to create an AWS Step Functions connection to AWS Lamda using the AWS Console.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an AWS Step Functions connection to AWS Lambda using the AWS Console</h1>
                </header>
            
            <article>
                
<p>In this section, we will create setp functions using the AWS Console. To create a step function, there are two main steps: </p>
<ol>
<li><span>Creating the AWS Lambda instance</span></li>
<li>Creating the step function that will use the Lambda instance</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the AWS Lambda instance</h1>
                </header>
            
            <article>
                
<p>Now we will create an AWS Lambda instance using the AWS Console:</p>
<ol start="1">
<li>Navigate to Lambda to create the Lambda instance.</li>
<li>Now enter the <span class="packt_screen">Name</span> as <kbd>testLambdaStepFunction</kbd>, <span class="packt_screen">Runtime</span> as <span class="packt_screen">Python 3.6</span>, <span class="packt_screen">Role</span> as <span class="packt_screen">Choose an existing role<strong>,</strong></span> and the existing role as <kbd>lamdaAdminRole</kbd><span class="packt_screen"><strong>.</strong></span> Then click on <span class="packt_screen">Create function<strong>,</strong></span> which is at the bottom-right part of the screen:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/00e5c249-acd6-4662-bee7-31721498178e.png"/></p>
<ol start="3">
<li>The Lambda instance has been successfully created:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-717 image-border" src="assets/de5327bf-d4ad-43d1-b9c6-a7419822ac4a.png" style="width:93.50em;height:36.67em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the step function</h1>
                </header>
            
            <article>
                
<p>To create the step function, we need to perform the following steps: </p>
<ol>
<li>Go to the <span>Step Functions</span> service and click on <span class="packt_screen">Create state machine</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9ba76c2a-c3c4-49ed-add0-adbaeecd6ecf.png"/></p>
<p class="mce-root"/>
<ol start="2">
<li>In the <span class="packt_screen">Define state machine</span> tab, enter the name as <kbd>testLambda:</kbd></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b1850fe2-2c5a-41b1-9644-7a1dc5d66338.png" style="width:48.08em;height:22.50em;"/></p>
<ol start="3">
<li>Now we need to define <kbd>Type</kbd> as <kbd>Task</kbd> and the <kbd>Resource</kbd>. For the resource, you will need to use the ARN address of your Lambda, which you will find in the top-right corner of the tab. You can copy and paste this in the state machine definition section, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-718 image-border" src="assets/9a5a4d88-95b3-4a7a-a2ff-0f01fbc9eefa.png" style="width:76.58em;height:41.25em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="4">
<li>We will now create an IAM role, which is done automatically. Enter the name as <kbd>StepFunctionTestRole</kbd> and click on <span class="packt_screen">Create function<strong>.</strong></span> This will take up a minute before your state machine has permissions to execute properly:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-719 image-border" src="assets/b9269fed-f3f4-4d8f-97ff-5ccaa9177f9a.png" style="width:78.92em;height:52.33em;"/></p>
<ol start="5">
<li>Now, once we have created the step function, we can test and send a simple message. To do this, click on <span class="packt_screen">Start execution</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6eeb1272-b7ac-49bf-834b-17cc5274b0b2.png"/></p>
<ol start="6">
<li>We can see the graph of execution here:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-720 image-border" src="assets/9207d192-9679-4c39-a4af-4075e247888a.png" style="width:27.33em;height:20.33em;"/></p>
<ol start="7">
<li><span>F</span>or each execution, you can see the input and output of the whole step function:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/61cf30c5-e891-44cf-8836-a2a60be86e29.png"/></p>
<ol start="8">
<li>We can see the input and output of each node (this can be seen in the <span class="packt_screen">Step details</span> tab). If there is an error, we will be able to see it in the <span class="packt_screen">Exception</span> tab. Also, if you scroll down, you can also see the timeline of execution:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/18d7bb8b-5034-45ae-9976-2456b01b2aee.png" style="width:29.00em;height:44.67em;"/></p>
<ol start="9">
<li>We can also check logs by using the link present in the <span class="packt_screen">Resource</span> tab under the <span class="packt_screen">Step details</span> tab by clicking on it. This will lead you to the following page:<span><br/></span></li>
</ol>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/91a97835-4c06-42cb-940b-2862cfec6508.png"/></p>
<p class="CDPAlignLeft CDPAlign"><span>Therefore, we can see that step function is a very convenient service for managing Lambda execution.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating AWS step functions for an AWS Lambda instance using the serverless framework</h1>
                </header>
            
            <article>
                
<p><span>In this section, we'll create step functions using the serverless framework. </span>First, let's take a look at our project files: one Python file and the serverless configuration file. In the configuration file, we will be adding a few plugins and describing step functions, which is a complex thing. </p>
<p>So, let's explore the step functions in the serverless configuration file by beginning with the live code:</p>
<ol>
<li>Deploy the serverless framework.</li>
<li>Using the CLI, check the deployment status of the serverless framework.</li>
<li>Now, check the step function result using the AWS Console.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step functions</h1>
                </header>
            
            <article>
                
<p>Let's check the list of files that we have by executing the <kbd>ls</kbd> command. As you can see, we have the <kbd>index.py</kbd> file and the <kbd>serverless.yml</kbd> configuration file service document. We also have installed plugins for the serverless framework.</p>
<p>Let's take a look at the configuration file and its two main parts here:</p>
<ol>
<li>First, we will be adding several functions, which will be used in different states of the step function:</li>
</ol>
<pre>function:<br/>    branch:<br/>        handler: index.handlerBranch<br/>    map:<br/>        handler: index.handlerMap<br/>    reduce:<br/>        handler: index.handlerReduce</pre>
<ol start="2">
<li>Next, we will add some plugins, which are required to work with step functions:</li>
</ol>
<pre style="padding-left: 60px">plugins:    - serverless-step-functions<br/>    - serverless-pseudo-parameters</pre>
<ol start="3">
<li>Now let's take a look at the <kbd>index.py</kbd> file, where you can see all the parts discussed so far:</li>
</ol>
<pre class="CDPAlignLeft CDPAlign" style="padding-left: 60px">def handlerMap(event,context):<br/>    return event<br/><br/>def handlerReduce(event,context):<br/>    return event<br/><br/>def handlerBranch(event,context):<br/>    return 'Hello world'</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Serverless deployment</h1>
                </header>
            
            <article>
                
<p>Now, let's deploy our service by executing the following command:</p>
<pre><strong>serverless deploy</strong></pre>
<p>The preceding command deploys your service, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3fd7abbc-8d56-49fe-a645-bbf47f4bb674.png"/></p>
<p>As part of the deployment, it will give us the URL of the API Gateway, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-733 image-border" src="assets/15414d25-539f-4323-9630-cd4b6c5f0af1.png" style="width:107.75em;height:10.58em;"/></p>
<p>Now let's test the URL in the command line:</p>
<pre><strong>curl https://dns1519ilj.execute-api.us-east-1.amazonaws.com/dev/startFunction</strong></pre>
<p>You can check with the results in your browser. In the following screenshot, you can see our step function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/34adc7b7-87bb-4a80-a839-07fcd728150f.png"/></p>
<p>In the following screenshot, we can see that the latest execution went successfully:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/10f5436d-2d88-401d-973e-078edbe7d840.png"/></p>
<p>You can check the input and output of each node. If there are any errors, you can check them in the <span class="packt_screen">Exception</span> section.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Both branches returned hello world and the step node combines the result and returns it as the result of the step function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bd522dd4-b292-4a6a-b092-d2dd3757f580.png"/></p>
<p>Here, let's check with the timeline of the execution. You can also see that the branches have started almost at the same time.</p>
<p>In the next section, we will look at an example of the deep learning workflow project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example project – deep learning workflow</h1>
                </header>
            
            <article>
                
<p>First, let's take a look at our following project files. We have the main Python file, the service integration file, and a few libraries and inception models. <span>In the configuration file, we will be adding a few plugins and describing step functions, which is a complex thing. </span></p>
<p>The main difference with our Python file will be that we will have three functions . One will map a list of URL links into separate things. Another will run a model on the link. The final one will combine the results. The structure of the deployment will be similar to the one in the previous section. We will skip the deployment of the model to S3, since we covered it in the previous chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the model</h1>
                </header>
            
            <article>
                
<p>Here, we will need to deploy the serverless framework and then we can check the trance using the CLI:</p>
<ol>
<li>Let's look at the configuration file. You can see all the main parts and r<span>oles that we need to define to access the model:</span></li>
</ol>
<pre style="padding-left: 60px">provider:<br/>  name: aws<br/>  region: us-east-1<br/>  runtime: python3.6<br/>  memorySize: 1536<br/>  timeout: 30<br/>  iamRoleStatements:<br/>    - Effect: "Allow"<br/>       Action:<br/>         - "s3:ListBucket"<br/>       Resource:<br/>         - arn:aws:s3:::serverlessdeeplearning<br/>    - Effect: "Allow"<br/>       Action:<br/>         - "s3:GetObject"<br/>       Resource:<br/>         - arn:aws:s3:::serverlessdeeplearning/*</pre>
<ol start="2">
<li>Here are the functions, which we will use in different states of the step function:</li>
</ol>
<pre style="padding-left: 60px">functions:<br/>  main:<br/>    handler: index.handler<br/>  map:<br/>    handler: index.map<br/>  reduce:<br/>    handler: index.reduce</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="3">
<li><kbd>map</kbd> will enable the mapping of the incoming event into different Lambdas, range will enable the processing of each link separately in parallel, and <kbd>reduce</kbd> will help in combining them in one response.  We have the state machine definition, which is very similar to that previously discussed:</li>
</ol>
<pre style="padding-left: 60px">stepFunctions:<br/>  stateMachines:<br/>    DeepLearningWorkflow:<br/>      events:<br/>        - http:<br/>            path: gofunction<br/>            method: POST<br/>      name: DeepLearningWorkflow<br/>      definition:<br/>        StartAt: StartStepF<br/>        States:<br/>          StartStepF:<br/>            Type: Task<br/>            Resource: arn:aws:lambda:#{AWS::Region}:#{AWS::AccountId}:function:${self:service}-${opt:stage}-map<br/>            Next: Parallel<br/>          Parallel:<br/>            Type: Parallel<br/>            Next: EndStepF<br/>            Branches:<br/>              - StartAt: Branch1<br/>                States:<br/>                  Branch1:<br/>                    Type: Task<br/>                    Resource: arn:aws:lambda:#{AWS::Region}:#{AWS::AccountId}:function:${self:service}-${opt:stage}-main<br/>                    InputPath: '$.branch1.url'<br/>                    ResultPath: '$.res'<br/>                    End: True<br/>              - StartAt: Branch2<br/>                States:<br/>                  Branch2:<br/>                    Type: Task<br/>                    Resource: arn:aws:lambda:#{AWS::Region}:#{AWS::AccountId}:function:${self:service}-${opt:stage}-main<br/>                    InputPath: '$.branch2.url'<br/>                    ResultPath: '$.res'<br/>                    End: True<br/>              - StartAt: Branch3<br/>                States:<br/>                  Branch3:<br/>                    Type: Task<br/>                    Resource: arn:aws:lambda:#{AWS::Region}:#{AWS::AccountId}:function:${self:service}-${opt:stage}-main<br/>                    InputPath: '$.branch3.url'<br/>                    ResultPath: '$.res'<br/>                    End: True<br/>          EndStepF:<br/>            Type: Task<br/>            Resource: arn:aws:lambda:#{AWS::Region}:#{AWS::AccountId}:function:${self:service}-${opt:stage}-reduce<br/>            End: true</pre>
<ol start="4">
<li>Here, we have plugins, which are required to work the functions:</li>
</ol>
<pre style="padding-left: 60px">plugins:<br/>  - serverless-step-functions<br/>  - serverless-pseudo-parameters</pre>
<ol start="5">
<li>The main difference in our index file from the previous section is that we added the MapReduce logic. This will enable the processing of each URL separately:</li>
</ol>
<pre style="padding-left: 60px">def map(event, context):<br/>    dictMap = {}<br/>    dictMap['branch1'] = {'url':event[0]}<br/>    dictMap['branch2'] = {'url':event[1]}<br/>    dictMap['branch3'] = {'url':event[2]}<br/>    return dictMap<br/><br/>def reduce(event, context):<br/>    vecRes = []<br/>    for res in event:<br/>        vecRes.append(res['res'])<br/>    return vecRes</pre>
<p class="CDPAlignLeft CDPAlign" style="padding-left: 30px">For this case, we'll have three URLs,for the dog, panda, and red panda images taken from the free images website. </p>
<ol start="6">
<li>Now we have our model ready, let's deploy the service using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>serverless deploy</strong></pre>
<ol start="7">
<li>You will have the URL for the API to test.</li>
</ol>
<ol start="8">
<li>Let's test this URL. We will need to use the <kbd>curl</kbd> command, which will be a little different from its usages previously.</li>
<li>First of all, we will use <kbd>POST</kbd> requests instead of <kbd>GET</kbd> requests, and we will provide a list of links as both of the request. As you can see, it returned successfully. This execution indicates that it successfully sent the command to the step function:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-742 image-border" src="assets/46ee1384-e17a-44cf-bf3d-6da9e89362a9.png" style="width:66.42em;height:20.83em;"/></p>
<ol start="10">
<li>Now let's look at the graph in the browser. We can see that it has already finished the execution:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7432b778-a596-4b95-90c2-de0d4257f6b0.png" style="width:25.92em;height:24.17em;"/></p>
<ol start="11">
<li>We can see that each branch received a separate URL, and we can see that the final note combined results from different branches as single, and that it successfully recognized the images:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/74d04458-0193-4cda-9049-e2770a6e231d.png" style="width:25.67em;height:32.83em;"/></p>
<p>Also, we can check the timeline of the execution and see that almost all the branches started at the same time.</p>
<p>This means that the parallelization really enabled us to process a list of links faster.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we studied the AWS <span>Step Functions</span> service, including its features and pricing. We also learned how to connect AWS <span>Step Functions</span> to AWS Lambda using the AWS Console. We also saw how to create a step function using the serverless framework and even created a deep learning workflow.</p>


            </article>

            
        </section>
    </body></html>