<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Making Quality Product Recommendations Using TensorFlow</h1>
                </header>
            
            <article>
                
<p class="mce-root">When you visit Amazon, Netflix, or your other favorite websites, or use any modern app such as Spotify or Pandora, you will have noticed that they recommend different items to you. These recommendations are created using recommendation system algorithms. Before machine learning based recommendations systems, the recommendations were generated with rule-based systems. However, with the advent of machine learning and neural networks, recommendations have become more accurate. </p>
<p>In this chapter, we'll learn about recommendation systems. We'll use the Retailrocket dataset to implement a recommendation system in two different ways, using TensorFlow and Keras.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Recommendation systems</li>
<li>Content-based filtering</li>
<li>Collaborative filtering</li>
<li>Hybrid systems</li>
<li>Matrix factorization</li>
<li>Introducing the Retailrocket dataset</li>
<li>Exploring the Retailrocket dataset</li>
<li>Preprocessing the data</li>
<li>The matrix factorization model for Retailrocket <span>recommendations</span></li>
<li>The neural network model for Retailrocket recommendations</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recommendation systems</h1>
                </header>
            
            <article>
                
<p class="mce-root">One of the most common applications of machine learning systems is to recommend things to users that they'll be interested in. Have you noticed how Spotify and Pandora recommend a certain kind of music, or particular songs or radio stations? You may have observed Netflix recommending movies for you, as well, as in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1068 image-border" src="assets/bb82990e-16df-4071-94c2-0606431b38b1.png" style="width:151.25em;height:20.75em;"/></p>
<p>How about Amazon recommending books based on the book that you are currently browsing, as in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1098 image-border" src="assets/d7875ab6-8be8-4ede-ab89-0a5db8b9473b.png" style="width:50.42em;height:33.58em;"/></p>
<p>Such systems are known as recommendation systems. </p>
<p>A recommendation system is one that learns about what items might be of interest to a user, and then recommends those items for buying, renting, listening, watching, and so on. Recommendation systems are broadly classified into two categories: content-based filtering and collaborative filtering.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Content-based filtering</h1>
                </header>
            
            <article>
                
<p>Content-based filtering is based on creating a detailed model of the content from which recommendations are made, such as the text of books, attributes of movies, or information about music. The content model is generally represented as a vector space model. Some of the common models for transforming content into vector space models are TFIDF, the <em>Bag-of-words</em> model, Word2Vec, GloVe, and Item2Vec. </p>
<p>Along with the content model, a user profile is also created using information about the user. Content is recommended based on matching the user profile with the content model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advantages of content-based filtering algorithms</h1>
                </header>
            
            <article>
                
<p>The following are the advantages of content-based filtering algorithms:</p>
<ul>
<li><strong>Eliminates the cold-start problem for new items:</strong> If we have enough information about the users, and detailed information about the new content, then the cold-start problem found in collaborative filtering algorithms does not affect content-based algorithms. The recommendation can be made based on the user profile and the information about the content.</li>
<li><strong>The recommendations are explainable and transparent:</strong> Using content representation models, we'll be able to explain how certain items are selected for recommendations.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Disadvantages of content-based filtering algorithms</h1>
                </header>
            
            <article>
                
<p>The following are the disadvantages of content-based filtering algorithms:</p>
<ul>
<li>Content-based filtering algorithms require detailed information about items and content, which is sometimes not available</li>
<li>Content-based filtering algorithms are prone to overspecialization</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collaborative filtering</h1>
                </header>
            
            <article>
                
<p>Collaborative filtering algorithms do not need detailed information about the user or the items. They build models based on user interactions with items such as song listened, item viewed, link clicked, item purchased or video watched. The information generated from the user-item interactions is classified into two categories: implicit feedback and explicit feedback:</p>
<ul>
<li>Explicit feedback information is when the user explicitly assigns a score, such as a rating from 1 to 5 to an item.</li>
<li>Implicit feedback information is collected with different kinds of interaction between users and items, for example, view, click, purchase interactions in the Retailrocket dataset that we will use in our example.</li>
</ul>
<p>Further collaborative filtering algorithms can be either user-based or item-based. In user-based algorithms, interactions between users are focused on to identify similar users. Then the user is recommended items that other similar users have bought or viewed. In item-based algorithms, first, the similar items are identified based on item-user interactions, and then items similar to the current item are recommended.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hybrid systems</h1>
                </header>
            
            <article>
                
<p>Hybrid systems leverage the power of both content-based and collaborative filtering by combing both methods. There are many ways hybrid systems are implemented, such as:</p>
<ul>
<li>Creating ensembles of content-based and collaborative filtering algorithms and combining the recommendations of both types of algorithms</li>
<li>Enhancing collaborative filtering with content details and user information</li>
<li>Adding user-item interaction models to content-based filtering algorithms</li>
</ul>
<p class="mce-root"/>
<p>The reader is encouraged to explore more about the three kinds of recommendation systems. We'll explore how to build recommendation systems with matrix factorization and neural networks in the Retailrocket dataset example in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Matrix factorization</h1>
                </header>
            
            <article>
                
<p>Matrix factorization is a popular algorithm for implementing recommendation systems and falls in the collaborative filtering algorithms category. In this algorithm, the user-item interaction is decomposed into two low-dimensional matrices. For example, let's say all the visitor-item interactions in our dataset are M x N matrix, denoted by A. Matrix factorization decomposes matrix A into two matrices of M x k and k x N dimensions respectively, such that the dot product of these two can approximate matrix A. Some of the more popular algorithms for finding the low-dimensional matrix are based on <strong>Singular Value Decomposition</strong> (<strong>SVD</strong>). In the following example, we'll use the TensorFlow and Keras libraries to implement matrix factorization.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the Retailrocket dataset</h1>
                </header>
            
            <article>
                
<p>In this chapter, we shall showcase a recommendation system algorithm using the Retailrocket dataset. </p>
<div class="packt_infobox">The Retailrocket dataset is available from the Kaggle website, at <a href="https://www.kaggle.com/retailrocket/ecommerce-dataset">https://www.kaggle.com/retailrocket/ecommerce-dataset</a>.</div>
<p>We download the dataset using the following command:</p>
<pre><strong>kaggle datasets download -d retailrocket/ecommerce-dataset</strong></pre>
<p>The downloaded files are moved into the <kbd>~/datasets/kaggle-retailrocket</kbd> <span>folder.</span> You can keep it in whichever folder you feel comfortable with.</p>
<p>The Retailrocket dataset comes in three files:</p>
<ul>
<li><kbd>events.csv</kbd>: This file contains the visitor-item interaction data</li>
<li><span><kbd>item_properties.сsv</kbd>: This file contains </span>item properties</li>
<li><kbd>category_tree.csv</kbd>: This file contains the category tree</li>
</ul>
<p>The data contains the values collected from an e-commerce website but has been anonymized to ensure the privacy of the users. <span>The </span>interaction<span> data represents interactions over a period of 4.5 months.</span></p>
<p><span>A visitor can engage in three categories of events: <kbd>view</kbd>,</span> <kbd>addtocart</kbd>,<span> or <kbd>transaction</kbd>. The dataset has a total of 2,756,101 interactions that include 2,664,312 <kbd>view</kbd> events, 69,332 <kbd>addtocart</kbd> events, and 22,457 <kbd>transaction</kbd> events. The interactions are from 1,407,580 unique visitors.</span></p>
<p>Since the data contains the user-item interactions and not the explicit ranking of items by users, it, therefore, falls under the category of implicit feedback information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring the Retailrocket dataset</h1>
                </header>
            
            <article>
                
<p>Let's load the dataset and explore it to learn more about the data.</p>
<ol>
<li>Set the path to the folder where we downloaded the data:</li>
</ol>
<pre style="padding-left: 60px">dsroot = os.path.join(os.path.expanduser('~'),<br/>                      'datasets',<br/>                      'kaggle-retailrocket')<br/>os.listdir(dsroot)</pre>
<ol start="2">
<li>Load the <kbd>events.csv</kbd> in a pandas DataFrame:</li>
</ol>
<pre style="padding-left: 60px">events = pd.read_csv(os.path.join(dsroot,'events.csv'))<br/>print('Event data\n',events.head())</pre>
<p style="padding-left: 60px">The events data has the five columns of <kbd>timestamp</kbd>, <kbd>visitorid</kbd>, <kbd>event</kbd>, <kbd>itemid</kbd>, and <kbd>transactionid</kbd>, as shown here:</p>
<pre style="padding-left: 60px">Event data
        timestamp  visitorid event  itemid  transactionid
0  1433221332117     257597  view  355908            NaN
1  1433224214164     992329  view  248676            NaN
2  1433221999827     111016  view  318965            NaN
3  1433221955914     483717  view  253185            NaN
4  1433221337106     951259  view  367447            NaN</pre>
<ol start="3">
<li>Print the unique items, users, and transactions:</li>
</ol>
<pre style="padding-left: 60px">print('Unique counts:',events.nunique())</pre>
<p class="mce-root"/>
<p style="padding-left: 60px">We get the following output:</p>
<pre style="padding-left: 60px">Unique counts: timestamp        2750455
visitorid        1407580
event                  3
itemid            235061
transactionid      17672
dtype: int64</pre>
<ol start="4">
<li>Verify the kinds of events that we mentioned earlier:</li>
</ol>
<pre style="padding-left: 60px">print('Kind of events:',events.event.unique())</pre>
<p style="padding-left: 60px">We see the three kinds of events that we described before:</p>
<pre style="padding-left: 60px">Kind of events: ['view' 'addtocart' 'transaction']</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pre-processing the data</h1>
                </header>
            
            <article>
                
<p>Fields <kbd>visitorid</kbd> and <kbd>itemid</kbd> are already numeric, but we still need to convert the events into numeric values.</p>
<ol>
<li>We convert <kbd>view</kbd> events to <kbd>1</kbd>, <kbd>addtocart</kbd> events to <kbd>2</kbd>, and <kbd>transaction</kbd> events to <kbd>3</kbd> with the following code:</li>
</ol>
<pre style="padding-left: 60px">events.event.replace(to_replace=dict(view=1, <br/>                                     addtocart=2, <br/>                                     transaction=3), <br/>                     inplace=True)</pre>
<ol start="2">
<li>Drop the <kbd>transcationid</kbd> and <kbd>timestamp</kbd> columns that we don't need:</li>
</ol>
<pre style="padding-left: 60px">events.drop(['transactionid'],axis=1,inplace=True)<br/>events.drop(['timestamp'],axis=1,inplace=True)</pre>
<ol start="3">
<li>Shuffle the dataset to get random data for training and test datasets:</li>
</ol>
<pre style="padding-left: 60px">events = events.reindex(np.random.permutation(events.index))</pre>
<p style="padding-left: 60px">The dataset can also be shuffled with the following command:</p>
<pre style="padding-left: 60px">events = events.sample(frac=1).reset_index(drop=True)</pre>
<ol start="4">
<li>Split the data in <kbd>train</kbd>, <kbd>valid</kbd>, and <kbd>test</kbd> sets, as follows:</li>
</ol>
<pre style="padding-left: 60px">split_1 = int(0.8 * len(events))<br/>split_2 = int(0.9 * len(events))<br/>train = events[:split_1]<br/>valid = events[split_1:split_2]<br/>test = events[split_2:]<br/>print(train.head())<br/>print(valid.head())<br/>print(test.head())</pre>
<p>The <kbd>train</kbd> and <kbd>test</kbd> data is printed as follows:</p>
<pre>             timestamp  visitorid  event  itemid
1621867  1431388649092     896963      1  264947
1060311  1440610461477    1102098      1  431592
114317   1433628249991    1241997      1  283584
1658382  1431543289648     198153      1   97879
2173151  1436211020113    1278262      1  218178<br/>             timestamp  visitorid  event  itemid
1903213  1432567070061      85425      1  344338
1722815  1431708672912    1085328      1   59691
1388040  1442124865777    1366284      1  248032
2669880  1438030300131     478634      1  388940
1893864  1432416049191    1052918      1  328647<br/>             timestamp  visitorid  event  itemid
1004940  1440383070554     193171      1   11565
642906   1438664048047     704648      1  262522
902126   1439869996568      10212      1   46971
569976   1435624889084     753933      1   29489
1517206  1430856529370     261457      1  154821</pre>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The matrix factorization model for Retailrocket recommendations</h1>
                </header>
            
            <article>
                
<p><span>Now let's create a matrix factorization model in Keras:</span></p>
<ol>
<li>Store the number of visitors and items in a variable, as follows:</li>
</ol>
<pre style="padding-left: 60px">n_visitors = events.visitorid.nunique()<br/>n_items = events.itemid.nunique()</pre>
<ol start="2">
<li>Set the number of latent factors for embedding to <kbd>5</kbd>. You may want to try different values to see the impact on the model training:</li>
</ol>
<pre style="padding-left: 60px">n_latent_factors = 5</pre>
<ol start="3">
<li>Import the Input, Embedding, and Flatten layers from the Keras library:</li>
</ol>
<pre style="padding-left: 60px">from tensorflow.keras.layers import Input, Embedding, Flatten</pre>
<ol start="4">
<li>Start with the items – create an input layer for them as follows:</li>
</ol>
<pre style="padding-left: 60px">item_input = Input(shape=[1],name='Items')</pre>
<ol start="5">
<li>Create an Embedding representation layer and then flatten the Embedding layer to get the output in the number of latent dimensions that we set earlier:</li>
</ol>
<pre style="padding-left: 60px">item_embed = Embedding(n_items + 1,<br/>                           n_latent_factors, <br/>                           name='ItemsEmbedding')(item_input)<br/>item_vec = Flatten(name='ItemsFlatten')(item_embed)</pre>
<ol start="6">
<li>Similarly, create the vector space representation for the visitors:</li>
</ol>
<pre style="padding-left: 60px">visitor_input = Input(shape=[1],name='Visitors')<br/>visitor_embed = Embedding(n_visitors + 1,<br/>                          n_latent_factors,<br/>                          name='VisitorsEmbedding')(visitor_input)<br/>visitor_vec = Flatten(name='VisitorsFlatten')(visitor_embed)</pre>
<ol start="7">
<li>Create a layer for the dot product of both vector space representations:</li>
</ol>
<pre style="padding-left: 60px">dot_prod = keras.layers.dot([item_vec, visitor_vec],axes=[1,1],<br/>                             name='DotProduct') </pre>
<ol start="8">
<li>Build the Keras model from the input layers, and the dot product layer as the output layer, and compile it as follows:</li>
</ol>
<pre style="padding-left: 60px">model = keras.Model([item_input, visitor_input], dot_prod)<br/>model.compile('adam', 'mse')<br/>model.summary()</pre>
<p style="padding-left: 60px">The model is summarized as follows:</p>
<pre style="padding-left: 60px">________________________
Layer (type)                    Output Shape         Param #     Connected to                     
================================================================================
Items (InputLayer)              (None, 1)            0                                            
________________________________________________________________________________
Visitors (InputLayer)           (None, 1)            0                                            
________________________________________________________________________________
ItemsEmbedding (Embedding)      (None, 1, 5)         1175310     Items[0][0]                      
________________________________________________________________________________
VisitorsEmbedding (Embedding)   (None, 1, 5)         7037905     Visitors[0][0]                   
________________________________________________________________________________
ItemsFlatten (Flatten)          (None, 5)            0           ItemsEmbedding[0][0]             
________________________________________________________________________________
VisitorsFlatten (Flatten)       (None, 5)            0           VisitorsEmbedding[0][0]          
________________________________________________________________________________
DotProduct (Dot)                (None, 1)            0           ItemsFlatten[0][0]               
                                                                 VisitorsFlatten[0][0]            
================================================================================
Total params: 8,213,215
Trainable params: 8,213,215
Non-trainable params: 0
________________________________________________________________________________</pre>
<p>Since the model is complicated, we can also draw it graphically using the following commands:</p>
<pre>keras.utils.plot_model(model, <br/>                       to_file='model.png', <br/>                       show_shapes=True, <br/>                       show_layer_names=True)<br/>from IPython import display<br/>display.display(display.Image('model.png'))</pre>
<p class="mce-root"/>
<p>You can see the layers and output sizes clearly in this plotted visualization:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1077 image-border" src="assets/88232a90-7a0b-4964-9a4b-195d3ead67f5.png" style="width:54.25em;height:24.42em;"/></p>
<p>Now let's train and evaluate the model:</p>
<pre>model.fit([train.visitorid, train.itemid], train.event, epochs=50)<br/>score = model.evaluate([test.visitorid, test.itemid], test.event)<br/>print('mean squared error:', score)</pre>
<p>The training and evaluation loss will be very high. We can improve this by using advanced methods for matrix factorization.</p>
<p>Now, let's build the neural network model to provide the same recommendations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The neural network model for Retailrocket recommendations</h1>
                </header>
            
            <article>
                
<p>In this model, we set two different variables for latent factors for users and items but set both of them to <kbd>5</kbd>. The reader is welcome to experiment with different values of latent factors:</p>
<pre>n_lf_visitor = 5<br/>n_lf_item = 5</pre>
<ol>
<li>Build the item and visitor embeddings and vector space representations the same way we built earlier:</li>
</ol>
<pre style="padding-left: 60px">item_input = Input(shape=[1],name='Items')<br/>item_embed = Embedding(n_items + 1,<br/>                           n_lf_visitor, <br/>                           name='ItemsEmbedding')(item_input)<br/>item_vec = Flatten(name='ItemsFlatten')(item_embed)<br/><br/>visitor_input = Input(shape=[1],name='Visitors')<br/>visitor_embed = Embedding(n_visitors + 1, <br/>                              n_lf_item,<br/>                              name='VisitorsEmbedding')(visitor_input)<br/>visitor_vec = Flatten(name='VisitorsFlatten')(visitor_embed)</pre>
<ol start="2">
<li>Instead of creating a dot product layer, we concatenate the user and visitor representations, and then apply fully connected layers to get the recommendation output:</li>
</ol>
<pre style="padding-left: 60px">concat = keras.layers.concatenate([item_vec, visitor_vec], name='Concat')<br/>fc_1 = Dense(80,name='FC-1')(concat)<br/>fc_2 = Dense(40,name='FC-2')(fc_1)<br/>fc_3 = Dense(20,name='FC-3', activation='relu')(fc_2)<br/><br/>output = Dense(1, activation='relu',name='Output')(fc_3)</pre>
<ol start="3">
<li>Define and compile the model as follows:</li>
</ol>
<pre style="padding-left: 60px">optimizer = keras.optimizers.Adam(lr=0.001)<br/>model = keras.Model([item_input, visitor_input], output)<br/>model.compile(optimizer=optimizer,loss= 'mse')</pre>
<p>Let's see how this model looks visually:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1078 image-border" src="assets/dd18aa42-3786-4c6d-bb49-762d635a2e69.png" style="width:55.67em;height:52.75em;"/></p>
<ol start="4">
<li>Train and evaluate the model:</li>
</ol>
<pre style="padding-left: 60px">model.fit([train.visitorid, train.itemid], train.event, epochs=50)<br/>score = model.evaluate([test.visitorid, test.itemid], test.event)<br/>print('mean squared error:', score)</pre>
<p class="mce-root"/>
<p>We get a pretty good accuracy with a very low error rate:</p>
<pre style="padding-left: 60px">275611/275611 [==============================] - 4s 14us/step
mean squared error: 0.05709125054560985</pre>
<p>That's it. We encourage the reader to learn more about different recommendation system algorithms and try implementing them with Retailrocket or other <span>publicly available </span>datasets.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span>In this chapter, we learned about recommendation systems. We learned about different kinds of recommendation systems such as collaborative filtering, content-based filtering, and hybrid systems. We used the Retailrocket dataset to create two models of our recommendation system, one with matrix factorization, and one using a neural network. We saw that the neural network model gave pretty good accuracy.</span></p>
<p>In the next chapter, we'll learn about object detection at large scale with distributed TensorFlow.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<p class="mce-root">Enhance your understanding by practicing the following questions:</p>
<ol>
<li>What are the various algorithms for implementing vector space models for text-based content?</li>
<li>What are the various advanced algorithms for collaborative filtering?</li>
<li>How can we handle overfitting in collaborative filtering models?</li>
<li>Experiment with different algorithms apart from the ones implemented in this chapter.</li>
<li>Experiment with different values of latent factors for visitors and items.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>You'll learn more by reading the following materials:</p>
<ul>
<li>Tutorials and articles on recommender systems at the following link: <a href="http://recommender-systems.org">http://recommendation-systems.org</a></li>
<li><em>Recommendation Systems Handbook<span> </span></em><span class="a-size-large a-color-secondary a-text-normal"><em>2nd ed.</em></span><span> by </span><span class="author notFaded">Francesco Ricci<span class="contribution"><span class="a-color-secondary">, </span></span></span><span class="author notFaded"><span class="a-declarative">Lior Rokach</span><span class="contribution"><span class="a-color-secondary">, and </span></span></span><span class="author notFaded">Bracha Shapira, 2015.</span></li>
<li><em>Recommendation Systems: The Textbook.</em> by Charu C. Aggarwal, 2016.</li>
</ul>


            </article>

            
        </section>
    </body></html>