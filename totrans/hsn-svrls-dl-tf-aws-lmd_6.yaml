- en: Creating a Deep Learning Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we studied the creation of the API gateway service using
    the AWS Console, as well as the serverless framework. In this chapter, we will
    learn about creating SQS connections using the AWS console, as well as the serverless
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Message queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing AWS simple query service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating AWS SQS using AWS console and serverless framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample projects—deep learning pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS subscription
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find all the codes at [https://github.com/PacktPublishing/Hands-On-Serverless-Deep-Learning-with-TensorFlow-and-AWS-Lambda](https://github.com/PacktPublishing/Hands-On-Serverless-Deep-Learning-with-TensorFlow-and-AWS-Lambda)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The message queue is an important additional method of interaction within different
    services. While the RESTful API has a timeout limit, the message queue doesn't
    have this kind of drawback. Therefore, it helps to handle long-running processes
    or delayed messages. Also, it allows a more uniform load on the backend. It does
    not have a critical feature for working with AWS Lambda, since Lambda can easily
    scale, but it can be very useful when dealing with clusters. Finally, the message
    queue allows retry logic, meaning that failed tasks can be sent back multiple
    times. Now let's look more into AWS SQS.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to AWS SQS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basically, this is an AWS service that allows the sending, receipt, and storage
    of messages. It can be connected to any processing backend. It has a pay-as-you-go
    system, which makes it very convenient as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: AWS API gateway features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The different features of AWS API are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is extremely scalable, and you don't have to manage any other scaling in
    the queue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service handles access from readers to the queue, so it's something that
    you don't have to implement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQS has a customizable retry mechanism that increases the probability of avoiding
    errors, which improves the overall speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQS provides very simple APIs, which you can use in almost any programming language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it provides encryption, which could be useful for improving the security
    of your service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS SQS pricing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main advantages of SQS is the pay-per-user-go system, which is very
    simple. Pricing is 50 cents per 1 million requests and the first one million requests
    are free every month. This makes it perfect for early projects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AWS SQS connection using an AWS Console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will initially create an AWS Lambda, and then create the
    simple query service, before connecting SQS to AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AWS Lambda instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps for creating the AWS Lambda instance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the name under Name, choose Runtime as Python 3.6, set Role as Choose
    an  existing role, then from Existing role choose `lambda1`, and click on Create
    function, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b385768b-6389-4a9a-b300-15f253d821fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Lambda function is created as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8089ef55-5533-4e14-8202-9c5019c94c65.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, switch to SQS and create a SQS queue by selecting Create New Queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/21706e6c-9e8f-4625-9f1d-0959623d93c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After creating a queue named testLambda, we get the SQS ARN as highlighted
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ec3309d6-7bfb-4622-91c7-1275fda63a64.png)'
  prefs: []
  type: TYPE_IMG
- en: '5\. From the Designer tab on the left, choose SQS as the trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc60d8d0-5246-477b-b9eb-ff3fe1531127.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will send some messages to the queue by selecting Send a Message from the Queue
    Actions drop-down list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ed4cad1c-a03e-4867-960f-b11cc4bf5a2a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we have only one message available, meaning they all were consumed
    by Lambda as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/df0aaea3-c35d-4cab-9ebc-5c4a60f81224.png)'
  prefs: []
  type: TYPE_IMG
- en: '8\. By clicking Monitoring, we get a detailed overview as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0113f961-b532-4d60-8549-d41511dae11e.png)'
  prefs: []
  type: TYPE_IMG
- en: We also get to see the log details by clicking on View logs in CloudWatch as
    shown in the preceding screeenshot. Each start and end means invocation for each
    message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next section concerns the creation of an AWS SQS connection to AWS Lambda
    using the serverless framework.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AWS SQS connection using the serverless framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create the SQS connection, we have the main Python file and the serverless
    configuration file. The configuration file will be a little complex. We will need
    to define SQS in the resources section, edit as event source for Lambda, and then
    enable Lambda to read from SQS.
  prefs: []
  type: TYPE_NORMAL
- en: The Python file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main difference for the Python file will be that, instead of returning
    a string, we will write to another SQS query, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc7425d7-37a2-48f1-b35b-782328043304.png)'
  prefs: []
  type: TYPE_IMG
- en: Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting with the code, we will first need to deploy the serverless framework,
    and then we need to check that it runs using the command-line interface. We will
    run the code using the `index.py` file and the `serverless.yml` configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: serverless.yml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `serverless.yml` file, we can see all the sections that we discussed
    in the previous chapters, especially the part where we define the role for accessing
    the query from where we will read messages, and to which our Lambda will write.
    The following code shows the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to define that one of the queries will act as an event source,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define the queries, which we can perform in the resource section
    as shown in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we will need to use the plugin `serverless-pseudo-parameters`, which
    we will install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to remove the package with the preceding plugin from the `deployment`
    package as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is to use this plugin to access the ID of the region that we use and our
    account ID as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can access the account ID and the ID of a region without this plugin and
    just manually find it as well.
  prefs: []
  type: TYPE_NORMAL
- en: index.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `index.py` file is very simple. We just read incoming messages and then
    write them as SQS. The following shows the code for `index.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see the preceding `index.py` and `serverless.yml` files in the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to install plugin, `serverless-pseudo-parameters`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9dd7aebe-03eb-4ce7-a058-f94aedccba8a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will deploy Lambda using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the plugin replaced the region with the actual base region
    and account as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/142a3105-5000-478e-b270-2200cdb679cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To send a message through the queue, first we need to find the queue URL using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the queue URL, we can send messages. We see the command executed successfully
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4762bea-b362-4ada-8bad-fd11a49424fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can read the same message from the SQS queue. Basically, here we can
    check  whether Lambda has received the message that we have sent, which is `Hello
    world1`, and send it to write SQL. We see that Lambda works successfully and we
    can see the resulting message, `Hello world1`, in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ff07274-2898-49de-a34a-7b2814427375.png)'
  prefs: []
  type: TYPE_IMG
- en: Example project – deep learning pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the project files, we have the main Python file, the serverless configuration
    file, libraries files, and an inception module. The configuration file will be
    the same as the one we used in the previous chapter. We will look at the Python
    file. The main difference for our Python file will be that, instead of returning
    the string, we will send a message to another SQS query. Also, we will make Lambda
    accept the link to the image in the message, and then apply module to structure
    it. The deployment will be similar to the one in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: We will skip the deployment of the model, since we have covered it before.
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will need to deploy the serverless framework, and then we can check
    that it runs using the command-line interface. We have the `index.py` file and
    the `serverless.yml` configuration file. We also have libraries for TensorFlow
    and pre-installed plugins for the serverless framework.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration file - serverless.yml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can see that the current configuration file is taken from the preceding sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a bucket where we keep our model, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an event source for Lambda and resources, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: index.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `index.py` file, the script looks the same way as it did in the previous
    section. An additional part has been added, which is reading the URL from the
    message and writing the result to another queue. The following is the code snippet
    for `index.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the part where we retrieve the image and run
    our model on it, and hence, we write the result of the model to another queue,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s deploy the service as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27e1f796-47b8-4291-a5d8-4ddc64f8cc6f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will send the message with a URL to the first queue. This can be done with
    the command-line interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6c11837-4ede-4d69-9d6e-1c912ec9d3ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can read the sent message from another queue as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05cee0bc-e1e1-4439-bd50-381b227977bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were introduced to AWS SQS, which included the features
    as well as a look at its pricing. We also created AWS SQS connection using both
    the AWS console and the serverless framework.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about the deployment of the `serverless.yml`  configuration file
    and the `index.py` file. This chapter concluded with an example project, which
    was a deep learning pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about creating crossing workflow by connecting
    an AWS Lambda instance and AWS functions where we will learn how to make deep
    learning workflow.
  prefs: []
  type: TYPE_NORMAL
