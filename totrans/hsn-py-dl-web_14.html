<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Securing Web Apps with Deep Learning</h1>
                </header>
            
            <article>
                
<p>Security is of the utmost importance to any website—and all software, in general. These days, security threats are evolving with the rise of available computing power and developments in the field of technology. So, it is important that websites employ the best possible measures of security to keep their data and user information secure. Websites with online commercial activities are always at high risk and it is very common for them to face security attacks that have not been seen before. New attacks are particularly difficult for rule-based security systems to identify and stop; so, you can look at the options offered by deep learning-powered security systems, which can effectively replace rule-based systems and are also capable of correctly identifying and blocking new threats. </p>
<p>This chapter discusses several tricks and techniques that you can use to secure websites using deep learning with Python. We will present reCAPTCHA and Cloudflare and discuss how they are used to enhance the security of websites. We will also show you how to implement security mechanisms to detect malicious users on websites using deep learning-based techniques and a Python backend. The following topics will be covered in this chapter:</p>
<ul>
<li>The story of <span>reCAPTCHA</span></li>
<li><span>DIY – malicious user detection on Django</span></li>
<li><span>Using reCAPTCHA in web applications with Python</span></li>
<li>Website security with Cloudflare</li>
</ul>
<p>We will begin this chapter's discussion with the story of <span>reCAPTCHA—</span>an ingenious tool, created by Google, that changed the internet.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You can access the code for this chapter at <a href="https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter10">https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter10</a>.</p>
<p>You'll need the following software to run the code in this chapter:</p>
<ul>
<li>Python 3.6+</li>
<li>TensorFlow 1.14</li>
<li>Keras compatible with TensorFlow 1.14</li>
<li>Django 2.x</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The story of reCAPTCHA</h1>
                </header>
            
            <article>
                
<p><em>Easy on Humans, Hard on Bots</em>—that is the tagline of <span>reCAPTCHA, which</span> states the simple idea that <span>reCAPTCHA</span> is a system that establishes whether a user on an application or website is a genuine human user or an automated script. <span>reCAPTCHA</span><span> is a specific implementation of the CAPTCHA technology—a method that uses visuals with distorted, squiggly letters and numbers and challenges the user to decipher the contents of the visual image and write it out in a plain format. </span></p>
<p>If you were a regular internet user in the early 2000s, you would have seen images resembling the following CAPTCHA on a number of websites:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1270 image-border" src="assets/bdf82cb8-25df-4316-ab30-7c488e38f119.png" style="width:22.50em;height:15.08em;"/></p>
<div class="packt_infobox"><strong>CAPTCHA</strong> is an acronym for <strong>Completely Automated Public Turing Test To Tell Computers and Humans Apart</strong>. </div>
<p>Popularized by Yahoo, the CAPTCHA system was rapidly adopted for use on millions of websites. However, despite the boost to security this system provided to websites, it was time-consuming and was often being beaten by rogue programmers. Every so often, people would create new CAPTCHA systems with varied designs and combinations of elements in the visuals.</p>
<p>At the same time, developers were tackling a very different problem—one of digitizing printed books and other texts. A quick solution was to scan books; that is, using an <strong>Optical Character Reader</strong> (<strong>OCR</strong>) to convert books into preliminary digital text form. The conversions were fine for printed content that was made with standard fonts and whose scans were obtainable in good quality. However, the conversion accuracy suffered for malformed prints and manuscripts. People were increasingly uploading images to online platforms in the quest to extract text from those images and to use them for several purposes, such as determination of content in images, locations, or brands mentioned. </p>
<div class="packt_infobox">The origin of CAPTCHA is disputed with claims of invention from multiple groups, but it was in 2003 that Luis von Ahn coined the term CAPTCHA, and he later became the founder of reCAPTCHA, which was acquired by Google.</div>
<p>A pioneer of crowdsourcing, Luis von Ahn used the <span>reCAPTCHA</span> program to display very small chunks of text cropped from scans of printed books. Only humans would be able to solve these challenges easily, and automated programs would fail. At the same time, these books were being slowly digitized by contributions from a large number of human users, through unknown crowdsourcing activity. <span>reCAPTCHA</span> still remained a nuisance for users but the issue of digitizing books was solved.</p>
<p>Over time, <span>reCAPTCHA</span> evolved to use AI-based systems to identify real and fake users. At the time of writing this book, <span>reCAPTCHA</span> is being actively developed by Google and is currently on its third version, where it allows the invisible verification of users in the background of the web page and only displays a challenge when the user cannot be successfully verified. This saves a lot of time for genuine users and poses a challenge to machines.</p>
<p>We will now build a website to use deep learning-based models and <span>reCAPTCHA</span> to provide security elements to a website.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Malicious user detection</h1>
                </header>
            
            <article>
                
<p>A malicious user on a website is any user who attempts to perform tasks that they are not authorized to do. In today's world, the threats posed by malicious users are increasing exponentially, with huge databases of personal information from several global tech giants, government agencies, and other private firms being exposed to the public by hackers. It is important to have systems <span>in place</span><span> </span><span>that can automatically mitigate these malicious attacks. </span></p>
<p>In order to recognize the malicious users in our sample web app, we have created a model that is able to learn the usual behavior of a user and raises the alarm if the user behavior at any instance changes significantly from their past usage. </p>
<p>Anomaly detection is a popular branch of machine learning. It is a collection of algorithms that are used to detect data samples in a given dataset that do not fall along with the majority of the data sample properties. To detect a cat in a dog shelter would be anomaly detection. Anomaly detection is performed in several ways:</p>
<ul>
<li>By using minimum-maximum ranges of columns</li>
<li>By finding out sudden spikes in the plots of the data</li>
<li>By marking points lying on the extreme ends as outliers (anomalies) when data is plotted under a Gaussian curve</li>
</ul>
<p>Support vector machines, k-nearest neighbors, and <span>Bayesian networks are some of the most popular algorithms used for anomaly detection.</span> </p>
<p>How can we define usual behavior for users on a website?</p>
<p>Assume that you use a website where you normally log in using your laptop. Mostly, it takes you a maximum of two attempts to successfully log in to the website. If one day you suddenly start using a new laptop, the login would be suspicious and would probably be a malicious attempt to hack your account. It would be more so if the location of the new device was somewhere you have not been to recently or ever before. It would also be highly suspicious if you took 10 attempts to log in to your account. The state of not being in any suspicious state of usage is the usual behavior of the user on a website.</p>
<p>Sometimes, the anomaly may not be due to the irregular behavior of any specific user. Due to changes in the server, the regular traffic of the users and so their behavior might change. We have to be careful to not mark all users as malicious in such circumstances. Also, the irregular behavior of a user may be caused due to reasons other than hacking attempts on their account. If a genuine user suddenly starts accessing parts of the website that they should not have access to, it is an anomaly and needs to be prevented. </p>
<p>In our sample website, we will integrate a system like this. To do so, we will be putting a check on the login page of the website where we will try to determine whether a user's login is normal or anomalous. We will be taking into consideration the page that the user logs in from, as a website may have multiple login pages, and try to determine whether it is a usual page for the user to login from. If the user attempts to log in from a page that they generally do not log in from, we will mark it as an anomaly. This is just one simple criterion for checking anomalous users, with a scope of several hundreds of other parameters. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An LSTM-based model for authenticating users</h1>
                </header>
            
            <article>
                
<p>We will break down this section into two major sub-sections:</p>
<ol>
<li>Building the security check model</li>
<li>Hosting the model as an API</li>
</ol>
<p>Let's begin with the first section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a model for an authentication validity check</h1>
                </header>
            
            <article>
                
<p>To authenticate the user based on their login activity, we will need an API that checks the requests. We can build this model using the following steps:</p>
<ol>
<li class="mce-root"><span>Let's begin by developing the authentication model that determines whether a user is not acting in a regular manner. We begin by importing the necessary modules in a Jupyter notebook running Python 3.6+, as shown:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">import sys<br/>import os<br/>import json<br/>import pandas<br/>import numpy<br/>from keras.models import Sequential<br/>from keras.layers import LSTM, Dense, Dropout<br/>from keras.layers.embeddings import Embedding<br/>from keras.preprocessing import sequence<br/>from keras.preprocessing.text import Tokenizer<br/>from collections import OrderedDict</pre>
<ol start="2">
<li class="mce-root">We <span>can now import the data into the project. We will be using the dataset at </span><a href="https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/model/data/data-full.csv">https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/model/data/data-full.csv</a><span>. We load the dataset into the project, as shown:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">file = 'data-full.csv'<br/><br/>df = pandas.read_csv(file, quotechar='|', header=None)<br/>df_count = df.groupby([1]).count()<br/>total_req = df_count[0][0] + df_count[0][1]<br/>num_malicious = df_count[0][1]<br/><br/>print("Malicious request logs in dataset: {:0.2f}%".format(float(num_malicious) / total_req * 100))</pre>
<p style="padding-left: 60px" class="mce-root"><span>You will see some general statistics about the data, as shown:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1272 image-border" src="assets/db398383-b1d7-407a-9f2a-ed4f4223c548.png" style="width:24.33em;height:6.17em;"/></p>
<p style="padding-left: 60px" class="CDPAlignLeft CDPAlign">You will observe that the data contains text, as shown:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1273 image-border" src="assets/8d84d0b7-32b3-4ac3-a3d1-d1ba262ee005.png" style="width:31.42em;height:19.58em;"/></p>
<p style="padding-left: 60px">This observation is important and we'll be referring to this screenshot in future steps.</p>
<ol start="3">
<li>However, all the data is in string format. We need to convert it into appropriate types of values. Also, the dataset currently consists of just one DataFrame; we will break it into two parts—the training columns and the labels column—with the following code:</li>
</ol>
<pre style="padding-left: 60px">df_values = df.sample(frac=1).values<br/><br/>X = df_values[:,0]<br/>Y = df_values[:,1]</pre>
<ol start="4">
<li class="mce-root">Also<span>, we need to lose some of the columns as we only want to use features in the dataset that are relevant to our task:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">for index, item in enumerate(X):<br/>    req = json.loads(item, object_pairs_hook=OrderedDict)<br/>    del req['timestamp']<br/>    del req['headers']<br/>    del req['source']<br/>    del req['route']<br/>    del req['responsePayload']<br/>    X[index] = json.dumps(req, separators=(',', ':'))</pre>
<ol start="5">
<li class="mce-root">With <span>this done, we are now ready to proceed with tokenizing the request body. Tokenizing is a method where we break large paragraphs down into sentences and sentences into words. We can perform tokenization with the following code:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">tokenizer = Tokenizer(filters='\t\n', char_level=True)<br/>tokenizer.fit_on_texts(X)</pre>
<ol start="6">
<li class="mce-root">With <span>the tokenization done, we convert each request body entry into vectors. We do so because we need a numerical representation of the data for the computer to be able to perform calculations on it. After that, we further split the dataset into two more parts—75% of the dataset is for training and the rest is for testing purposes. Similarly, the labels column is split using the following code:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">num_words = len(tokenizer.word_index)+1<br/>X = tokenizer.texts_to_sequences(X)<br/><br/>max_log_length = 1024<br/>split = int(len(df_values) * .75)<br/><br/>X_processed = sequence.pad_sequences(X, maxlen=max_log_length)<br/>X_train, X_test = X_processed[0:split], X_processed[split:len(X_processed)]<br/>Y_train, Y_test = Y[0:split], Y[split:len(Y)]</pre>
<p style="padding-left: 60px" class="CDPAlignLeft CDPAlign">Remember from step 2 that this data mainly contained text. When it comes to text data, there is most likely a context and a specific order associated with it.<br/>
<br/>
For example, consider the words of this sentence—<em>Sachin Tendulkar is a great cricketer</em>. The order of the words must not be changed in order to convey the expected meaning. This is where the importance of maintaining order and context comes into the picture when you deal with text data in machine learning.</p>
<p style="padding-left: 60px" class="CDPAlignLeft CDPAlign">In our case, we will use a special type of recurrent neural network—<strong>Long Short-Term Memory</strong> (<strong>LSTM</strong>)—which will learn to recognize the regular user behavior.</p>
<div class="CDPAlignLeft CDPAlign packt_infobox"><br/>
A detailed discussion on LSTM is beyond the scope of this book but if you are interested, you can refer to <a href="http://bit.ly/2m0RWnx">http://bit.ly/2m0RWnx</a><span> to learn about it in detail.<br/></span></div>
<ol start="7">
<li class="mce-root">We now <span>add the layers, along with the word embeddings, which helps maintain the relationship between the numerically encoded text and the actual words, using the following code: </span></li>
</ol>
<pre style="color: black;padding-left: 60px">clf = Sequential()<br/>clf.add(Embedding(num_words, 32, input_length=max_log_length))<br/>clf.add(Dropout(0.5))<br/>clf.add(LSTM(64, recurrent_dropout=0.5))<br/>clf.add(Dropout(0.5))<br/>clf.add(Dense(1, activation='sigmoid'))</pre>
<p style="padding-left: 60px" class="mce-root"><span>Our output is a single neuron that either holds <kbd>0</kbd> or <kbd>1</kbd> in the case of a non-anomalous or an anomalous login attempt, respectively.</span></p>
<ol start="8">
<li class="mce-root">We <span>then compile the model and print a summary using the following code:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">clf.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])<br/>print(clf.summary())</pre>
<p class="mce-root"><span> The summary of the model is produced, as shown:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1274 image-border" src="assets/0a057f86-a447-49f8-a185-d82dc84ada58.png" style="width:34.92em;height:18.75em;"/></p>
<p>Now, we are ready to move on to training the model:</p>
<ol>
<li class="mce-root"><span>We use the</span> <kbd>fit()</kbd> <span>method of the</span> model<span> as shown: </span></li>
</ol>
<pre style="color: black;padding-left: 60px">clf.fit(X_train, Y_train, validation_split=0.25, epochs=3, batch_size=128)</pre>
<ol start="2">
<li class="mce-root">We <span>will quickly check the accuracy achieved by the model. We can see that the model is more than 96% accurate on the validation data</span><span>. This score is quite impressive given that this is our first model. We can check the accuracy of the model using the following code: </span></li>
</ol>
<pre style="color: black;padding-left: 60px">score, acc = clf.evaluate(X_test, Y_test, verbose=1, batch_size=128)<br/>print("Model Accuracy: {:0.2f}%".format(acc * 100))</pre>
<p style="padding-left: 60px" class="mce-root"><span>You should see an output as in this screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1275 image-border" src="assets/15fc01ad-104b-40c0-a6f4-5490fed2bbf6.png" style="width:35.58em;height:4.00em;"/></p>
<ol start="3">
<li class="mce-root">Let's <span>save these weights. We will use them to create an API that is used for authenticating the users. We can save the model using the following code:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">clf.save_weights('weights.h5')<br/>clf.save('model.h5')</pre>
<p>With the model ready, we can now move on to hosting it as a Flask API.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hosting the custom authentication validation model</h1>
                </header>
            
            <article>
                
<p>Let's now create the API that will accept the login attempt from the user and return its confidence in the validity of the login:</p>
<ol>
<li>We begin by importing the required modules for creating a Flask server, as shown:</li>
</ol>
<pre style="padding-left: 60px">from sklearn.externals import joblib<br/>from flask import Flask, request, jsonify<br/>from string import digits<br/><br/>import sys<br/>import os<br/>import json<br/>import pandas<br/>import numpy<br/>import optparse<br/>from keras.models import Sequential, load_model<br/>from keras.preprocessing import sequence<br/>from keras.preprocessing.text import Tokenizer<br/>from collections import OrderedDict</pre>
<ol start="2">
<li>We now need to import the saved model and weights from the <kbd>model</kbd> training step. Once we do so, we need to recompile the model and make its <kbd>predict</kbd> function using the <kbd>make_predict_function()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">app = Flask(__name__)<br/><br/>model = load_model('lstm-model.h5')<br/>model.load_weights('lstm-weights.h5')<br/>model.compile(loss = 'binary_crossentropy', optimizer = 'adam', metrics = ['accuracy'])<br/>model._make_predict_function()</pre>
<ol start="3">
<li>We will be using a data cleaning function to strip out numbers and other non-useful text in the incoming queries from the client app:</li>
</ol>
<pre style="padding-left: 60px">def remove_digits(s: str) -&gt; str:<br/>    remove_digits = str.maketrans('', '', digits)<br/>    res = s.translate(remove_digits)<br/>    return res</pre>
<ol start="4">
<li>Next, we create the <kbd>/login</kbd> route in the app, which will accept the login credentials and other request header details from the client app when the user attempts to log in. Notice that we still drop out some extra request headers as we did during the training.</li>
<li class="mce-root">Once <span>we clean the data, we tokenize and vectorize it. These steps are the same as the preprocessing we did during training. This is to ensure that the incoming request is processed exactly as it was during the training phase:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">@app.route('/login', methods=['GET, POST'])<br/>def login():<br/>    req = dict(request.headers)<br/>    item = {}<br/>    item["method"] = str(request.method)<br/>    item["query"] = str(request.query_string)<br/>    item["path"] = str(request.path)<br/>    item["statusCode"] = 200<br/>    item["requestPayload"] = []<br/><br/>    X = numpy.array([json.dumps(item)])<br/>    log_entry = "store"<br/><br/>    tokenizer = Tokenizer(filters='\t\n', char_level=True)<br/>    tokenizer.fit_on_texts(X)<br/>    seq = tokenizer.texts_to_sequences([log_entry])<br/>    max_log_length = 1024<br/>    log_entry_processed = sequence.pad_sequences(seq, maxlen=max_log_length)<br/><br/>    prediction = model.predict(log_entry_processed)<br/>    print(prediction)<br/>    response = {'result': float(prediction[0][0])}<br/>    return jsonify(response)</pre>
<p style="padding-left: 60px" class="mce-root"><span>Finally, the app returns its confidence in the user being authenticated in the form of a JSON.</span></p>
<ol start="6">
<li>To run the server on the desired port, we need to add the following lines at the end of the script:</li>
</ol>
<pre style="padding-left: 60px">if __name__ == '__main__':<br/>    app.run(port=9000, debug=True)</pre>
<ol start="7">
<li>Lastly, we save the server script file as <kbd>main.py</kbd>. We will get the server running by using the following command on the system:</li>
</ol>
<pre style="padding-left: 60px"><strong>python main.py</strong></pre>
<p>This will start the Flask server, which listens in on the loopback IP <kbd>127.0.0.1</kbd>, and at port <kbd>9000</kbd>. You can easily host this script on a virtual machine in the cloud and make it available to all your apps and websites as a common security checkpoint API.</p>
<p>We can now move on to creating our web app that runs on the Django framework.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A Django-based app for using an API</h1>
                </header>
            
            <article>
                
<p>The website that we are creating to consume the user-authentication check API will be a simple billboard demo. The website will have provisions for users to log in and then post bills to a billboard. While the app is simple, it contains two major features of deep learning-based security integrations—anomaly detection during user authentication and the implementation of <span>reCAPTCHA</span> during posting bills—to avoid spam.</p>
<p>The steps to create the application are discussed in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Django project setup</h1>
                </header>
            
            <article>
                
<p>In this section, we'll be working with Django. Make sure that you have a working Django installation on your system before proceeding with this section. You can find installation instructions for Django in the <em>A brief introduction to Django web development</em> section in <a href="3bf31fe1-d41c-4410-a83c-1651da439c70.xhtml"/><a href="3bf31fe1-d41c-4410-a83c-1651da439c70.xhtml">Chapter 8</a><a href="3bf31fe1-d41c-4410-a83c-1651da439c70.xhtml" target="_blank"/><em>, Deep Learning on Microsoft Azure Using Python</em>.</p>
<p>Now, we will create a Django project. To do so, we use the following command: </p>
<pre><strong>django-admin startproject webapp</strong></pre>
<p>This will create the <kbd>webapp</kbd><span> </span><span>directory</span><span> in the current folder. We will be adding all of our future code in this directory. The current directory structure looks as follows: </span></p>
<pre><span class="n">webapp</span><span class="o">/</span>
    <span class="n">manage</span><span class="o">.</span><span class="n">py</span>
    <span class="n">webapp</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">py</span>
        <span class="n">urls</span><span class="o">.</span><span class="n">py</span>
        <span class="n">wsgi</span><span class="o">.</span><span class="n">py<br/>    db.sqlite3<br/></span></pre>
<p>With this done, we are now ready to create an app inside the project, which is shown in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an app in the project</h1>
                </header>
            
            <article>
                
<p>As discussed in <a href="3bf31fe1-d41c-4410-a83c-1651da439c70.xhtml">Chapter 8</a>, <em>Deep Learning on Microsoft Azure Using Python</em>, we must now add apps to the website project. To do so, we use the following command:</p>
<pre><strong>cd webapp</strong><br/><strong>python manage.py startapp billboard</strong></pre>
<p>The preceding command will create an app called <kbd>billboard</kbd> in the project. However, we still have to link this app to the project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Linking the app to the project</h1>
                </header>
            
            <article>
                
<p>To add the app to the project, we need to add the app name to the list of apps in <kbd>settings.py</kbd> in the project settings file, as in the following code. In <kbd>settings.py</kbd>, add the following change:</p>
<pre># Application definition<br/><br/>INSTALLED_APPS = [<br/>    'billboard',  # &lt;---- ADD THIS LINE<br/>    'django.contrib.admin',<br/>    'django.contrib.auth',<br/>    'django.contrib.contenttypes',<br/>    'django.contrib.sessions',<br/>    'django.contrib.messages',<br/>    'django.contrib.staticfiles',<br/>]</pre>
<p>With this, we are ready to create the routes on the website.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding routes to the website</h1>
                </header>
            
            <article>
                
<p>To add routes to the project, we edit the <kbd>urls.py</kbd> file of <kbd>webapp</kbd>:</p>
<pre>from django.contrib import admin<br/>from django.urls import path, include # &lt;--- ADD 'include' module<br/><br/>urlpatterns = [<br/>    path('', include('billboard.urls')), # &lt;--- ADD billboard.urls path<br/>    path('admin/', admin.site.urls),<br/>]</pre>
<p>However, the <kbd>billboard.urls</kbd> path does not exist. We'll create the path to proceed.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the route handling file in the billboard app</h1>
                </header>
            
            <article>
                
<p>Create a new file, called <kbd>urls.py</kbd>, in the <kbd>billboard</kbd> folder, as shown:</p>
<pre>from django.urls import path<br/>from django.contrib.auth.decorators import login_required<br/><br/>from . import views<br/><br/>urlpatterns = [<br/>    path('', login_required(views.board), name='View Board'),<br/>    path('add', login_required(views.addbill), name='Add Bill'),<br/>    path('login', views.loginView, name='Login'),<br/>    path('logout', views.logoutView, name='Logout'),<br/>]</pre>
<p>Save this as <kbd>webapp/billboard/urls.py</kbd>. Notice that we have imported some <kbd>views</kbd> items to this route handling file. Also, we have used the <kbd>login_required</kbd> method. This indicates that we can start working on the authentication of the website.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding authentication routes and configurations</h1>
                </header>
            
            <article>
                
<p>To add the routes for authentication, add the following at the end of the <kbd>webapp/settings.py</kbd> file:</p>
<pre>LOGIN_URL = "/login"<br/>LOGIN_REDIRECT_URL = '/'<br/>LOGOUT_REDIRECT_URL = '/logout'</pre>
<p>These lines indicate that we will need a <kbd>/login</kbd> and a <kbd>/logout</kbd> route. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the login page</h1>
                </header>
            
            <article>
                
<p>To create the login page, we'll need to add the <kbd>/login</kbd> route to <kbd>urls.py</kbd> in the billboard app. However, we've already done that. Next, we need to add the <kbd>loginView</kbd> view to the <kbd>views.py</kbd> file of the billboard app:</p>
<pre>def loginView(request):<br/>    if request.user.is_authenticated:<br/>        return redirect('/')<br/>    else:<br/>        if request.POST:<br/>            username = request.POST['username']<br/>            password = request.POST['password']<br/>            user = authenticate(request, username=username, password=password)<br/>            ## MORE CODE BELOW THIS LINE<br/>            <br/>            ## MORE CODE ABOVE THIS LINE<br/>            else:<br/>                return redirect('/logout')<br/>        else:<br/>            template = loader.get_template('login.html')<br/>            context = {}<br/>            return HttpResponse(template.render(context, request))</pre>
<p>The preceding function first checks whether the username and password being passed to it exist in the user database. So, we'll need a user model, in the future, to store users in the database file, <kbd>db.sqlite3</kbd>, which was created during the project creation step.</p>
<p>The function will then make a call to the authentication check model API to validate whether the user login is of normal behavior. The validation is carried out as in the following code:</p>
<pre>def loginView(request):<br/>    ...<br/>            ## MORE CODE BELOW THIS LINE            <br/>            if user is not None:<br/>                url = 'http://127.0.0.1:9000/login'<br/>                values = { 'username': username, 'password': password }<br/>                data = urllib.parse.urlencode(values).encode()<br/>                req = urllib.request.Request(url, data=data)<br/>                response = urllib.request.urlopen(req)<br/>                result = json.loads(response.read().decode())<br/>                if result['result'] &gt; 0.20:<br/>                    login(request, user)<br/>                    return redirect('/')<br/>                else:<br/>                    return redirect('/logout')<br/>            ## MORE CODE ABOVE THIS LINE<br/>    ...</pre>
<p>The preceding code block validates the user login and, if it's found to be invalid, performs a logout action and redirects the user back to log in again.</p>
<p>We'll need to add some necessary imports to the <kbd>view.py</kbd> file for this, as shown: </p>
<pre>from django.shortcuts import redirect<br/>from django.contrib.auth import authenticate, login, logout<br/><br/>from django.http import HttpResponse<br/>from django.template import loader<br/><br/>from django.conf import settings<br/>from django.urls import reverse_lazy<br/>from django.views import generic<br/><br/>from django.contrib.auth.models import User<br/><br/>import urllib<br/>import ssl<br/>import json</pre>
<p>Notice that we also imported the <kbd>logout</kbd> method from <kbd>django.contrib.auth</kbd>. This will be used to create a <kbd>logout</kbd> view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a logout view</h1>
                </header>
            
            <article>
                
<p>Now, let's create the <kbd>logout</kbd> view. This is very simple to do, as shown: </p>
<pre>def logoutView(request):<br/>    logout(request)<br/>    return redirect('/')</pre>
<p>Now, let's create a template of the login page. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a login page template</h1>
                </header>
            
            <article>
                
<p>To create a template, we first need to create the folders required. </p>
<p>Create a folder called <kbd>templates</kbd> in the <kbd>billboard</kbd> directory. The directory structure will now look as in the following code: </p>
<pre><span class="n">webapp</span><span class="o">/</span>
    <span class="n">manage</span><span class="o">.</span><span class="n">py</span>
    <span class="n">webapp</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">py</span>
        <span class="n">urls</span><span class="o">.</span><span class="n">py</span>
        <span class="n">wsgi</span><span class="o">.</span><span class="n">py</span><br/>    billboard/<br/>        templates/<br/>        ___init_.py<br/>        admin.py<br/>        apps.py<br/>        models.py<br/>        tests.py<br/>        urls.py<br/>        views.py</pre>
<p>Inside the <kbd>templates</kbd> folder, we'll place our template files. Let's first create <kbd>base.html</kbd>, which we will extend in all other templates. This will contain the <kbd>CSS</kbd> and <kbd>JS</kbd> includes, along with the general block structure of the page.</p>
<div class="packt_infobox">We have provided a sample of this file at <a href="https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/webapp/billboard/templates/base.html">https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/webapp/billboard/templates/base.html</a>.</div>
<p>Once this is done, we're ready to create the <kbd>login.html</kbd> file, which will carry out the process of sending the login values to the server:</p>
<pre>{% extends 'base.html' %}<br/>{% block content %}<br/>&lt;div class="container"&gt;<br/>    &lt;div class="row"&gt;<br/>        &lt;div class="form_bg"&gt;<br/>            &lt;form method="post"&gt;<br/>                {% csrf_token %}<br/>                &lt;h2 class="text-center"&gt;Login Page&lt;/h2&gt;<br/>                # WE'LL ADD MORE CODE BELOW THIS LINE<br/>                ...<br/>                # WE'LL ADD MORE CODE ABOVE THIS LINE<br/>            &lt;/form&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>&lt;/div&gt;<br/>{% endblock %}</pre>
<p>Notice that we have extended the <kbd>base.html</kbd> template in the preceding view template.</p>
<div class="packt_infobox">You can read more about extending Django templates at <a href="https://tutorial.djangogirls.org/en/template_extending/">https://tutorial.djangogirls.org/en/template_extending/</a>.</div>
<p>The form in this login page makes a <kbd>POST</kbd> request and so requires the passing of the CSRF token. We can now create the page that renders after the login is done.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The billboard page template</h1>
                </header>
            
            <article>
                
<p>Since we've already set up the <kbd>base.html</kbd> file, we can simply extend it in the <kbd>board.html</kbd> template file<span> </span><span>to create the billboard display page</span><span>:</span></p>
<pre>{% extends 'base.html' %}<br/>{% block content %}<br/>&lt;div class="container"&gt;<br/>    &lt;div class="row"&gt;<br/>        {% for bill in bills %}<br/>        &lt;div class="col-sm-4 py-2"&gt;<br/>            &lt;div class="card card-body h-100"&gt;<br/>                &lt;h2&gt;{{ bill.billName }}&lt;/h2&gt;<br/>                &lt;hr&gt;<br/>                &lt;p&gt;<br/>                    {{ bill.billDesc }}<br/>                &lt;/p&gt;<br/>                &lt;a href="#" class="btn btn-outline-secondary"&gt;{{ bill.user.username }}&lt;/a&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>        {% endfor %}<br/>    &lt;/div&gt;<br/>&lt;/div&gt;<br/>{% endblock %}</pre>
<p>In the preceding block of code, we have iterated over all the available <kbd>bills</kbd> items in the billboard's database and displayed them using a <kbd>for</kbd> loop in the template. The use of the <kbd>base.html</kbd> template allows us to reduce the amount of repeated code in the view templates. </p>
<p>After this, we will create the page that will have the code to add a new bill to the billboard. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding to Billboard page template</h1>
                </header>
            
            <article>
                
<p>To create the page template that adds a bill to the billboard, we use the following code to create the <kbd>add.html</kbd> template file:</p>
<pre>{% extends 'base.html' %}<br/>{% block content %}<br/>&lt;div class="container"&gt;<br/>    &lt;div class="row"&gt;<br/>        &lt;div class="form_bg"&gt;<br/>            &lt;form method="post" id="form"&gt;<br/>                {% csrf_token %}<br/>                &lt;h2 class="text-center"&gt;Add Bill&lt;/h2&gt;<br/>                &lt;br /&gt;<br/>                &lt;div class="form-group"&gt;<br/>                    &lt;input type="text" class="form-control" id="billname" name="billname" placeholder="Bill Name"&gt;<br/>                &lt;/div&gt;<br/>                &lt;div class="form-group"&gt;<br/>                    &lt;input type="text" class="form-control" id="billdesc" name="billdesc" placeholder="Description"&gt;<br/>                &lt;/div&gt;<br/>                &lt;br /&gt;<br/>                &lt;div class="align-center"&gt;<br/>                    &lt;button type="submit" class="btn btn-success" id="save"&gt;Submit&lt;/button&gt;<br/>                &lt;/div&gt;<br/>            &lt;/form&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>&lt;/div&gt;<br/>{% endblock %}</pre>
<p>In the preceding block of code, we have extended the <kbd>base.html</kbd> template to add a form that allows us to add bills. Notice the use of the CSRF token in the <kbd>form</kbd> element. In Django, we always need to pass valid CSRF tokens while making POST requests.</p>
<div class="packt_infobox">You can read more about CSRF tokens in Django at <a href="https://docs.djangoproject.com/en/3.0/ref/csrf/">https://docs.djangoproject.com/en/3.0/ref/csrf/</a>.</div>
<p>But wait, we've not yet added the views to handle the billboard page and the addition of the bills page. Let's add them now!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The billboard model </h1>
                </header>
            
            <article>
                
<p>We need to add the views to see all the bills on the billboard page. However, for this, we first need to create the model to hold all the bills. </p>
<p>In the <kbd>models.py</kbd> file, add the following code:</p>
<pre>from django.utils.timezone import now<br/>from django.contrib.auth.models import User<br/><br/>class Bills(models.Model):<br/>    billName = models.CharField("Bill Name", blank=False, max_length=100, default="New Bill")<br/>    user = models.ForeignKey(User, on_delete=models.CASCADE)<br/>    billDesc = models.TextField("Bill Description")<br/>    billTime = models.DateTimeField(default=now, editable=False)<br/><br/>    class Meta:<br/>        db_table = "bills"</pre>
<p>In the preceding code, we created a new model called <kbd>Bills</kbd>. This will store the details for all of the bills added by users on the billboard. The <kbd>user</kbd> model is linked with this model as a foreign key. Save this file as <kbd>webapp/billboard/models.py</kbd>.</p>
<div class="packt_infobox">You can read more about foreign keys and other keys at <a href="https://www.sqlite.org/foreignkeys.html">https://www.sqlite.org/foreignkeys.html</a>.   </div>
<p>With this done, we can now use the <kbd>Bills</kbd> model in the views. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the billboard view </h1>
                </header>
            
            <article>
                
<p>To start using the <kbd>Bills</kbd> model in the app, we first need to import it to the <kbd>views.py</kbd> file. </p>
<p>Add the following line at the top of the <kbd>view.py</kbd> file:</p>
<pre>from .models import Bills</pre>
<p>Then, we can add the view for the billboard, as shown:</p>
<pre>def board(request):<br/>    template = loader.get_template('board.html')<br/>    context = {}<br/>    context["isLogged"] = 1<br/><br/>    Bill = Bills.objects.all()<br/><br/>    context["bills"] = Bill<br/><br/>    return HttpResponse(template.render(context, request))</pre>
<p>Next, we need to create the view for adding the bills.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating bills and adding views</h1>
                </header>
            
            <article>
                
<p>In this view, we will create the bills. If a valid <kbd>POST</kbd> request is made to the route served by the <kbd>addbill</kbd> method, we create a new <kbd>Bill</kbd> object and save it to the database. Otherwise, we display the form for adding bills to the user. Let's see how we can do this in the following code:</p>
<pre>def addbill(request):<br/>    if request.POST:<br/>            billName = request.POST['billname']<br/>            billDesc = request.POST['billdesc']<br/>            Bill = Bills.objects.create(billName=billName, user=request.user, billDesc=billDesc)<br/>            Bill.save()<br/>            return redirect('/')<br/>    else:<br/>        template = loader.get_template('add.html')<br/>        context = {}<br/>        context["isLogged"] = 1<br/><br/>        return HttpResponse(template.render(context, request))</pre>
<p>However, we still need to create the admin user before using the app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the admin user and testing it</h1>
                </header>
            
            <article>
                
<p>To create the admin user, we use the following command:</p>
<pre><strong> python manage.py createsuperuser</strong></pre>
<p>We can now migrate the database change by using the following commands:</p>
<pre><strong>python manage.py makemigrations</strong><br/><strong>python manage.py migrate</strong></pre>
<p>An output similar to the following is produced:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1276 image-border" src="assets/e0506807-c8f7-4fa1-b8c1-2b79d7600dd8.png" style="width:49.75em;height:17.25em;"/></p>
<p>Now, let's secure the billboard postings using the <span>reCAPTCHA</span> tool.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using reCAPTCHA in web applications with Python</h1>
                </header>
            
            <article>
                
<p>To add the <span>reCAPTCHA</span> to the website, we first need to obtain the API keys from the Google <span>reCAPTCHA</span> console:</p>
<ol>
<li>First, log in to your Google account and go to <a href="https://www.google.com/recaptcha">https://www.google.com/recaptcha</a>.</li>
<li>Next, click on <span class="packt_screen">Admin Console</span> at the top-right. </li>
<li>Add your site to the console by following the steps shown on your screen. If you're testing on your local system, you'll have to specify <kbd>127.0.0.1</kbd> as one of the URLs.</li>
<li>Obtain the API keys for your domain.<br/>
<br/>
The screen that you get your domain's API keys on should look similar to the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1277 image-border" src="assets/fee62e08-e223-469d-a77e-82bac332aa67.png" style="width:33.17em;height:13.08em;"/></p>
<ol start="5">
<li class="mce-root">Now<span>, add the secret key to the</span> <kbd>settings.py</kbd> <span>file of the web app, </span><span>as shown: </span></li>
</ol>
<pre style="color: black;padding-left: 60px">GOOGLE_RECAPTCHA_SECRET_KEY = '6Lfi6ncUAAAAANJYkMC66skocDgA1REblmx0-3B2'</pre>
<ol start="6">
<li class="mce-root">Next<span>, we need to add the scripts to be loaded to the</span> <kbd>add.html</kbd> <span>template. We'll add it to the billboard app page template, as shown: </span></li>
</ol>
<pre style="color: black;padding-left: 60px">&lt;script src="https://www.google.com/recaptcha/api.js?render=6Lfi6ncUAAAAAIaJgQCDaR3s-FGGczzo7Mefp0TQ"&gt;&lt;/script&gt;<br/>&lt;script&gt;<br/>    grecaptcha.ready(function() {<br/>        grecaptcha.execute('6Lfi6ncUAAAAAIaJgQCDaR3s-FGGczzo7Mefp0TQ')<br/>        .then(function(token) {<br/>            $("#form").append('&lt;input type="hidden" name="g-recaptcha-response" value="'+token+'" &gt;');<br/>        });<br/>    });<br/>&lt;/script&gt;<br/><br/>{% endblock %}</pre>
<p style="padding-left: 60px" class="mce-root"><span>Note that the key used in this step is the client/site key.</span></p>
<ol start="7">
<li class="mce-root">Finally<span>, we need to validate the reCAPTCHA in the add billboard view, as shown:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">def addbill(request):<br/>    if request.POST:<br/>        recaptcha_response = request.POST.get('g-recaptcha-response')<br/>        url = 'https://www.google.com/recaptcha/api/siteverify'<br/>        values = {  'secret': settings.GOOGLE_RECAPTCHA_SECRET_KEY,<br/>                    'response': recaptcha_response}<br/>        context = ssl._create_unverified_context()<br/>        data = urllib.parse.urlencode(values).encode()<br/>        req = urllib.request.Request(url, data=data)<br/>        response = urllib.request.urlopen(req, context=context)<br/>        result = json.loads(response.read().decode())<br/>        if result['success']:<br/>            # Do stuff if valid<br/>    else:<br/>        # Do actions when no request is made</pre>
<p>You can grab the full working version of the <kbd>addbill</kbd> method in the previous code block from <a href="https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/webapp/billboard/views.py">https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/webapp/billboard/views.py</a>.<a href="https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/webapp/billboard/views.py"/></p>
<p>With the previous changes made, we're finally ready to test run the website with all its security measures in place. Run the following command to start the website server: </p>
<pre><strong>python manage.py runserver</strong></pre>
<p>You should be able to see the website's login page, as shown:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1278 image-border" src="assets/6be54474-9af3-4242-a2ac-c55719a38b51.png" style="width:30.33em;height:18.50em;"/></p>
<div class="packt_infobox">Note that at this point, you'll need to have the Flask server, which performs the login validation, running at the same time.</div>
<p>Upon login, you'll see the billboard page with bills <span>posted</span><span> </span><span>on it. Head over to the</span> <span class="packt_screen">Add Bill</span> <span>button to add a new bill, as shown:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1279 image-border" src="assets/d28fc58c-b859-4882-869e-c5c3d783772d.png" style="width:35.25em;height:21.58em;"/></p>
<p>Notice the <span>reCAPTCHA</span> logo at the bottom-right corner of the screen. This indicates that the page is protected against spamming by using <span>reCAPTCHA</span>. If you are able to post successfully, the billboard is displayed again with the submitted bill. If not, you'll be presented with a <span>reCAPTCHA</span> verify challenge.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Website security with Cloudflare</h1>
                </header>
            
            <article>
                
<p>Cloudflare is the industry's leading web infrastructure and website security provider. It creates a layer of security and fast content delivery between a website and its users, hence routing all the traffic through its servers, which enables security and other features on websites. In 2017, Cloudflare provided DNS services to over 12 million websites. These services include content delivery networks, <strong>Distributed Denial of Service</strong> (<span><strong>DDoS</strong>)</span> attack protection, hacking attempt protection, and other internet security services, such as leeching protection. </p>
<p>In 2014, Cloudflare reported mitigating a 400 Gib/s DDoS attack on a customer, which was soon followed by a 500 Gib/s attack the next year. The largest attack on any website recorded has been on GitHub, where it faced a DDoS of 1.4Tb/s flooding. GitHub was using Akamai Prolexic (an alternative to Cloudflare) and was able to withstand the attack, going down only for 10 minutes before coming back up entirely. Cloudflare offers DDoS protection to all its users free of charge. </p>
<p>To get started with deploying the services of Cloudflare on your website, you need to set up Cloudflare as an intermediate layer between your users and the hosting server. The following diagram depicts how Cloudflare sits on the network:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1281 image-border" src="assets/ada2acb7-d8a7-4b38-8329-e7e64ba13a85.png" style="width:44.17em;height:13.50em;"/></p>
<p>So, the detection of spam and malicious users that we created the previous custom solutions for, with the help of Google's <span>reCAPTCHA,</span> is automatically taken care of by Cloudflare to a basic extent (in the free tier, with more powerful solutions in the higher tiers as you upgrade). It is, therefore, very intuitive and simple for a small team of developers to push off their security needs to Cloudflare's systems and to rest assured that they are protected against a number of security breaches.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary </h1>
                </header>
            
            <article>
                
<p>In this chapter, we saw how we can provide security to websites using Cloudflare's services. We also saw how to create security APIs that can be used in integration with web applications and other security services such as <span>reCAPTCHA</span>. It is crucial for any website—small or large—to have these security measures in place in order for their website services to function properly. There have been major breaches in recent times, and countless others that have been attempted by AI-powered systems that do not make it onto the news because they were not an issue. Security using deep learning is a burning topic of research and it is believed that in the near future, security systems will all rely strongly on deep learning to recognize and eliminate threats. </p>
<p>In the next chapter, we will discuss how to set up a production-grade deep learning environment. We will discuss the architecture designs you could follow, depending on their size requirements, and the state-of-the-art service providers and tools.</p>


            </article>

            
        </section>
    </body></html>