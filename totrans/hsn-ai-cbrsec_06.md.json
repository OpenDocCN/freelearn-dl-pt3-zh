["```\ntypedef struct _IMAGE_DOS_HEADER {      \n// DOS .EXE header\n    WORD   e_magic;                     \n// Magic number\n    WORD   e_cblp;                      \n// Bytes on last page of file\n    WORD   e_cp;                        \n// Pages in file\n    WORD   e_crlc;                      \n// Relocations\n    WORD   e_cparhdr;                   \n// Size of header in paragraphs\n    WORD   e_minalloc;                  \n// Minimum extra paragraphs needed\n    WORD   e_maxalloc;                  \n// Maximum extra paragraphs needed\n    WORD   e_ss;                        \n// Initial (relative) SS value\n    WORD   e_sp;                        \n// Initial SP value\n    WORD   e_csum;                      \n// Checksum\n    WORD   e_ip;                        \n// Initial IP value\n    WORD   e_cs;                        \n// Initial (relative) CS value\n    WORD   e_lfarlc;                    \n// File address of relocation table\n    WORD   e_ovno;                      \n// Overlay number\n    WORD   e_res[4];                    \n// Reserved words\n    WORD   e_oemid;                     \n// OEM identifier (for e_oeminfo)\n    WORD   e_oeminfo;                   \n// OEM information; e_oemid specific\n    WORD   e_res2[10];                  \n// Reserved words\n    LONG   e_lfanew;                    \n// File address of new exe header\n  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;\n```", "```\ntypedef struct _IMAGE_NT_HEADERS {\n    DWORD Signature;\n    IMAGE_FILE_HEADER FileHeader;\n    IMAGE_OPTIONAL_HEADER32 OptionalHeader;\n} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;\n```", "```\ntypedef struct _IMAGE_FILE_HEADER {\n    WORD    Machine;\n    WORD    NumberOfSections;\n    DWORD   TimeDateStamp;\n    DWORD   PointerToSymbolTable;\n    DWORD   NumberOfSymbols;\n    WORD    SizeOfOptionalHeader;\n    WORD    Characteristics;\n} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n```", "```\ntypedef struct _IMAGE_OPTIONAL_HEADER {\n    //\n    // Standard fields.\n    //\n\n    WORD    Magic;\n    BYTE    MajorLinkerVersion;\n    BYTE    MinorLinkerVersion;\n    DWORD   SizeOfCode;\n    DWORD   SizeOfInitializedData;\n    DWORD   SizeOfUninitializedData;\n    DWORD   AddressOfEntryPoint;\n    DWORD   BaseOfCode;\n    DWORD   BaseOfData;\n\n    //\n    // NT additional fields.\n    //\n\n    DWORD   ImageBase;\n    DWORD   SectionAlignment;\n    DWORD   FileAlignment;\n    WORD    MajorOperatingSystemVersion;\n    WORD    MinorOperatingSystemVersion;\n    WORD    MajorImageVersion;\n    WORD    MinorImageVersion;\n    WORD    MajorSubsystemVersion;\n    WORD    MinorSubsystemVersion;\n    DWORD   Win32VersionValue;\n    DWORD   SizeOfImage;\n    DWORD   SizeOfHeaders;\n    DWORD   CheckSum;\n    WORD    Subsystem;\n    WORD    DllCharacteristics;\n    DWORD   SizeOfStackReserve;\n    DWORD   SizeOfStackCommit;\n    DWORD   SizeOfHeapReserve;\n    DWORD   SizeOfHeapCommit;\n    DWORD   LoaderFlags;\n    DWORD   NumberOfRvaAndSizes;\n    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];\n} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;\n```", "```\npython setup.py install\n```", "```\nconda install -n py35 -c conda-forge pefile\n```", "```\nimport os\nimport pefile\n\nsuspect_pe = pefile.PE(\"suspect.exe\")\n```", "```\nAddressOfEntryPoint = suspect_pe.OPTIONAL_HEADER.AddressOfEntryPoint\nMajorImageVersion = suspect_pe.OPTIONAL_HEADER.MajorImageVersion\nNumberOfSections = suspect_pe.FILE_HEADER.NumberOfSections\nSizeOfStackReserve = suspect_pe.OPTIONAL_HEADER.SizeOfStackReserve\n```", "```\nimport os\nimport pefile\nimport glob\n\ncsv = file('MalwareArtifacts.csv','w')\n\nfiles = glob.glob('c:\\\\MalwareSamples\\\\*.exe')\n\ncsv.write(\"AddressOfEntryPoint,MajorLinkerVersion,MajorImageVersion,\nMajorOperatingSystemVersion,,DllCharacteristics,SizeOfStackReserve,\nNumberOfSections,ResourceSize,\\n\")\n\nfor file in files:\n    suspect_pe = pefile.PE(file)\n    csv.write( str(suspect_pe.OPTIONAL_HEADER.AddressOfEntryPoint) + ',')\n    csv.write( str(suspect_pe.OPTIONAL_HEADER.MajorLinkerVersion) + ',')\n    csv.write( str(suspect_pe.OPTIONAL_HEADER.MajorImageVersion) + ',')\n    csv.write( str(suspect_pe.OPTIONAL_HEADER.MajorOperatingSystemVersion) + ',')\n    csv.write( str(suspect_pe.OPTIONAL_HEADER.DllCharacteristics) + ',')\n    csv.write( str(suspect_pe.OPTIONAL_HEADER.SizeOfStackReserve) + ',')\n    csv.write( str(suspect_pe.FILE_HEADER.NumberOfSections) + ',')\n    csv.write( str(suspect_pe.OPTIONAL_HEADER.DATA_DIRECTORY[2].Size) + \"\\n\")\n\ncsv.close()\n\n```", "```\nimport numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt \n\nfrom sklearn.cluster import KMeans \nfrom sklearn.metrics import silhouette_score \n\nmalware_dataset = pd.read_csv('../datasets/MalwareArtifacts.csv', delimiter=',')\n\n# Extracting artifacts samples fields \n# MajorLinkerVersion,MajorImageVersion,\n# MajorOperatingSystemVersion,DllCharacteristics\n\nsamples = malware_dataset.iloc[:, [1,2,3,4]].values\ntargets = malware_dataset.iloc[:, 8].values\n```", "```\nk_means = KMeans(n_clusters=2,max_iter=300)\n```", "```\nk_means.fit(samples)\n```", "```\nk_means = KMeans(n_clusters=2,max_iter=300)\nk_means.fit(samples) \n\nprint(\"K-means labels: \" + str(k_means.labels_))\n\nprint (\"\\nK-means Clustering Results:\\n\\n\", pd.crosstab(targets,\nk_means.labels_,rownames = [\"Observed\"],colnames = [\"Predicted\"]) )      \n\nprint (\"\\nSilhouette coefficient: %0.3f\" % silhouette_score(samples, k_means.labels_, metric='euclidean')) \n```", "```\nK-means labels: [0 0 0 ... 0 1 0]\nK-means Clustering Results:\n\nPredicted      0      1\nObserved               \n0           83419  13107\n1            7995  32923\n\nSilhouette coefficient: 0.975\n```", "```\nimport pandas as pd\nimport numpy as np\nfrom sklearn import *\n\nfrom sklearn.metrics import accuracy_score\n\nmalware_dataset = pd.read_csv('../datasets/MalwareArtifacts.csv', delimiter=',')\n\n# Extracting artifacts samples fields \"AddressOfEntryPoint\" and\n# \"DllCharacteristics\"\nsamples = malware_dataset.iloc[:, [0, 4]].values\ntargets = malware_dataset.iloc[:, 8].values\n\nfrom sklearn.model_selection import train_test_split\n\ntraining_samples, testing_samples, training_targets, \ntesting_targets = train_test_split(samples, targets, \n                    test_size=0.2, random_state=0)\n\nfrom sklearn import tree\ntree_classifier = tree.DecisionTreeClassifier()\n\ntree_classifier.fit(training_samples, training_targets)\n\npredictions = tree_classifier.predict(testing_samples)\n\naccuracy = 100.0 * accuracy_score(testing_targets, predictions)\n\nprint (\"Decision Tree accuracy: \" + str(accuracy))\nDecision Tree accuracy: 96.25860195581312\n```", "```\nimport pandas as pd\nimport numpy as np\nfrom sklearn import *\n\nmalware_dataset = pd.read_csv('../datasets/MalwareArtifacts.csv', delimiter=',')\n\n# Extracting artifacts samples fields \"AddressOfEntryPoint\" and\n# \"DllCharacteristics\"\n\nsamples = malware_dataset.iloc[:, [0,4]].values\ntargets = malware_dataset.iloc[:, 8].values\n\nfrom sklearn.model_selection import train_test_split\n\ntraining_samples, testing_samples, \ntraining_targets, testing_targets = train_test_split(samples, targets,\ntest_size=0.2)\n\nrfc =  ensemble.RandomForestClassifier(n_estimators=50)\nrfc.fit(training_samples, training_targets)\naccuracy = rfc.score(testing_samples, testing_targets)\n\nprint(\"Random Forest Classifier accuracy: \" + str(accuracy*100) )\n```", "```\nDecision Tree accuracy: 96.25860195581312\nRandom Forest accuracy: 96.46142701919594\n```", "```\n                 Working   Not Working\n\nMalicious          0.2         0.8\n\nLegitimate         0.4         0.6\n```", "```\n             Malicious  Legitimate\n\nMalicious        0.7       0.3\n\nLegitimate       0.1       0.9\n```", "```\nMalicious        0.1 \n\nLegitimate       0.9\n```", "```\nob_types = (‘W’,‘N’ )\n```", "```\nstates = (‘L’, ’M')\n```", "```\nobservations = (‘W’,‘W’,‘W’,‘N’)\n```", "```\nstart = np.matrix(‘0.1 0.9’)\n```", "```\ntransition = np.matrix(‘0.7 0.3 ; 0.1 0.9’)\n```", "```\nemission = np.matrix(‘0.2 0.8 ; 0.4 0.6’)\n```", "```\nimport numpy as np\nfrom hidden_markov import hmm\n\nob_types = ('W','N' )\n\nstates = ('L', 'M')\n\nobservations = ('W','W','W','N')\n\nstart = np.matrix('0.1 0.9')\ntransition = np.matrix('0.7 0.3 ; 0.1 0.9')\nemission = np.matrix('0.2 0.8 ; 0.4 0.6')\n\n_hmm = hmm(states,ob_types,start,transition,emission)\n\nprint(\"Forward algorithm: \")\nprint ( _hmm.forward_algo(observations) )\n\nprint(\"\\nViterbi algorithm: \")\nprint( _hmm.viterbi(observations) )\n```", "```\nForward algorithm: 0.033196\nViterbi algorithm: [’M', ’M', ’M', ’M']\n```", "```\ngit clone https://github.com/AFAgarap/malware-classification.git/\n```", "```\nUsage: main.py [-h] -m MODEL -d DATASET -n NUM_EPOCHS -c PENALTY_PARAMETER -k CHECKPOINT_PATH -l LOG_PATH -r RESULT_PATH\n```", "```\nmain.py –model 1 –dataset ./dataset/malimg.npz –num_epochs 100 –penalty_parameter 10 -c ./checkpoint/ -l ./logs/ -r ./results/\n```"]