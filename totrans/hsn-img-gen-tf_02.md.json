["```\nimport tensorflow_datasets as tfds\nimport matplotlib.pyplot as plt\nimport numpy as np\nds_train, ds_info = tfds.load('celeb_a', split='test', \n                               shuffle_files=False, \n                               with_info=True)\nfig = tfds.show_examples(ds_info, ds_train)\n```", "```\nsample_size = 2000\nds_train = ds_train.batch(sample_size)\nfeatures = next(iter(ds_train.take(1)))\nsample_images = features['image']\nnew_image = np.mean(sample_images, axis=0)\nplt.imshow(new_image.astype(np.uint8))\n```", "```\nnew_image = np.zeros(sample_images.shape[1:], dtype=np.uint8)\nfor i in range(h):\n    for j in range(w):\n        rand_int = np.random.randint(0, sample_images.shape[0])\n        new_image[i,j] = sample_images[rand_int,i,j]\n```", "```\ndef binarize(image, label):\n    image = tf.cast(image, tf.float32)\n    image = tf.math.round(image/255.)\n    return image, tf.cast(image, tf.int32)\n```", "```\nclass MaskedConv2D(tf.keras.layers.Layer):\n    def __init__(self):\n        ...       \n    def build(self, input_shape):\n        ...\n    def call(self, inputs):\n        ...\n        return output\n```", "```\n    def build(self, input_shape):\n        self.w = self.add_weight(shape=[self.kernel,\n                                        self.kernel,\n                                        input_shape[-1],\n                                        self.filters],\n                                initializer='glorot_normal',\n                                trainable=True)\n        self.b = self.add_weight(shape=(self.filters,),\n                                initializer='zeros',\n                                trainable=True)\n        mask = np.ones(self.kernel**2, dtype=np.float32)\n        center = len(mask)//2\n        mask[center+1:] = 0\n        if self.mask_type == 'A':\n            mask[center] = 0\n        mask = mask.reshape((self.kernel, self.kernel, 1, 1))\n        self.mask = tf.constant(mask, dtype='float32')\n```", "```\n    def call(self, inputs):\n        masked_w = tf.math.multiply(self.w, self.mask)\n        output = tf.nn.conv2d(inputs, masked_w, 1, \"SAME\") +  \t                   self.b\n        return output\n```", "```\npixelcnn = SimplePixelCnn()\npixelcnn.compile(\n    loss = tf.keras.losses.BinaryCrossentropy(),\n    optimizer=tf.keras.optimizers.RMSprop(learning_rate=0.001),\n    metrics=[ tf.keras.metrics.BinaryCrossentropy()])\npixelcnn.fit(ds_train, epochs = 10, validation_data=ds_test)\n```"]