<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Setting Up Your AI for Cybersecurity Arsenal</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This chapter introduces the main software requirements and their configurations. </span><span class="koboSpan" id="kobo.2.2">You will learn how to feed a knowledge base with samples of malicious code that will be passed as input to AI procedures. </span><span class="koboSpan" id="kobo.2.3">IPython notebooks will be introduced for the interactive execution of Python tools and commands.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The chapter will cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.4.1">Getting to know Python for AI and cybersecurity</span></li>
<li><span class="koboSpan" id="kobo.5.1">Enter Anaconda—the data scientist's environment of choice</span></li>
<li><span class="koboSpan" id="kobo.6.1">Playing with Jupyter Notebook</span></li>
<li><span class="koboSpan" id="kobo.7.1">Feeding your AI arsenal—where to find data and malicious samples</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting to know Python for AI and cybersecurity</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Among all the languages ​​that can be used to program AI tools and algorithms, Python is the one that, in recent years, has shown to be constantly growing and is appreciated by programmers, new and old. Despite the competition being fierce, as languages ​​such as R, as well as Java, can boast tens of thousands of developers in their ranks, Python has gained the reputation of being a language of choice not only for </span><strong><span class="koboSpan" id="kobo.3.1">data science</span></strong><span class="koboSpan" id="kobo.4.1"> but also (and above all) for </span><strong><span class="koboSpan" id="kobo.5.1">machine learning</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong><span class="koboSpan" id="kobo.7.1">ML</span></strong><span class="koboSpan" id="kobo.8.1">), </span><strong><span class="koboSpan" id="kobo.9.1">deep learning</span></strong><span class="koboSpan" id="kobo.10.1"> (</span><strong><span class="koboSpan" id="kobo.11.1">DL)</span></strong><span class="koboSpan" id="kobo.12.1">,</span><strong><span class="koboSpan" id="kobo.13.1"> </span></strong><span class="koboSpan" id="kobo.14.1">and more generally, for the development of </span><strong><span class="koboSpan" id="kobo.15.1">artificial intelligence</span></strong><span class="koboSpan" id="kobo.16.1"> (</span><strong><span class="koboSpan" id="kobo.17.1">AI</span></strong><span class="koboSpan" id="kobo.18.1">) algorithms.</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.19.1">The success of Python in these areas should not be surprising. </span><span class="koboSpan" id="kobo.19.2">Python was originally developed for programming numerical calculations, but was then extended to non-specialist areas, assuming the form of a general-purpose programming language, alongside better-known languages ​​such as C++ and Java.</span></p>
<p><span class="koboSpan" id="kobo.20.1">Python's success is due to a number of reasons, as follows:</span></p>
<ul>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.21.1">Easy to learn</span></strong><span><span class="koboSpan" id="kobo.22.1">: The language learning curve is indeed much less steep than other languages, ​​such as C++ and Java.</span></span></li>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.23.1">Speeding up both the code prototyping and code refactoring processes</span></strong><span><span class="koboSpan" id="kobo.24.1">: Thanks to a clean design and clear syntax, programming in Python is much easier than other languages. </span><span class="koboSpan" id="kobo.24.2">It is also much easier to debug code. </span><span class="koboSpan" id="kobo.24.3">It is not uncommon for prototypes of programs developed in Python to be released for operation without the need for further modifications. </span><span class="koboSpan" id="kobo.24.4">These characteristics are essential in areas such as data science and AI. </span><span class="koboSpan" id="kobo.24.5">Sectors characterized by the need to quickly prototype new features and refactor old ones, without having to waste time debugging legacy code, are in need of a means to speed up code prototyping and refactoring.</span></span></li>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.25.1">Interpreted language and object orientation</span></strong><span><span class="koboSpan" id="kobo.26.1">: The ability to write code in the form of a script that can be started directly on the command line, or better still, in interactive mode (as we will see later), without the need to proceed with the compilation in executable format, dramatically accelerates the process of development, and the testing of applications. Object orientation also facilitates the development of APIs and libraries of reusable functionalities, ensuring the reliability and robustness of the code.</span></span></li>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.27.1">The wide availability of open source libraries that expand programming features</span></strong><span><span class="koboSpan" id="kobo.28.1">: The benefits we have talked about so far translate into the availability of numerous libraries of high-level functions, freely usable by analysts and developers, and made available by the large Python community. </span><span class="koboSpan" id="kobo.28.2">These function libraries can be easily integrated with each other by virtue of the clean language design, which facilitates the development of APIs that can be recalled by the developers.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.29.1">Now, let's delve deeper into the most common AI programming libraries available in Python.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Python libraries for AI</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As anticipated, there are numerous libraries available in Python that can be used in the field of data science and ML, including DL and </span><strong><span class="koboSpan" id="kobo.3.1">reinforcement learning</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">RL</span></strong><span class="koboSpan" id="kobo.6.1">).</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.7.1">In the same way, there are many functions of graphical representation and reporting. </span><span class="koboSpan" id="kobo.7.2">In the following sections, we will analyze the characteristics of these libraries.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">NumPy as an AI building block</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Of all the Python libraries dedicated to data science and AI, there is no doubt that NumPy holds a privileged place. </span><span class="koboSpan" id="kobo.2.2">Using the functionalities and APIs implemented by NumPy, it is possible to build algorithms and tools for ML from scratch.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Of course, having specialized libraries available for AI (such as the </span><kbd><span class="koboSpan" id="kobo.4.1">scikit-learn</span></kbd><span class="koboSpan" id="kobo.5.1"> library) accelerates the process of the development of AI and ML tools, but to fully appreciate the advantages deriving from the use of such higher-level libraries, it is useful to understand the building blocks on which they are built. </span><span class="koboSpan" id="kobo.5.2">This is why knowledge of the basic concepts of NumPy is helpful in this regard.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">NumPy multidimensional arrays</span></h1>
                </header>
            
            <article>
                
<p><strong><span class="koboSpan" id="kobo.2.1">NumPy</span></strong><span class="koboSpan" id="kobo.3.1"> was created to solve important scientific problems, which include </span><strong><span class="koboSpan" id="kobo.4.1">linear algebra</span></strong><span class="koboSpan" id="kobo.5.1"> and </span><strong><span class="koboSpan" id="kobo.6.1">matrix calculations</span></strong><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">It offers a particularly </span><strong><span class="koboSpan" id="kobo.8.1">optimized version, </span></strong><span class="koboSpan" id="kobo.9.1">compared to the corresponding native versions of data structures offered by the Python language, such as lists of arrays and making </span><strong><span class="koboSpan" id="kobo.10.1">multidimensional</span></strong><span class="koboSpan" id="kobo.11.1"> array objects, known as </span><kbd><span class="koboSpan" id="kobo.12.1">ndarrays</span></kbd><span class="koboSpan" id="kobo.13.1">, available. In fact, an object of the </span><kbd><span class="koboSpan" id="kobo.14.1">ndarray</span></kbd><span class="koboSpan" id="kobo.15.1"> type allows the acceleration of operations to reach speeds of up to 25 times faster compared to traditional </span><kbd><span class="koboSpan" id="kobo.16.1">for</span></kbd><span class="koboSpan" id="kobo.17.1"> loops, which is necessary to manage access to data stored in a traditional Python list.</span></p>
<p><span class="koboSpan" id="kobo.18.1">Moreover, NumPy allows the management of operations on matrices, which is particularly useful for the implementation of ML algorithms. </span><span class="koboSpan" id="kobo.18.2">Unlike </span><kbd><span class="koboSpan" id="kobo.19.1">ndarray</span></kbd><span class="koboSpan" id="kobo.20.1"> objects, matrices are objects that can take only two dimensions and represent the main data structures used in linear algebra.</span></p>
<p><span class="koboSpan" id="kobo.21.1">Here are some examples of defining NumPy objects:</span></p>
<pre><span class="koboSpan" id="kobo.22.1">import numpy as np
np_array = np.array( [0, 1, 2, 3] )

# Creating an array with ten elements initialized as zero
np_zero_array = np.zeros(10)</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Matrix operations with NumPy</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As anticipated, matrices and the operations executed on them are of particular importance in the field of ML, and, more generally, they are used to conveniently represent the data to be fed to AI ​​algorithms.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Matrices are particularly useful in the management and representation of large amounts of data.</span></p>
<p><span class="koboSpan" id="kobo.4.1">The notation itself is commonly used to identify the elements of a matrix, making use of positional indexes that allow the execution of consistent, rapid fashion operations, and calculations that concern either the whole matrix or just specific subsets. </span><span class="koboSpan" id="kobo.4.2">F</span><span><span class="koboSpan" id="kobo.5.1">or</span></span> <span><span class="koboSpan" id="kobo.6.1">example, the </span><span class="koboSpan" id="kobo.7.1"><img class="fm-editor-equation" src="assets/0c6fe151-0486-488f-9b59-912d58501543.png" style="width:2.00em;height:1.58em;"/></span></span><span><span class="koboSpan" id="kobo.8.1"> element is easily identified within the matrix, crossing </span></span><span><span class="koboSpan" id="kobo.9.1">row </span><span class="koboSpan" id="kobo.10.1"><img class="fm-editor-equation" src="assets/afbc1ec2-ac8d-4274-ba4a-0bb61100ef01.png" style="width:0.50em;height:1.33em;"/></span></span><span><span class="koboSpan" id="kobo.11.1"> and column </span><span class="koboSpan" id="kobo.12.1"><img class="fm-editor-equation" src="assets/8a391b3a-1f5d-4dfa-8678-f800dea8c887.png" style="width:0.67em;height:1.58em;"/></span></span><span><span class="koboSpan" id="kobo.13.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">A special matrix, consisting of only one row (and several columns) is identified as a </span><strong><span class="koboSpan" id="kobo.15.1">vector</span></strong><em><span class="koboSpan" id="kobo.16.1">. </span></em><span class="koboSpan" id="kobo.17.1">Vectors can be represented in Python as objects of a </span><kbd><span class="koboSpan" id="kobo.18.1">list </span></kbd><span class="koboSpan" id="kobo.19.1">type.</span></p>
<p><span class="koboSpan" id="kobo.20.1">However, the particular rules established by </span><strong><span class="koboSpan" id="kobo.21.1">linear algebra</span></strong><span class="koboSpan" id="kobo.22.1"> should be taken into account when performing operations between </span><strong><span class="koboSpan" id="kobo.23.1">matrices and vectors</span></strong><span class="koboSpan" id="kobo.24.1">.</span></p>
<p><span class="koboSpan" id="kobo.25.1">The basic operations that can be performed on matrices are as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.26.1">Addition</span></li>
<li><span class="koboSpan" id="kobo.27.1">Subtraction</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.28.1">Scalar multiplication (resulting in a constant value multiplied for each matrix element)</span></li>
</ul>
<p><span class="koboSpan" id="kobo.29.1">If such operations on matrices are relatively simple to accomplish, and are required only as a </span><strong><span class="koboSpan" id="kobo.30.1">necessary precondition</span></strong><span class="koboSpan" id="kobo.31.1"> that the matrices that add or subtract from each other are of the </span><strong><span class="koboSpan" id="kobo.32.1">same size, then </span></strong><span class="koboSpan" id="kobo.33.1">the result of the addition or subtraction of two matrices is a </span><strong><span class="koboSpan" id="kobo.34.1">new matrix</span></strong><span class="koboSpan" id="kobo.35.1"> whose elements are the result of the sum of corresponding elements in row and column order.</span></p>
<p><span class="koboSpan" id="kobo.36.1">When dealing with the </span><strong><span class="koboSpan" id="kobo.37.1">product</span></strong><span class="koboSpan" id="kobo.38.1"> operation between matrices or between vectors and matrices, the rules of linear algebra are partly different, since, for example, the </span><strong><span class="koboSpan" id="kobo.39.1">commutative property</span></strong><span class="koboSpan" id="kobo.40.1"> is not applicable as it is in the case of the product of two scalars.</span></p>
<p><span class="koboSpan" id="kobo.41.1">In fact, while in the case of the product of two numbers among them, the order of factors does not change the result of multiplication (that is, </span><em><span class="koboSpan" id="kobo.42.1">2 x 3 = 3 x 2</span></em><span class="koboSpan" id="kobo.43.1">), in the case of the product of two matrices, </span><strong><span class="koboSpan" id="kobo.44.1">the order is important</span></strong><span class="koboSpan" id="kobo.45.1">:</span></p>
<pre><span class="koboSpan" id="kobo.46.1">aX != Xa</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.47.1">Here, </span><kbd><span class="koboSpan" id="kobo.48.1">X</span></kbd><em><span class="koboSpan" id="kobo.49.1"> </span></em><span class="koboSpan" id="kobo.50.1">represents a </span><strong><span class="koboSpan" id="kobo.51.1">matrix</span></strong><span class="koboSpan" id="kobo.52.1"> and </span><kbd><span class="koboSpan" id="kobo.53.1">a</span></kbd><span class="koboSpan" id="kobo.54.1"> represents a </span><strong><span class="koboSpan" id="kobo.55.1">vector</span></strong><span class="koboSpan" id="kobo.56.1"> of coefficients. </span><span class="koboSpan" id="kobo.56.2">Moreover, it is </span><strong><span class="koboSpan" id="kobo.57.1">not always</span></strong><span class="koboSpan" id="kobo.58.1"> possible to </span><strong><span class="koboSpan" id="kobo.59.1">multiply two matrices</span></strong><span class="koboSpan" id="kobo.60.1">, as in the case of two matrices with </span><strong><span class="koboSpan" id="kobo.61.1">incompatible dimensions</span></strong><span class="koboSpan" id="kobo.62.1">.</span></p>
<p><span class="koboSpan" id="kobo.63.1">For this reason, the </span><kbd><span class="koboSpan" id="kobo.64.1">numpy</span></kbd><span class="koboSpan" id="kobo.65.1"> library provides the </span><kbd><span class="koboSpan" id="kobo.66.1">dot()</span></kbd><span class="koboSpan" id="kobo.67.1"> function to calculate the product of two matrices between them (usable whenever this operation is possible):</span></p>
<pre><span class="koboSpan" id="kobo.68.1">import numpy as np
a = np.array([-8, 15])
X = np.array([[1, 5], 
              </span><br/><span class="koboSpan" id="kobo.69.1">              [3, 4],  
              </span><br/><span class="koboSpan" id="kobo.70.1">              [2, 3]])
y = np.dot(X, a)</span></pre>
<p><span class="koboSpan" id="kobo.71.1">In the preceding example, we calculate the product between matrix </span><kbd><span class="koboSpan" id="kobo.72.1">X</span></kbd><em><span class="koboSpan" id="kobo.73.1"> </span></em><span class="koboSpan" id="kobo.74.1">and vector </span><kbd><span class="koboSpan" id="kobo.75.1">a</span></kbd><span class="koboSpan" id="kobo.76.1"> using the </span><kbd><span class="koboSpan" id="kobo.77.1">np.dot()</span></kbd><span class="koboSpan" id="kobo.78.1"> </span><span><span class="koboSpan" id="kobo.79.1">function</span></span><span class="koboSpan" id="kobo.80.1">.</span></p>
<p><span class="koboSpan" id="kobo.81.1">This product is the expression of the model:</span></p>
<pre><span class="koboSpan" id="kobo.82.1">y = Xa</span></pre>
<p><span class="koboSpan" id="kobo.83.1">It represents </span><strong><span class="koboSpan" id="kobo.84.1">one of the most basic models</span></strong><span class="koboSpan" id="kobo.85.1"> used in ML to associate a set of </span><strong><span class="koboSpan" id="kobo.86.1">weights</span></strong><span class="koboSpan" id="kobo.87.1"> (</span><kbd><span class="koboSpan" id="kobo.88.1">a</span></kbd><span class="koboSpan" id="kobo.89.1">) to an </span><strong><span class="koboSpan" id="kobo.90.1">input data matrix</span></strong><span class="koboSpan" id="kobo.91.1"> (</span><kbd><span class="koboSpan" id="kobo.92.1">X</span></kbd><span class="koboSpan" id="kobo.93.1">) in order to obtain the estimated </span><strong><span class="koboSpan" id="kobo.94.1">values</span></strong><span class="koboSpan" id="kobo.95.1"> (</span><kbd><span class="koboSpan" id="kobo.96.1">y</span></kbd><span class="koboSpan" id="kobo.97.1">) as output.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Implementing a simple predictor with NumPy</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To fully understand the use of the </span><kbd><span class="koboSpan" id="kobo.3.1">dot()</span></kbd><span class="koboSpan" id="kobo.4.1"> method of NumPy in matrix multiplication operations, we can try to implement a </span><strong><span class="koboSpan" id="kobo.5.1">simple predictor</span></strong><span class="koboSpan" id="kobo.6.1"> from scratch, to predict future values starting from a set of multiple inputs and on the basis of relative weights, using the product between matrices and vectors:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">import numpy as np</span><br/><span class="koboSpan" id="kobo.8.1">def predict(data, w):  </span><br/><span class="koboSpan" id="kobo.9.1">     return data.dot(w)
</span><br/><span class="koboSpan" id="kobo.10.1"># w is the vector of weights</span><br/><span class="koboSpan" id="kobo.11.1">w = np.array([0.1, 0.2, 0.3]) 
</span><br/><span class="koboSpan" id="kobo.12.1"># matrices as input datasets</span><br/><span class="koboSpan" id="kobo.13.1">data1 = np.array([0.3, 1.5, 2.8]) 
data2 = np.array([0.5, 0.4, 0.9]) 
data3 = np.array([2.3, 3.1, 0.5])</span><br/><span class="koboSpan" id="kobo.14.1">data_in = np.array([data1[0],data2[0],data3[0]]) </span><br/><span class="koboSpan" id="kobo.15.1">print('Predicted value: $%.2f' %  predict(data_in, w) )</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Scikit-learn</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">One of the best and most used ML libraries is definitely the </span><kbd><span class="koboSpan" id="kobo.3.1">scikit-learn</span></kbd><span class="koboSpan" id="kobo.4.1"> library. </span><span class="koboSpan" id="kobo.4.2">First developed in 2007, the </span><kbd><span class="koboSpan" id="kobo.5.1">scikit-learn</span></kbd><span class="koboSpan" id="kobo.6.1"> library provides a series of models and algorithms that are easily reusable in the development of customized solutions, which makes use of the main predictive methods and strategies, including the following:</span></p>
<ul>
<li class="mce-root"><span><span class="koboSpan" id="kobo.7.1">Classification</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.8.1">Regression</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.9.1">Dimensionality reduction</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.10.1">Clustering</span></li>
</ul>
<p><span class="koboSpan" id="kobo.11.1">The list does not end here; in fact, </span><kbd><span class="koboSpan" id="kobo.12.1">scikit-learn</span></kbd><span class="koboSpan" id="kobo.13.1"> also provides ready-to-use modules that allow the following tasks:</span></p>
<ul>
<li class="mce-root"><span><span class="koboSpan" id="kobo.14.1">Data</span></span> <span><span class="koboSpan" id="kobo.15.1">preprocessing</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.16.1">Feature extraction</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.17.1">Hyperparameter optimization</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.18.1">Model evaluation</span></li>
</ul>
<p><span class="koboSpan" id="kobo.19.1">The particularity of </span><kbd><span class="koboSpan" id="kobo.20.1">scikit-learn</span></kbd><span class="koboSpan" id="kobo.21.1"> is that it uses the </span><kbd><span class="koboSpan" id="kobo.22.1">numpy</span></kbd><span class="koboSpan" id="kobo.23.1"> library in addition to the SciPy library for scientific computing. </span><span class="koboSpan" id="kobo.23.2">As we have seen, NumPy allows the optimization of calculation operations performed on large datasets, using multidimensional arrays and matrices.</span></p>
<p><span class="koboSpan" id="kobo.24.1">Among the advantages of </span><kbd><span class="koboSpan" id="kobo.25.1">scikit-learn</span></kbd><span class="koboSpan" id="kobo.26.1">, we must not forget that it provides developers with a very clean </span><span><strong><span class="koboSpan" id="kobo.27.1">application programming interface</span></strong><span class="koboSpan" id="kobo.28.1"> (</span></span><strong><span class="koboSpan" id="kobo.29.1">API</span></strong><span class="koboSpan" id="kobo.30.1">), which makes the development of customized tools from the classes of the library relatively simple.</span></p>
<p><span class="koboSpan" id="kobo.31.1">As an example of using the </span><strong><span class="koboSpan" id="kobo.32.1">predictive analytics</span></strong><span class="koboSpan" id="kobo.33.1"> templates available in </span><kbd><span class="koboSpan" id="kobo.34.1">scikit-learn</span></kbd><span class="koboSpan" id="kobo.35.1">, we will show how to perform a prediction on training data (stored in the </span><kbd><span class="koboSpan" id="kobo.36.1">X</span></kbd><span class="koboSpan" id="kobo.37.1"> matrix) using the </span><strong><span class="koboSpan" id="kobo.38.1">linear regression</span></strong><span class="koboSpan" id="kobo.39.1"> model, based on a </span><kbd><span class="koboSpan" id="kobo.40.1">y</span></kbd><span class="koboSpan" id="kobo.41.1"> weight vector.</span></p>
<p><span class="koboSpan" id="kobo.42.1">Our goal will be to use the </span><kbd><span class="koboSpan" id="kobo.43.1">fit()</span></kbd><span class="koboSpan" id="kobo.44.1"> and </span><kbd><span class="koboSpan" id="kobo.45.1">predict()</span></kbd><span class="koboSpan" id="kobo.46.1"> methods implemented in the </span><kbd><span class="koboSpan" id="kobo.47.1">LinearRegression</span></kbd><span class="koboSpan" id="kobo.48.1"> class:</span></p>
<pre><span class="koboSpan" id="kobo.49.1">import numpy as np</span><br/><span class="koboSpan" id="kobo.50.1">from sklearn.linear_model import LinearRegression</span><br/><br/><span class="koboSpan" id="kobo.51.1"># X is a matrix that represents the training dataset</span><br/><br/><span class="koboSpan" id="kobo.52.1"># y is a vector of weights, to be associated with input dataset</span><br/><br/><span class="koboSpan" id="kobo.53.1">X = np.array([[3], [5], [7], [9], [11]]).reshape(-1, 1) </span><br/><span class="koboSpan" id="kobo.54.1">y = [8.0, 9.1, 10.3, 11.4, 12.6]  </span><br/><span class="koboSpan" id="kobo.55.1">lreg_model = LinearRegression()  </span><br/><span class="koboSpan" id="kobo.56.1">lreg_model.fit(X, y) </span><br/><br/><span class="koboSpan" id="kobo.57.1"># New data (unseen before)</span><br/><span class="koboSpan" id="kobo.58.1">new_data = np.array([[13]]) </span><br/><span class="koboSpan" id="kobo.59.1">print('Model Prediction for new data: $%.2f' </span><br/><span class="koboSpan" id="kobo.60.1">       %  lreg_model.predict(new_data)[0]  )</span><br/><br/></pre>
<p><span class="koboSpan" id="kobo.61.1">Upon execution, the script produces the following output:</span></p>
<pre><span class="koboSpan" id="kobo.62.1">Model Prediction for new data: $13.73</span></pre>
<p><span class="koboSpan" id="kobo.63.1">Let's now continue with the Matplotlib and Seaborn libraries.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Matplotlib and Seaborn</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">One of the analytical tools used the most by analysts in AI and data science consists of the </span><strong><span class="koboSpan" id="kobo.3.1">graphical representation</span></strong><span class="koboSpan" id="kobo.4.1"> of data. </span><span class="koboSpan" id="kobo.4.2">This allows a preliminary activity of data analysis known as </span><strong><span class="koboSpan" id="kobo.5.1">exploratory data analysis</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong><span class="koboSpan" id="kobo.7.1">EDA</span></strong><span class="koboSpan" id="kobo.8.1">). </span><span class="koboSpan" id="kobo.8.2">By means of EDA, it is possible to identify, from a simple visual survey of the data, the possibility of associating them with regularities or </span><strong><span class="koboSpan" id="kobo.9.1">better predictive models</span></strong><span class="koboSpan" id="kobo.10.1"> than others.</span></p>
<p><span class="koboSpan" id="kobo.11.1">Among graphical libraries, without a doubt, the best known and most used is the </span><kbd><span class="koboSpan" id="kobo.12.1">matplotlib</span></kbd><span class="koboSpan" id="kobo.13.1"> library, through which it is possible to create graphs and images of the data being analyzed in a very simple and intuitive way.</span></p>
<p><strong><span class="koboSpan" id="kobo.14.1">Matplotlib</span></strong><span class="koboSpan" id="kobo.15.1"> is basically a </span><strong><span class="koboSpan" id="kobo.16.1">data plotting tool</span></strong><span class="koboSpan" id="kobo.17.1"> inspired by MATLAB, and is similar to the </span><kbd><span class="koboSpan" id="kobo.18.1">ggplot</span></kbd><span class="koboSpan" id="kobo.19.1"> tool used in R.</span></p>
<p><span class="koboSpan" id="kobo.20.1">In the following code, we show a simple example of using the </span><kbd><span class="koboSpan" id="kobo.21.1">matplotlib</span></kbd><span class="koboSpan" id="kobo.22.1"> library, using the </span><kbd><span class="koboSpan" id="kobo.23.1">plot()</span></kbd><span class="koboSpan" id="kobo.24.1"> method to plot input data obtained by the </span><kbd><span class="koboSpan" id="kobo.25.1">arange()</span></kbd><span class="koboSpan" id="kobo.26.1"> method (array range) of the </span><kbd><span class="koboSpan" id="kobo.27.1">numpy</span></kbd><span class="koboSpan" id="kobo.28.1"> library:</span></p>
<pre><span class="koboSpan" id="kobo.29.1">import numpy as np </span><br/><span class="koboSpan" id="kobo.30.1">import matplotlib.pyplot as plt  </span><br/><span class="koboSpan" id="kobo.31.1">plt.plot(np.arange(15), np.arange(15))</span><br/><span class="koboSpan" id="kobo.32.1">plt.show() </span></pre>
<p><span class="koboSpan" id="kobo.33.1">In addition to the </span><kbd><span class="koboSpan" id="kobo.34.1">matplotlib</span></kbd><span class="koboSpan" id="kobo.35.1"> library in Python, there is another well-known visualization tool among data scientists called </span><strong><span class="koboSpan" id="kobo.36.1">Seaborn</span></strong><span class="koboSpan" id="kobo.37.1">.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.38.1">Seaborn is an extension of Matplotlib, which makes various visualization tools </span><span><span class="koboSpan" id="kobo.39.1">available</span></span><span><span class="koboSpan" id="kobo.40.1"> </span></span><span><span class="koboSpan" id="kobo.41.1">for data science, simplifying the analyst's task and relieving them of the task of having to program the graphical data representation tools from scratch, using the basic features offered by</span></span> <kbd><span class="koboSpan" id="kobo.42.1">matplotlib</span></kbd> <span><span class="koboSpan" id="kobo.43.1">and</span></span> <kbd><span class="koboSpan" id="kobo.44.1">scikit-learn</span></kbd><span><span class="koboSpan" id="kobo.45.1">.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Pandas</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The last (but not least) among Python's most used libraries that we'll look at here, is the </span><kbd><span class="koboSpan" id="kobo.3.1">pandas</span></kbd><span class="koboSpan" id="kobo.4.1"> package, which helps to simplify the ordinary activity of data cleaning (an activity that absorbs most of the analyst's time) in order to proceed with the subsequent data analysis phase.</span></p>
<p><span class="koboSpan" id="kobo.5.1">The implementation of </span><kbd><span class="koboSpan" id="kobo.6.1">pandas</span></kbd><span class="koboSpan" id="kobo.7.1"> is very similar to that of the </span><kbd><span class="koboSpan" id="kobo.8.1">DataFrame</span></kbd><span class="koboSpan" id="kobo.9.1"> package in R; DataFrame is nothing but a tabular structure used to store data in the form of a table, on which the columns represent the variables, while the rows represent the data itself.</span></p>
<p><span class="koboSpan" id="kobo.10.1">In the following example, we will show a typical use of a DataFrame, obtained as a result of the instantiation of the </span><kbd><span class="koboSpan" id="kobo.11.1">DataFrame</span></kbd><span class="koboSpan" id="kobo.12.1"> class of </span><kbd><span class="koboSpan" id="kobo.13.1">pandas</span></kbd><span class="koboSpan" id="kobo.14.1">, which receives, as an input parameter, one of the datasets (the </span><kbd><span class="koboSpan" id="kobo.15.1">iris</span></kbd><span class="koboSpan" id="kobo.16.1"> dataset) available in </span><kbd><span class="koboSpan" id="kobo.17.1">scikit-learn</span></kbd><span class="koboSpan" id="kobo.18.1">.</span></p>
<p><span class="koboSpan" id="kobo.19.1">After having instantiated the </span><kbd><span class="koboSpan" id="kobo.20.1">iris_df</span></kbd><span><span class="koboSpan" id="kobo.21.1"> object</span></span><span class="koboSpan" id="kobo.22.1"> of the  </span><kbd><span class="koboSpan" id="kobo.23.1">DataFrame</span></kbd><span class="koboSpan" id="kobo.24.1"> type, the </span><kbd><span class="koboSpan" id="kobo.25.1">head()</span></kbd><span class="koboSpan" id="kobo.26.1"> and </span><kbd><span class="koboSpan" id="kobo.27.1">describe()</span></kbd> <span><span class="koboSpan" id="kobo.28.1">methods </span></span><span class="koboSpan" id="kobo.29.1">of the </span><kbd><span class="koboSpan" id="kobo.30.1">pandas</span></kbd><span class="koboSpan" id="kobo.31.1"> library are invoked, which shows us the first five records of the dataset, respectively, and some of the main statistical measures calculated in the dataset:</span></p>
<pre><span class="koboSpan" id="kobo.32.1">import pandas as pd  </span><br/><span class="koboSpan" id="kobo.33.1">from sklearn import datasets</span><br/><br/><span class="koboSpan" id="kobo.34.1">iris = datasets.load_iris()</span><br/><span class="koboSpan" id="kobo.35.1">iris_df = pd.DataFrame(iris.data, columns = iris.feature_names)</span><br/><span class="koboSpan" id="kobo.36.1">iris_df.head()</span><br/><span class="koboSpan" id="kobo.37.1">iris_df.describe()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Python libraries for cybersecurity</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Python is not only one of the best languages for data science and AI, but also the language preferred by penetration testers and malware analysts (along with low-level languages, such as C and Assembly).</span></p>
<p><span class="koboSpan" id="kobo.3.1">In Python, there are an infinite number of libraries ready for use, which simplify the daily activities of researchers.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Next, we will analyze some of the most common and the most used of them.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Pefile</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The Pefile library is very useful for analyzing Windows executable files, especially during the phases of </span><strong><span class="koboSpan" id="kobo.3.1">static malware analysis</span></strong><span class="koboSpan" id="kobo.4.1">, looking for possible indications of compromise or the presence of malicious code in executables. </span><span class="koboSpan" id="kobo.4.2">In fact, Pefile makes it very easy to analyze the </span><strong><span class="koboSpan" id="kobo.5.1">Portable Executable</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong><span class="koboSpan" id="kobo.7.1">PE</span></strong><span class="koboSpan" id="kobo.8.1">) file format, which represents the standard for the object files (contained or retrievable as libraries of external executable functions) on the Microsoft platform.</span></p>
<p><span class="koboSpan" id="kobo.9.1">So, not only the classic </span><kbd><span class="koboSpan" id="kobo.10.1">.exe</span></kbd><span class="koboSpan" id="kobo.11.1"> files, but also the </span><kbd><span class="koboSpan" id="kobo.12.1">.dll</span></kbd><span class="koboSpan" id="kobo.13.1"> libraries and </span><kbd><span class="koboSpan" id="kobo.14.1">.sys</span></kbd> <span><span class="koboSpan" id="kobo.15.1">device drivers, </span></span><span class="koboSpan" id="kobo.16.1">follow the PE file format specification. </span><span class="koboSpan" id="kobo.16.2">The installation of the Pefile library is very simple; it is sufficient to use the </span><kbd><span class="koboSpan" id="kobo.17.1">pip</span></kbd><span class="koboSpan" id="kobo.18.1"> command as used in the following example:</span></p>
<pre><strong><span class="koboSpan" id="kobo.19.1">pip install pefile</span></strong></pre>
<p><span class="koboSpan" id="kobo.20.1">Once the installation is complete, we can test the library with a simple script such as the following, which loads the executable </span><kbd><span class="koboSpan" id="kobo.21.1">notepad.exe</span></kbd><span class="koboSpan" id="kobo.22.1"> into runtime memory, and then extracts from its executable image some of the most relevant information saved in the relative PE file format fields:</span></p>
<pre><span class="koboSpan" id="kobo.23.1">import os</span><br/><span class="koboSpan" id="kobo.24.1">import pefile</span><br/><span class="koboSpan" id="kobo.25.1">notepad = pefile.PE("notepad.exe", fast_load=True)</span><br/><span class="koboSpan" id="kobo.26.1">dbgRVA = notepad.OPTIONAL_HEADER.DATA_DIRECTORY[6].VirtualAddress</span><br/><span class="koboSpan" id="kobo.27.1">imgver = notepad.OPTIONAL_HEADER.MajorImageVersion</span><br/><span class="koboSpan" id="kobo.28.1">expRVA = notepad.OPTIONAL_HEADER.DATA_DIRECTORY[0].VirtualAddress</span><br/><span class="koboSpan" id="kobo.29.1">iat = notepad.OPTIONAL_HEADER.DATA_DIRECTORY[12].VirtualAddress</span><br/><span class="koboSpan" id="kobo.30.1">sections = notepad.FILE_HEADER.NumberOfSections</span><br/><span class="koboSpan" id="kobo.31.1">dll = notepad.OPTIONAL_HEADER.DllCharacteristics</span><br/><span class="koboSpan" id="kobo.32.1">print("Notepad PE info: \n")</span><br/><span class="koboSpan" id="kobo.33.1">print ("Debug RVA: " + dbgRVA)</span><br/><span class="koboSpan" id="kobo.34.1">print ("\nImage Version: " + imgver)</span><br/><span class="koboSpan" id="kobo.35.1">print ("\nExport RVA: " + expRVA)</span><br/><span class="koboSpan" id="kobo.36.1">print ("\nImport Address Table: " + iat)</span><br/><span class="koboSpan" id="kobo.37.1">print ("\nNumber of Sections: " + sections)</span><br/><span class="koboSpan" id="kobo.38.1">print ("\nDynamic linking libraries: " + dll)</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Volatility</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Another tool widely used by malware analysts is </span><strong><span class="koboSpan" id="kobo.3.1">volatility</span></strong><span class="koboSpan" id="kobo.4.1">, which allows the analysis of the runtime memory of an executable process, highlighting the presence of possible malware code.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Volatility is a Python-programmable utility, which is often installed by default in distributions for malware analysis and pentesting, such as Kali Linux. </span><span class="koboSpan" id="kobo.5.2">Volatility allows the extraction of important information about processes (such as API hooks, network connections and kernel modules) directly from memory dumps, providing the analyst with a suite of programmable tools using Python.</span></p>
<p><span class="koboSpan" id="kobo.6.1">These tools allow the extraction from the memory dumps of all the processes running on the system and any relevant information about injected </span><strong><span><span class="koboSpan" id="kobo.7.1">Dynamic-Link Libraries</span></span></strong><span class="koboSpan" id="kobo.8.1"> (</span><strong><span class="koboSpan" id="kobo.9.1">DLLs</span></strong><span><span class="koboSpan" id="kobo.10.1">)</span></span><span class="koboSpan" id="kobo.11.1">, along with the presence of rootkits, or more generally, the presence of </span><strong><span class="koboSpan" id="kobo.12.1">hidden processes</span></strong><span class="koboSpan" id="kobo.13.1"> within the runtime memory, which easily escapes the detection of common antivirus softwares.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Installing Python libraries</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We have seen some of the basic Python libraries, which are useful for our analysis purposes. </span><span class="koboSpan" id="kobo.2.2">How do we install these libraries in our development environment?</span></p>
<p><span class="koboSpan" id="kobo.3.1">Being Python libraries, it is obviously possible to proceed with the installation simply by following the traditional utilities provided by the language; in particular, using the </span><kbd><span class="koboSpan" id="kobo.4.1">pip</span></kbd><span class="koboSpan" id="kobo.5.1"> command, or launching the </span><kbd><span class="koboSpan" id="kobo.6.1">setup.py</span></kbd><em><span class="koboSpan" id="kobo.7.1"> </span></em><span class="koboSpan" id="kobo.8.1">provided by each library package. </span><span class="koboSpan" id="kobo.8.2">However, there is a much easier way to proceed with the configuration of an analysis and development environment in the field of AI and data science, using Anaconda, as we will see in the upcoming sections.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Enter Anaconda – the data scientist's environment of choice</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Given the large number of available Python libraries, their installation is often particularly tedious (if not boring), as well as difficult, especially for those who are beginning their approach to the world of data science and AI.</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.3.1">To facilitate the setup of an already preconfigured development environment, </span><span><span class="koboSpan" id="kobo.4.1">collections of packages and libraries, such as Anaconda (</span></span><a href="http://www.anaconda.com/download/"><span class="koboSpan" id="kobo.5.1">http://www.anaconda.com/download/</span></a><span><span class="koboSpan" id="kobo.6.1">) are made available. </span></span><span class="koboSpan" id="kobo.7.1">This allows quick access to the most used tools and libraries, thus speeding up development activities, without the need to waste time solving problems with dependencies between packages, or installation issues with the various operating systems.</span></p>
<p><span class="koboSpan" id="kobo.8.1">While I'm writing this, the latest available version of Anaconda released is 5.3.0 (available for download at </span><a href="https://www.anaconda.com/anaconda-distribution-5-3-0-released/"><span class="koboSpan" id="kobo.9.1">https://www.anaconda.com/anaconda-distribution-5-3-0-released/</span></a><span class="koboSpan" id="kobo.10.1">).</span></p>
<p><span class="koboSpan" id="kobo.11.1">You can choose the installation distribution for your platform of choice, whether it is Windows, Linux, or macOS, 32-bit or 64-bit or Python 3.7 or 2.7, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1"><img src="assets/6dcb7f19-35fd-4f4d-b1f5-77830903a125.png"/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Anaconda Python advantages</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Anaconda is a collection of over 700 packages developed in Python, among which are the data analysis and ML libraries we talked about in the previous paragraphs, among many others:</span></p>
<ul>
<li class="mce-root"><span><span class="koboSpan" id="kobo.3.1">NumPy</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.4.1">SciPy</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.5.1">Scikit-learn</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.6.1">Pandas</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.7.1">Matplotlib</span></li>
</ul>
<p><span class="koboSpan" id="kobo.8.1">In addition, Anaconda allows you to configure custom environments, within which you can install specific versions not only of Python but also packages and libraries used for development.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Conda utility</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Anaconda provides a very powerful utility, conda. </span><span class="koboSpan" id="kobo.2.2">Through conda, it is possible to manage and update already installed packages, or install new packages, as well as to create custom environments in the easiest possible way.</span></p>
<p><span class="koboSpan" id="kobo.3.1">To access the conda help menu, run the following command from Command Prompt:</span></p>
<pre><strong><span class="koboSpan" id="kobo.4.1">conda -h</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Installing packages in Anaconda</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">With the conda utility, it is possible to install new packages not included in the collection of pre-installed packages. </span><span class="koboSpan" id="kobo.2.2">To proceed with the installation of a new package, simply execute the following command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.3.1">conda install</span></strong></pre>
<p><span class="koboSpan" id="kobo.4.1">The command being executed will search among the packages contained in the online repository of Anaconda Continuum Analytics. </span><span class="koboSpan" id="kobo.4.2">Remember that it is always possible to proceed with the traditional methods of installation, by resorting to the </span><kbd><span class="koboSpan" id="kobo.5.1">pip install</span></kbd><span class="koboSpan" id="kobo.6.1"> commands or by launching the </span><kbd><span class="koboSpan" id="kobo.7.1">setup.py</span></kbd><span class="koboSpan" id="kobo.8.1"> file contained in the package.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Obviously, in this case, we will have to worry about solving all the possible dependencies and compatibility problems between versions.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Creating custom environments</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As mentioned, one of the strengths of Anaconda is its ability to create custom environments, within which we can install specific software versions of both Python and of the various packages. </span><span class="koboSpan" id="kobo.2.2">Anaconda is in fact usually available with the pre-installed versions of Python 2.7 and Python 3.7. </span><span class="koboSpan" id="kobo.2.3">You can decide to combine specific versions of Python, without incurring the risk of corrupting the default environments. </span><span class="koboSpan" id="kobo.2.4">To achieve this, you’ll need to create custom environments.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Let’s assume we want to create a custom environment in which we would like to install the version of Python 3.5 (or another version). </span><span class="koboSpan" id="kobo.3.2">Just invoke the conda utility as in the following example:</span></p>
<pre><strong><span class="koboSpan" id="kobo.4.1">conda create -n py35 python=3.5</span></strong></pre>
<p><span class="koboSpan" id="kobo.5.1">At this point, </span><kbd><span class="koboSpan" id="kobo.6.1">conda</span></kbd><span class="koboSpan" id="kobo.7.1"> proceeds with the creation and configuration of the new custom environment named </span><kbd><span class="koboSpan" id="kobo.8.1">py35</span></kbd><span class="koboSpan" id="kobo.9.1">, in which the version of Python 3.5 is installed. </span><span class="koboSpan" id="kobo.9.2">To activate the newly created environment, just run the following command from Command Prompt:</span></p>
<pre><strong><span class="koboSpan" id="kobo.10.1">activate py35</span></strong></pre>
<p><span class="koboSpan" id="kobo.11.1">From now on, all the commands launched will be executed in the </span><kbd><span class="koboSpan" id="kobo.12.1">py35</span></kbd><span><span class="koboSpan" id="kobo.13.1"> custom environment</span></span><span class="koboSpan" id="kobo.14.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Some useful Conda commands</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Some of the useful Conda commands are as follows:</span></p>
<ul>
<li class="CDPAlignLeft CDPAlign"><span class="koboSpan" id="kobo.3.1">To activate the newly created </span><kbd><span class="koboSpan" id="kobo.4.1">py35</span></kbd><span class="koboSpan" id="kobo.5.1"> custom environment, run the following command:</span></li>
</ul>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.6.1">activate py35</span></strong></pre>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Install packages in a specific environment by executing the following commands:</span></li>
</ul>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.8.1">conda install -n py35 PACKAGE-NAME</span></strong><br/><strong><span class="koboSpan" id="kobo.9.1">conda install -n py35 seaborn</span></strong></pre>
<ul>
<li><span class="koboSpan" id="kobo.10.1">List the installed packages of a specific environment by running the following command:</span></li>
</ul>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.11.1">conda list -n py35</span></strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ul>
<li><span class="koboSpan" id="kobo.12.1">Update Anaconda with the following commands:</span></li>
</ul>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.13.1">conda update conda</span></strong><br/><strong><span class="koboSpan" id="kobo.14.1">conda update –all</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Python on steroids with parallel GPU</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To fully exploit the potential of some ML libraries, and especially DL, it is necessary to deploy dedicated hardware that includes the use of </span><strong><span class="koboSpan" id="kobo.3.1">graphics processing units</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">GPU</span></strong><span class="koboSpan" id="kobo.6.1">s) in addition to traditional CPUs. </span><span class="koboSpan" id="kobo.6.2">As current GPUs are, in fact, optimized to perform parallel calculations, this feature is very useful for the effective execution of many DL algorithms.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Reference hardware equipment could be the following:</span></p>
<ul>
<li class="mce-root"><span><span class="koboSpan" id="kobo.8.1">CPU Intel Core i5 6</span><sup><span class="koboSpan" id="kobo.9.1">th</span></sup><span class="koboSpan" id="kobo.10.1"> Generation or higher (or AMD equivalent)</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.11.1">8 GB RAM as a minimum (16 GB or higher is recommended)</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.12.1">GPU  NVIDIA GeForce GTX 960 or higher (visit </span><a href="https://developer.nvidia.com/cuda-gpus"><span class="koboSpan" id="kobo.13.1">https://developer.nvidia.com/cuda-gpus</span></a> <span><span class="koboSpan" id="kobo.14.1">for more info)</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.15.1">Linux operating system (for example Ubuntu) or Microsoft Windows 10</span></li>
</ul>
<p><span class="koboSpan" id="kobo.16.1">By leveraging the Numba compiler provided by Anaconda, you can compile the Python code and run it on CUDA-capable GPUs.</span></p>
<p><span class="koboSpan" id="kobo.17.1">For further information, please refer to the website of your GPU manufacturer and the Numba documentation (</span><a href="https://numba.pydata.org/numba-doc/latest/user/index.html"><span class="koboSpan" id="kobo.18.1">https://numba.pydata.org/numba-doc/latest/user/index.html</span></a><span class="koboSpan" id="kobo.19.1">).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Playing with Jupyter Notebooks</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Among the most useful tools for the developer, there is undoubtedly the </span><strong><span class="koboSpan" id="kobo.3.1">Jupyter Notebook</span></strong><span class="koboSpan" id="kobo.4.1">, which allows, in a single document, the integration of both the Python code and the result of its execution, including images and graphics. </span><span class="koboSpan" id="kobo.4.2">In this way, it is possible to receive immediate feedback on the development activity in progress, managing the various phases of programming in an iterative manner.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Inside the Jupyter Notebook, it is possible to recall the various specific libraries installed in a custom environment. </span><span class="koboSpan" id="kobo.5.2">Jupyter is a web-based utility, so to run the notebook you need to run the following command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.6.1">jupyter notebook</span></strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.7.1">It is also possible to specify the listening port of the service, using the </span><kbd><span class="koboSpan" id="kobo.8.1">port</span></kbd><span class="koboSpan" id="kobo.9.1"> parameter:</span></p>
<pre><strong><span class="koboSpan" id="kobo.10.1">jupyter notebook --port 9000</span></strong></pre>
<p><span class="koboSpan" id="kobo.11.1">In this way, the service will be started on the listening port </span><kbd><span class="koboSpan" id="kobo.12.1">9000</span></kbd><span class="koboSpan" id="kobo.13.1"> (instead of the default </span><kbd><span class="koboSpan" id="kobo.14.1">8888</span></kbd><span class="koboSpan" id="kobo.15.1">).</span></p>
<p><span class="koboSpan" id="kobo.16.1">Jupyter is among the packages that come pre-installed with Anaconda; it is not necessary to install the software as it is readily available for use.</span></p>
<p><span class="koboSpan" id="kobo.17.1">In the next paragraphs, we will learn how to use the Jupyter Notebook using some examples.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Our first Jupyter Notebook</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Once Jupyter is started, you can open an existing notebook inside the root directory (which can be viewed at </span><a href="http://localhost:8888/tree"><span class="koboSpan" id="kobo.3.1">http://localhost:8888/tree</span></a><span class="koboSpan" id="kobo.4.1">) from which the service was started, or proceed to create a new notebook from scratch:</span></p>
<p class="mce-root CDPAlignCenter CDPAlign"/>
<p><span class="koboSpan" id="kobo.5.1">Notebooks are nothing more than text files with the extension </span><kbd><span class="koboSpan" id="kobo.6.1">.ipynb</span></kbd><span class="koboSpan" id="kobo.7.1">, inside which are saved (in JSON format) Python code and other media resources (such as images coded in base64).</span></p>
<p><span class="koboSpan" id="kobo.8.1">To create our first notebook, simply use the menu items available in the dashboard's interface, which is very intuitive.</span></p>
<p><span class="koboSpan" id="kobo.9.1">All we have to do is to select the folder in which to place the newly created notebook, then click on the </span><span class="packt_screen"><span class="koboSpan" id="kobo.10.1">New</span></span><span class="koboSpan" id="kobo.11.1"> button and choose the version of Python that most suits our needs, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1"><img src="assets/3ffca135-c9c6-4170-97a0-2bb7dc7340f0.png" style="width:14.75em;height:14.42em;"/></span></p>
<p><span class="koboSpan" id="kobo.13.1">At this point, we can rename the newly created notebook and then proceed with the insertion of the cells within the document:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.14.1"><img src="assets/b8301e28-2d33-40cc-a4f0-07e52cbe4d74.png" style="width:53.42em;height:20.08em;"/></span></p>
<p><span class="koboSpan" id="kobo.15.1">We can specify the type of content of the cell, choosing between code (default) text, markdown, and other options:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.16.1"><img src="assets/b36e0ac5-1190-42c3-b565-4bd98e2ed16e.png" style="width:51.00em;height:18.50em;"/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Exploring the Jupyter interface</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Next, we will explore in more detail some of the common tasks in the management of notebooks, starting with the renaming of files. </span><span class="koboSpan" id="kobo.2.2">The default filename assigned to newly created notebooks is, in fact, </span><kbd><span class="koboSpan" id="kobo.3.1">Untitled.ipynb</span></kbd><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">We must keep that in mind to proceed with the renaming of a notebook; this must not be in the running state. </span><span class="koboSpan" id="kobo.4.3">Therefore, make sure to select </span><span><span class="koboSpan" id="kobo.5.1">the</span></span><span class="koboSpan" id="kobo.6.1"> </span><span class="packt_screen"><span class="koboSpan" id="kobo.7.1">File</span></span><span class="koboSpan" id="kobo.8.1"> | </span><span class="packt_screen"><span class="koboSpan" id="kobo.9.1">Close and Halt</span></span><span><span class="koboSpan" id="kobo.10.1"> menu item </span></span><span class="koboSpan" id="kobo.11.1">before assigning a new name to the notebook; simply select the file to be renamed in the directory and click on </span><span class="packt_screen"><span class="koboSpan" id="kobo.12.1">Rename</span></span><span class="koboSpan" id="kobo.13.1"> among the dashboard controls:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.14.1"><img src="assets/5148652e-098a-41b3-9099-7072d2c25511.png" style="width:27.92em;height:34.58em;"/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">What's in a cell?</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The cells represent containers in which it is possible to insert different types of content; the most commonly occurring content of a cell obviously consists of Python code to be executed inside the notebook, but it is also possible to insert plain text or markdown inside a cell.</span></p>
<p><span class="koboSpan" id="kobo.3.1">When we insert Python code, the result of the execution is immediately shown below the code, within the same cell. </span><span class="koboSpan" id="kobo.3.2">To insert a new cell, click on </span><span class="packt_screen"><span class="koboSpan" id="kobo.4.1">Insert</span></span><span class="koboSpan" id="kobo.5.1"> from the menu bar, and select </span><span class="packt_screen"><span class="koboSpan" id="kobo.6.1">Insert Cell Below</span></span><span class="koboSpan" id="kobo.7.1">.</span></p>
<p><span class="koboSpan" id="kobo.8.1">Alternatively, a keyboard shortcut can be used.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Useful keyboard shortcuts</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To speed up the execution of the most common commands, the Jupyter interface provides us with a series of keyboard shortcuts, including the following:</span></p>
<ul>
<li class="mce-root"><em><span class="koboSpan" id="kobo.3.1">Ctrl</span></em><span class="koboSpan" id="kobo.4.1"> + </span><em><span class="koboSpan" id="kobo.5.1">Enter</span></em><span><span class="koboSpan" id="kobo.6.1">: Run the selected cell</span></span></li>
<li class="mce-root"><em><span class="koboSpan" id="kobo.7.1">Esc</span></em><span class="koboSpan" id="kobo.8.1"> or </span><em><span class="koboSpan" id="kobo.9.1">Enter</span></em><span class="koboSpan" id="kobo.10.1">: Toggle between edit and command mode</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.11.1">Up and down keys: Scroll cells up/down (command mode)</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.12.1">Press </span><em><span class="koboSpan" id="kobo.13.1">A</span></em><span class="koboSpan" id="kobo.14.1"> or </span><em><span class="koboSpan" id="kobo.15.1">B</span></em><span class="koboSpan" id="kobo.16.1">: Insert a new cell above or below the active cell</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.17.1">Press </span><em><span class="koboSpan" id="kobo.18.1">Y</span></em><span class="koboSpan" id="kobo.19.1">: Set the active cell as a code cell</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.20.1">Press </span><em><span class="koboSpan" id="kobo.21.1">M</span></em><span class="koboSpan" id="kobo.22.1">: Transform the active cell to a markdown cell</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.23.1">Press </span><em><span class="koboSpan" id="kobo.24.1">D</span></em><span class="koboSpan" id="kobo.25.1"> twice: Delete the active cell</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.26.1">Press </span><em><span class="koboSpan" id="kobo.27.1">Z</span></em><span class="koboSpan" id="kobo.28.1">: Undo cell deletion</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Choose your notebook kernel</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A particularly interesting feature of notebooks is that behind each notebook hides a specific kernel. </span><span class="koboSpan" id="kobo.2.2">When we execute a cell containing Python code, that code is executed in the </span><strong><span class="koboSpan" id="kobo.3.1">specific kernel</span></strong><span class="koboSpan" id="kobo.4.1"> of the notebook.</span></p>
<p><span class="koboSpan" id="kobo.5.1">We can then select and assign a specific kernel to a single notebook, in case we have installed several different environments:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.6.1"><img src="assets/b901812d-f397-4f7c-823e-faba57c15da3.png" style="width:52.33em;height:26.50em;"/></span></p>
<p><span class="koboSpan" id="kobo.7.1">It is, in fact, possible to install not only different kernels for different versions of Python, but also kernels for other languages such as Java, C, R and Julia.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting your hands dirty</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To close the Jupyter Notebook argument, we will now try to insert a series of cells with example Python code inside, recalling the libraries and packages that we need, by performing the following steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.3.1">Proceed to insert a new cell, within which we write the following commands:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.4.1"># Execute plot() inline without calling show()</span><br/><span class="koboSpan" id="kobo.5.1">%matplotlib inline</span><br/><span class="koboSpan" id="kobo.6.1">import numpy as np </span><br/><span class="koboSpan" id="kobo.7.1">import matplotlib.pyplot as plt  </span><br/><span class="koboSpan" id="kobo.8.1">plt.plot(np.arange(15), np.arange(15))</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p style="padding-left: 60px"><span class="koboSpan" id="kobo.9.1">We should get the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.10.1"><img src="assets/f8da3ad1-77a1-46f3-b6fa-44c785188950.png" style="width:31.75em;height:15.75em;"/></span></p>
<ol start="2">
<li><span class="koboSpan" id="kobo.11.1">Now, add a new cell, within which we will write the following code:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.12.1">import numpy as np </span><br/><span class="koboSpan" id="kobo.13.1">from sklearn.linear_model import LinearRegression</span><br/><br/><span class="koboSpan" id="kobo.14.1"># X is a matrix that represents the training dataset</span><br/><span class="koboSpan" id="kobo.15.1"># y is a vector of weights, to be associated with input dataset</span><br/><br/><span class="koboSpan" id="kobo.16.1">X = np.array([[3], [5], [7], [9], [11]]).reshape(-1, 1) </span><br/><span class="koboSpan" id="kobo.17.1">y = [8.0, 9.1, 10.3, 11.4, 12.6]  
lreg_model = LinearRegression()  </span><br/><span class="koboSpan" id="kobo.18.1">lreg_model.fit(X, y) </span><br/><br/><span class="koboSpan" id="kobo.19.1"># New data (unseen before)</span><br/><span class="koboSpan" id="kobo.20.1">new_data = np.array([[13]]) </span><br/><span class="koboSpan" id="kobo.21.1">print('Model Prediction for new data: $%.2f' </span><br/><span class="koboSpan" id="kobo.22.1">       %  lreg_model.predict(new_data)[0]  ) </span></pre>
<p style="padding-left: 60px"><span class="koboSpan" id="kobo.23.1">By running the preceding code, we should get the following output:</span></p>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.24.1">Model Prediction for new data: $13.73</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.25.1">Finally, we insert a new cell, within which we will write the following code:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.26.1">import pandas as pd  </span><br/><span class="koboSpan" id="kobo.27.1">from sklearn import datasets</span><br/><span class="koboSpan" id="kobo.28.1">iris = datasets.load_iris()</span><br/><span class="koboSpan" id="kobo.29.1">iris_df = pd.DataFrame(iris.data, columns = iris.feature_names)</span><br/><span class="koboSpan" id="kobo.30.1">iris_df.head()</span><br/><span class="koboSpan" id="kobo.31.1">iris_df.describe()</span></pre>
<p style="padding-left: 60px"><span class="koboSpan" id="kobo.32.1">Launching the execution of the code inside the cell, we should get the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.33.1"><img src="assets/7cd389c6-abb0-416c-9e8d-6b2abbe7de8a.png" style="width:45.08em;height:16.00em;"/></span></p>
<p><span class="koboSpan" id="kobo.34.1">Congratulations! </span><span class="koboSpan" id="kobo.34.2">If everything went as described, you have successfully verified your configuration and can proceed further.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Installing DL libraries</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this section, we will consider the advantages of installing some of the main Python libraries for AI, in particular, to exploit the potential of deep learning.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The libraries that we will cover are as follows:</span></p>
<ul>
<li class="mce-root"><span><span class="koboSpan" id="kobo.4.1">TensorFlow</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.5.1">Keras</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.6.1">PyTorch</span></li>
</ul>
<p><span class="koboSpan" id="kobo.7.1">Prior to discovering the advantages of the individual libraries and proceeding with their installation, let's spend a few words on the advantages and characteristics of deep learning for cybersecurity.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Deep learning pros and cons for cybersecurity</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">One of the distinctive features of deep learning, compared to other branches of AI, is the ability to exploit general-purpose algorithms, by leveraging neural networks. </span><span class="koboSpan" id="kobo.2.2">In this way, it is possible to face similar problems that entail several different application domains, by reusing common algorithms elaborated in different contexts.</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.3.1">The deep learning approach exploits the possibility of </span><strong><span class="koboSpan" id="kobo.4.1">neural networks</span></strong> <span><span class="koboSpan" id="kobo.5.1">(</span></span><strong><span class="koboSpan" id="kobo.6.1">NNs</span></strong><span><span class="koboSpan" id="kobo.7.1">) </span></span><span class="koboSpan" id="kobo.8.1">to add multiple processing layers, each layer having the task of executing different types of processing, sharing the results of the processing with the other layers.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Within a neural network, at least one layer is hidden, thus simulating the behavior of human brain neurons.</span></p>
<p><span class="koboSpan" id="kobo.10.1">Among the most common uses of deep learning, are the following:</span></p>
<ul>
<li><span><span class="koboSpan" id="kobo.11.1">Speech recognition</span></span></li>
<li><span><span class="koboSpan" id="kobo.12.1">Video anomaly detection</span></span></li>
<li><strong><span class="koboSpan" id="kobo.13.1">Natural language processing</span></strong> <span><span class="koboSpan" id="kobo.14.1">(</span></span><strong><span class="koboSpan" id="kobo.15.1">NLP</span></strong><span><span class="koboSpan" id="kobo.16.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">These use cases are also of particular importance in the field of cybersecurity.</span></p>
<p><span class="koboSpan" id="kobo.18.1">For example, for </span><strong><span class="koboSpan" id="kobo.19.1">biometric authentication </span></strong><span class="koboSpan" id="kobo.20.1">procedures, which are </span><span><span class="koboSpan" id="kobo.21.1">increasingly </span></span><span class="koboSpan" id="kobo.22.1">carried out by resorting to deep learning algorithms, deep learning can also be used successfully in the detection of anomalous user behaviors, or in the abnormal use of payment instruments, such as credit cards, as part of </span><strong><span class="koboSpan" id="kobo.23.1">fraud detection </span></strong><span class="koboSpan" id="kobo.24.1">procedures.</span></p>
<p><span class="koboSpan" id="kobo.25.1">Another important use of deep learning is in the detection of possible malware or networking threats. </span><span class="koboSpan" id="kobo.25.2">Given the vast potential for using deep learning, it should not be surprising that even bad guys have begun to use it.</span></p>
<p><span class="koboSpan" id="kobo.26.1">In particular, the recent spread of evolved neural networks such as </span><strong><span class="koboSpan" id="kobo.27.1">generative adversarial networks</span></strong><span class="koboSpan" id="kobo.28.1"> (</span><strong><span class="koboSpan" id="kobo.29.1">GANs</span></strong><span class="koboSpan" id="kobo.30.1">) is posing a serious challenge to traditional biometric authentication procedures, which resort to </span><strong><span class="koboSpan" id="kobo.31.1">facial recognition</span></strong><span class="koboSpan" id="kobo.32.1"> or </span><strong><span class="koboSpan" id="kobo.33.1">voice recognition</span></strong><span class="koboSpan" id="kobo.34.1">. </span><span class="koboSpan" id="kobo.34.2">By using a GAN, it is, in fact, possible to generate </span><strong><span class="koboSpan" id="kobo.35.1">artificial samples of biometric evidence</span></strong><span class="koboSpan" id="kobo.36.1">, which are practically indistinguishable from the original ones.</span></p>
<p><span class="koboSpan" id="kobo.37.1">We will delve deeper into this in the upcoming chapters.</span></p>
<p><span class="koboSpan" id="kobo.38.1">Now, let's see how to proceed with the installation of the main deep learning libraries within our development environment.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">TensorFlow</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The first deep learning library we will deal with is TensorFlow; in fact, it plays a special role, having been specifically developed to program </span><strong><span class="koboSpan" id="kobo.3.1">deep neural network</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">DNN</span></strong><span class="koboSpan" id="kobo.6.1">) models.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.7.1">To proceed with the installation of TensorFlow within Anaconda, we must first proceed with the creation of a custom environment (if we have not already created one) by performing the following steps:</span></p>
<p><span class="koboSpan" id="kobo.8.1">In our case, we will use the custom environment </span><kbd><span class="koboSpan" id="kobo.9.1">py35</span></kbd><span class="koboSpan" id="kobo.10.1">, which was previously created:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.11.1">Install TensorFlow with conda:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.12.1">conda install -n py35 -c conda-forge tensorflow</span></strong></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.13.1">Install a specific version of TensorFlow by using the following command:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.14.1">conda install -n py35 -c conda-forge tensorflow=1.0.0</span></strong></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.15.1">We can test our installation by running a sample TensorFlow program in an interactive conda session as follows:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.16.1">activate py35</span></strong><br/><strong><span class="koboSpan" id="kobo.17.1">python</span></strong><br/><strong><span class="koboSpan" id="kobo.18.1">&gt;&gt;&gt; import tensorflow as tf</span></strong><br/><strong><span class="koboSpan" id="kobo.19.1">&gt;&gt;&gt; hello = tf.constant('Hello, TensorFlow!')</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1">&gt;&gt;&gt; sess = tf.Session()</span></strong><br/><strong><span class="koboSpan" id="kobo.21.1">&gt;&gt;&gt; print(sess.run(hello))</span></strong></pre>
<p><span class="koboSpan" id="kobo.22.1">For further documentation, visit the TensorFlow website at </span><a href="https://www.tensorflow.org/"><span class="koboSpan" id="kobo.23.1">https://www.tensorflow.org/</span></a><span class="koboSpan" id="kobo.24.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Keras</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The other deep learning library we will install is </span><kbd><span class="koboSpan" id="kobo.3.1">keras</span></kbd><span class="koboSpan" id="kobo.4.1">.</span></p>
<p><span class="koboSpan" id="kobo.5.1">A characteristic of Keras is that it can be installed on top of TensorFlow, thus constituting a high-level interface (with respect to TensorFlow) for NN development. </span><span class="koboSpan" id="kobo.5.2">Also, in the case of Keras, as with TensorFlow, we will proceed to the installation inside our custom environment </span><kbd><span class="koboSpan" id="kobo.6.1">py35</span></kbd><span class="koboSpan" id="kobo.7.1">, which we created previously, by executing the following command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.8.1">conda install -n py35 -c conda-forge keras</span></strong></pre>
<p><span class="koboSpan" id="kobo.9.1">For further documentation, visit the Keras website at </span><a href="https://keras.io/"><span class="koboSpan" id="kobo.10.1">https://keras.io/</span></a><span class="koboSpan" id="kobo.11.1">.</span><a href="https://keras.io/"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">PyTorch</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The last example of a deep learning library we will examine here is </span><kbd><span class="koboSpan" id="kobo.3.1">pytorch</span></kbd><span class="koboSpan" id="kobo.4.1">.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.5.1">PyTorch is a project developed by Facebook, specially designed to perform large-scale image analysis. </span><span class="koboSpan" id="kobo.5.2">Even in the case of PyTorch, installation (always within the </span><kbd><span class="koboSpan" id="kobo.6.1">py35</span></kbd><span class="koboSpan" id="kobo.7.1"> environment) via conda is rather simple:</span></p>
<pre><strong><span class="koboSpan" id="kobo.8.1">conda install -n py35 -c peterjc123 pytorch</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">PyTorch versus TensorFlow</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To compare both of the learning libraries, it should be noted that PyTorch is the most optimized solution for performing tensor calculus tasks on GPUs, as it has been specifically designed to improve performance in large-scale contexts.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Some of the most common use cases for using PyTorch are as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.4.1">NLP</span></li>
<li><span><span class="koboSpan" id="kobo.5.1">Large-scale image processing</span></span></li>
<li><span><span class="koboSpan" id="kobo.6.1">Social media analysis</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.7.1">However, when compared only on the basis of performance, both PyTorch and TensorFlow are excellent choices; there are other characteristics that could make you lean toward one solution or the other.</span></p>
<p><span class="koboSpan" id="kobo.8.1">For example, in TensorFlow, the debugging of programs is more complex than in PyTorch. </span><span class="koboSpan" id="kobo.8.2">This is because, in TensorFlow, development is more cumbersome (having to define tensors, initialize a session, keep track of tensors during the session, and so on), while the deployment of the TensorFlow model is certainly preferred.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this chapter, the indispensable tools for carrying out analysis and development activities in AI in the cybersecurity field have been illustrated. </span><span class="koboSpan" id="kobo.2.2">We looked at the main AI libraries and introduced the advantages and disadvantages of using deep learning in the field of cybersecurity.</span></p>
<p><span class="koboSpan" id="kobo.3.1">In the following chapters, we will learn how to use the tools at our disposal in the best possible way, consciously choosing those that most reflect our security analysis strategies.</span></p>
<p><span class="koboSpan" id="kobo.4.1">In the next chapter, we will start with the development of appropriate classifiers for </span><span><span class="koboSpan" id="kobo.5.1">email </span></span><span class="koboSpan" id="kobo.6.1">spam detection.</span></p>


            </article>

            
        </section>
    </body></html>