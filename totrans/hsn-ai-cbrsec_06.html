<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Malware Threat Detection</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The high diffusion of malware and ransomware codes, together with the rapid polymorphic mutation in the different variants (polymorphic and metamorphic malware) of the same threats, has made traditional detection solutions based on signatures and hashing of image files </span><span><span class="koboSpan" id="kobo.3.1">obsolete</span></span><span class="koboSpan" id="kobo.4.1">, on which most common antivirus software is based.</span></p>
<p><span class="koboSpan" id="kobo.5.1">It is therefore increasingly necessary to resort to </span><strong><span class="koboSpan" id="kobo.6.1">machine learning</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong><span class="koboSpan" id="kobo.8.1">ML</span></strong><span class="koboSpan" id="kobo.9.1">) solutions that allow a rapid screening (</span><strong><span class="koboSpan" id="kobo.10.1">triage</span></strong><span class="koboSpan" id="kobo.11.1">) of threats, focusing attention on not wasting scarce resources such as a malware analyst's skills and efforts.</span></p>
<p><span class="koboSpan" id="kobo.12.1">This chapter will cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Introducing the malware analysis methodology</span></li>
<li><span class="koboSpan" id="kobo.14.1">How to tell different malware families apart</span></li>
<li><span class="koboSpan" id="kobo.15.1">Decision tree malware detectors</span></li>
<li><span class="koboSpan" id="kobo.16.1">Detecting metamorphic malware with </span><strong><span class="koboSpan" id="kobo.17.1">Hidden Markov Models</span></strong><span class="koboSpan" id="kobo.18.1"> (</span><strong><span class="koboSpan" id="kobo.19.1">HMMs</span></strong><span class="koboSpan" id="kobo.20.1">)</span></li>
<li><span class="koboSpan" id="kobo.21.1">Advanced malware detection with deep learning</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Malware analysis at a glance</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">One of the most interesting aspects for those approaching malware analysis, is learning to distinguish, for example, legitimate binary files from those that are potentially dangerous for the integr</span><span><span class="koboSpan" id="kobo.3.1">ity</span></span><span class="koboSpan" id="kobo.4.1"> of the machines and the data they contain. </span><span class="koboSpan" id="kobo.4.2">We refer generically to </span><strong><span class="koboSpan" id="kobo.5.1">binary</span></strong><span class="koboSpan" id="kobo.6.1"> files rather than to </span><strong><span class="koboSpan" id="kobo.7.1">executable</span></strong><span class="koboSpan" id="kobo.8.1"> files (that is, files with extensions such as </span><kbd><span class="koboSpan" id="kobo.9.1">.exe</span></kbd><span class="koboSpan" id="kobo.10.1"> or </span><kbd><span class="koboSpan" id="kobo.11.1">.dll</span></kbd><span class="koboSpan" id="kobo.12.1">), since malware can </span><span><span class="koboSpan" id="kobo.13.1">even </span></span><span class="koboSpan" id="kobo.14.1">hide in apparently innocuous files such as image files (</span><span><span class="koboSpan" id="kobo.15.1">files with extensions such as</span></span> <kbd><span class="koboSpan" id="kobo.16.1">.jpg</span></kbd><span class="koboSpan" id="kobo.17.1"> or </span><kbd><span class="koboSpan" id="kobo.18.1">.png</span></kbd><span class="koboSpan" id="kobo.19.1">).</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.20.1">In the same way, even text documents (such as </span><kbd><span class="koboSpan" id="kobo.21.1">.docx</span></kbd><span class="koboSpan" id="kobo.22.1"> or </span><kbd><span class="koboSpan" id="kobo.23.1">.pdf</span></kbd><span class="koboSpan" id="kobo.24.1">) can turn out to be </span><strong><span class="koboSpan" id="kobo.25.1">healthy carriers</span></strong><span class="koboSpan" id="kobo.26.1"> or vehicles of software infections, despite their </span><strong><span class="koboSpan" id="kobo.27.1">non-executable</span></strong><span class="koboSpan" id="kobo.28.1"> file format. </span><span class="koboSpan" id="kobo.28.2">Moreover, the first stage of the spread of a malware (in </span><span><span class="koboSpan" id="kobo.29.1">both </span></span><span class="koboSpan" id="kobo.30.1">the cases of a home PC and a company LAN) often happens by compromising the integrity of the files residing within the machines being attacked.</span></p>
<p><span><span class="koboSpan" id="kobo.31.1">Therefore, i</span></span><span class="koboSpan" id="kobo.32.1">t is of fundamental importance to be able to effectively identify the presence of malicious software, in order to prevent, or at least limit, its dissemination within an organization.</span></p>
<p><span class="koboSpan" id="kobo.33.1">The following are the analysis strategies (and related tools) that are commonly used to conduct a preliminary survey of files and software disseminated </span><em><span class="koboSpan" id="kobo.34.1">in the wild</span></em><span class="koboSpan" id="kobo.35.1"> (via counterfeit links, spam emails, phishing, and others), in order to identify those that are potentially dangerous.</span></p>
<p><span class="koboSpan" id="kobo.36.1">To achieve this goal, we will have to examine the traditional methods of static and dynamic malware analysis more closely.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Artificial intelligence for malware detection</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">With the almost exponential increase in the number of threats associated with the daily spread of new malware, it is practically impossible to think of dealing with these threats effectively using only the analysis conducted by </span><strong><span class="koboSpan" id="kobo.3.1">human</span></strong><span class="koboSpan" id="kobo.4.1"> operators.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Therefore, it is necessary to introduce algorithms that allow us to at least automate the preparatory phase of malware analysis (known as triage, deriving from the same practice adopted by doctors during the First World War, and consists of selecting for treatment the wounded that are most likely to survive). </span><span class="koboSpan" id="kobo.5.2">That is to say, conducting a preliminary screening of the malware to be analyzed by the malware analyst allows them to respond in a timely and effective manner to real cyber threats.</span></p>
<p><span class="koboSpan" id="kobo.6.1">These algorithms actually take the form of the adoption of AI tools, given the dynamism that—by definition—characterizes cybersecurity. </span><span class="koboSpan" id="kobo.6.2">In fact, it is necessary that the machines can respond effectively, adapting themselves to the contextual changes related to the spread of unprecedented threats.</span></p>
<p><span class="koboSpan" id="kobo.7.1">This </span><span><span class="koboSpan" id="kobo.8.1">not only </span></span><span class="koboSpan" id="kobo.9.1">implies that the analyst manipulates the tools and methods of malware analysis (which is obvious), but that they can also interpret the behavior of the algorithms, being aware of the choices that the machine has adopted.</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.10.1">The malware analyst is, therefore, called to understand the logic followed by ML, intervening (directly or indirectly) in the </span><strong><span class="koboSpan" id="kobo.11.1">fine-tuning</span></strong><span class="koboSpan" id="kobo.12.1"> (refined adjustment) of the relevant learning procedures, based on the results obtained from the automated analysis.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Malware goes by many names</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There are many types of malware, and every day new forms of threat arise that creatively reutilize previous forms of attack, or adopt radically new compromising strategies that exploit specific characteristics of the target organization (in the case of </span><strong><span class="koboSpan" id="kobo.3.1">Advanced Persistent Threats</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><span><strong><span class="koboSpan" id="kobo.5.1">APTs</span></strong><span class="koboSpan" id="kobo.6.1">), these</span></span><span class="koboSpan" id="kobo.7.1"> are tailored forms of attack that perfectly adapt themselves to the target victim). </span><span class="koboSpan" id="kobo.7.2">This is only limited to the imagination of the attacker.</span></p>
<p><span class="koboSpan" id="kobo.8.1">However, it is possible to compile a classification of the most common types of malware, in order to understand which are the most effective measures of prevention, and contrast their effectiveness for dealing with each malware species:</span></p>
<ul>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.9.1">Trojans</span></strong><span><span class="koboSpan" id="kobo.10.1">: Executables that appear as legitimate</span></span> <span><span class="koboSpan" id="kobo.11.1">and harmless, but once they are launched, they execute malicious instructions in the background</span></span></li>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.12.1">Botnets</span></strong><span><span class="koboSpan" id="kobo.13.1">: Malware that has the goal of compromising as many possible hosts of a network, in order to put their computational capacity at the service of the attacker</span></span></li>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.14.1">Downloaders</span></strong><span><span class="koboSpan" id="kobo.15.1">: Malware that downloads malicious libraries or portions of code from the network and executes them on victim hosts</span></span></li>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.16.1">Rootkits</span></strong><span><span class="koboSpan" id="kobo.17.1">: Malware that compromises the hosts at the operating system level and, therefore, often come in the form of device drivers, making the various countermeasures (such as antiviruses installed on the endpoints) ineffective</span></span></li>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.18.1">Ransomwares</span></strong><span><span class="koboSpan" id="kobo.19.1">: Malware that proceeds to encrypt files stored inside the host machines, asking for a ransom from the victim (often to be paid in Bitcoin) to obtain the decryption key which is used for recovering the original files</span></span></li>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.20.1">APTs</span></strong><span><span class="koboSpan" id="kobo.21.1">:</span></span><span class="koboSpan" id="kobo.22.1"> APTs</span><span><span class="koboSpan" id="kobo.23.1"> are forms of tailored attacks that exploit specific vulnerabilities on the victimized hosts</span></span></li>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.24.1">Zero days (0 days)</span></strong><span><span class="koboSpan" id="kobo.25.1">:</span></span> <span><span class="koboSpan" id="kobo.26.1">Malware that exploits vulnerabilities not yet disclosed to the community of researchers and analysts, whose characteristics and impacts in terms of security are not yet known, and therefore go undetected by antivirus software</span></span></li>
</ul>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.27.1">Obviously, these different types of threats can be amplified by the fact that they can mix together in the same malicious file (for example, a seemingly harmless Trojan becomes a real threat, as it behaves like a downloader </span><span><span class="koboSpan" id="kobo.28.1">once executed</span></span><span class="koboSpan" id="kobo.29.1">, connecting to the network and downloading malicious software, such as rootkits, which compromises the local network and turns it into a botnet).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Malware analysis tools of the trade</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Many of the tools commonly used for conducting malware analysis can be categorized as follows:</span></p>
<ul>
<li class="mce-root"><span><span class="koboSpan" id="kobo.3.1">Disassemblers (such as Disasm and IDA)</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.4.1">Debuggers (such as OllyDbg, WinDbg, and IDA)</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.5.1">System monitors (such as Process Monitor and Process Explorer)</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.6.1">Network monitors (such as TCP View, Wireshark, and tcpdump)</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.7.1">Unpacking tools and Packer Identifiers (such as PEiD)</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.8.1">Binary and code analysis tools (such as PEView, PE Explorer, LordPE, and ImpREC)</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Malware detection strategies</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Obviously, every type of threat requires a specific detection strategy. </span><span class="koboSpan" id="kobo.2.2">In this section, we will see the </span><span><span class="koboSpan" id="kobo.3.1">analysis </span></span><span class="koboSpan" id="kobo.4.1">methods traditionally used in malware detection that are conducted manually by malware analysts. </span><span class="koboSpan" id="kobo.4.2">They provide a more detailed understanding of the phases of the analysis that can be improved and made more efficient by the introduction of AI algorithms, thus freeing the human analyst from the most repetitive or overwhelming tasks and allowing them to concentrate on the most peculiar or unusual aspects of the analysis.</span></p>
<p><span class="koboSpan" id="kobo.5.1">It should be emphasized that the development of malware software is the result of a creative activity carried out by the attacker, and as such is not easily ascribable to preestablished schemes or prefixed modalities. </span><span class="koboSpan" id="kobo.5.2">In the same way, the malware analyst must resort to all their imaginative resources, as well as developing unconventional procedures, in order to be able to stay in front of the attacker in a sort of </span><em><span class="koboSpan" id="kobo.6.1">cat and mouse game</span></em><span class="koboSpan" id="kobo.7.1">.</span></p>
<p><span class="koboSpan" id="kobo.8.1">Malware analysis should therefore be regarded more as an art than a science, and as such, it demands the analyst's ability to always imagine new ways of detection to identify future threats on time. </span><span class="koboSpan" id="kobo.8.2">C</span><span><span class="koboSpan" id="kobo.9.1">onsequently, t</span></span><span class="koboSpan" id="kobo.10.1">he malware analyst is called to continually update not only their technical skills, but also their investigation methods.</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.11.1">The fact remains that it is possible to start the detection activity by resorting to common practices of analysis, especially to detect the presence of known threats.</span></p>
<p><span class="koboSpan" id="kobo.12.1">To this end, among the most common malware detection activities, we can include the following malware detection activities:</span></p>
<ul>
<li class="mce-root"><span><strong><span class="koboSpan" id="kobo.13.1">Hashes file calculation</span></strong><span class="koboSpan" id="kobo.14.1">: To identify known threats already present in the knowledge base</span></span></li>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.15.1">System monitoring</span></strong><span class="koboSpan" id="kobo.16.1">: To identify anomalous behavior of both the hardware and the operating system (such as an unusual increase in CPU cycles, a particularly heavy disk writing activity, changes to the registry keys, and the creation of new and unsolicited processes in the system)</span></li>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.17.1">Network monitoring</span></strong><span class="koboSpan" id="kobo.18.1">: To identify anomalous connections established by host machines to remote destinations</span></li>
</ul>
<p><span class="koboSpan" id="kobo.19.1">These detection activities can be easily automated by using specific algorithms, as we will see shortly after having examined malware analysis methodologies.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Static malware analysis</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The first step in malware analysis begins with the evaluation of the presence of suspect artifacts in binary files, without actually running (executing) the code.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The complexity of techniques used in this phase goes under the name of </span><strong><span class="koboSpan" id="kobo.4.1">static malware analysis</span></strong><span class="koboSpan" id="kobo.5.1">.</span></p>
<p><span class="koboSpan" id="kobo.6.1">Static malware analysis consists of the following:</span></p>
<ul>
<li class="mce-root"><span><span class="koboSpan" id="kobo.7.1">Identifying the objectives considered of interest for the analysis</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.8.1">Understanding the flow of executable instructions</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.9.1">Identifying known patterns and associating them to possible malware (also known as </span><strong><span class="koboSpan" id="kobo.10.1">malware detection</span></strong><span class="koboSpan" id="kobo.11.1">)</span></li>
</ul>
<p><span class="koboSpan" id="kobo.12.1">To this end, analysis tools and procedures are used in order to perform the following functions:</span></p>
<ul>
<li class="mce-root"><span><span class="koboSpan" id="kobo.13.1">Identifying calls to system APIs</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.14.1">Decoding and manipulating string data for obtaining sensitive information (for example, domain names and IP addresses)</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.15.1">Detecting the presence and invocation by downloading other malware codes (for example, </span><strong><span class="koboSpan" id="kobo.16.1">Command and Control</span></strong><span class="koboSpan" id="kobo.17.1"> (</span><strong><span class="koboSpan" id="kobo.18.1">C2</span></strong><span class="koboSpan" id="kobo.19.1">), backdoors, and reverse shells)</span></li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Static analysis methodology</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The methodology used by static malware analysis consists of the examination of the machine instructions (assembly instructions) present in the disassembled binary image of the malware (malware disassembly), in order to identify its harmful potentialities and evaluate the external characteristics of the binary code, before proceeding with its execution.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Difficulties of static malware analysis</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Among the most insidious aspects of static malware analysis are the difficulties in determining the correctness of the malware disassembly. </span><span class="koboSpan" id="kobo.2.2">Given the increasingly widespread presence of anti-analysis techniques, it is not always possible to assume that the disassembled binary image produced by the disassembler is reliable. </span><span class="koboSpan" id="kobo.2.3">Therefore, the analyst must conduct a preliminary analysis, in order to detect, for example, the presence of packers that encrypt portions of executable code.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Such preliminary analysis procedures are often overlooked by analysts because they are expensive in terms of time required; nevertheless, they are indispensable for circumscribing relevant goals to be carried out.</span></p>
<p><span class="koboSpan" id="kobo.4.1">In addition, if the presence of portions of executable code is not correctly detected (perhaps because they are hidden within data that is considered </span><strong><span class="koboSpan" id="kobo.5.1">harmless</span></strong><span class="koboSpan" id="kobo.6.1">, such as resources representing images), this deficiency can undermine the subsequent phases of dynamic analysis, making it impossible to identify the exact type of malware being investigated.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to perform static analysis</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Once you have verified that the disassembled malware is reliable, it is possible to proceed in different ways: each analyst, in fact, follows their own preferred strategy, which is based on the experience and objectives they intend to pursue.</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.3.1">In principle, the adoptable strategies are as follows:</span></p>
<ul>
<li class="mce-root"><span><span class="koboSpan" id="kobo.4.1">Analyze the binary instructions in a systematic way, without executing them. </span><span class="koboSpan" id="kobo.4.2">It is an effective technique for limited portions of code that become complicated in cases of large malware, as the analyst must a keep trace of the status of the data for each instruction analyzed.</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.5.1">Scan the instructions to look for sequences that are considered to be of interest, setting breakpoints and partially executing the program up to the breakpoint, and then examining the status of the program at that point. </span><span class="koboSpan" id="kobo.5.2">This approach is often used to determine the presence of system calls deemed dangerous, based on the sequence in which these calls are invoked (for example, the sequence consisting of connecting to the network, creating a file, and modifying the system registry </span><span><span class="koboSpan" id="kobo.6.1">is one of the most common sequences of invocations of system APIs used by malware downloaders).</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.7.1">In the same way, it is possible to detect the absence of certain API calls. </span><span class="koboSpan" id="kobo.7.2">A code that does not present invocations to the system calls (for example, network-related calls), which is necessary for issuing network connections, cannot obviously represent a backdoor (but it could act, for example, as a keylogger, because it calls the sequence of system APIs to detect the keys pressed on the keyboard and write to disk).</span></li>
</ul>
<ul>
<li class="mce-root"><span class="koboSpan" id="kobo.8.1">Search for sensitive information (such as domain names and IP addresses) in a string format inside the disassembled image. </span><span class="koboSpan" id="kobo.8.2">Also, in this case, it is possible to set debugger breakpoints in correspondence with the network calls and detect any domain names or remote IP addresses that get contacted by the malware when connecting to the internet.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Hardware requirements for static analysis</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Unlike dynamic analysis, static analysis usually requires fewer specific resources in terms of hardware, since, in principle, the analyst does not execute the malicious code under analysis.</span></p>
<p><span class="koboSpan" id="kobo.3.1">As we will see, in the case of dynamic malware analysis, non-trivial hardware requirements may be required, and in some cases it is not enough to use virtual machines. </span><span class="koboSpan" id="kobo.3.2">This is due to the presence of countermeasures (anti-analysis tricks) implemented by the malware, which prevent the execution of the code if the presence of a virtual machine is detected.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Dynamic malware analysis</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As we have seen, the specific features of static malware analysis consist of the following:</span></p>
<ul>
<li><span><span class="koboSpan" id="kobo.3.1">Verify that a given binary file is actually malicious.</span></span></li>
<li class="mce-root"><span><span class="koboSpan" id="kobo.4.1">Identify as much information as possible about the binary file, without launching the execution and conducting the analysis on the basis of the characteristics that can be retracted, such as characteristics from the file format or from the resources stored in it.</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.5.1">Catalog the suspicious binary file by calculating its hash, which constitutes its signature (this signature can also be shared within the malware analysts community, in order to update the overall knowledge base of malware threats).</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.6.1">Without a doubt, static malware analysis, although rapid to conduct, presents a series of methodological limitations, especially when it comes to analyzing sophisticated types of malware (such as APT and polymorphic malware). </span><span class="koboSpan" id="kobo.6.2">One of the remedies to these methodological limits consists of combining it with dynamic malware analysis, in an attempt to understand the nature and type of malware being analyzed</span><span><span class="koboSpan" id="kobo.7.1"> in more depth</span></span><span class="koboSpan" id="kobo.8.1">.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.9.1">The distinctive character of the dynamic malware analysis is the fact that, unlike the static malware analysis, the binary file gets executed (often in isolated and protected environments, known as </span><strong><span class="koboSpan" id="kobo.10.1">malware analysis labs</span></strong><span class="koboSpan" id="kobo.11.1">, which make use of sandboxes and virtual machines to prevent the wide spread of malware in the corporate network).</span></p>
<p><span class="koboSpan" id="kobo.12.1">Therefore, this strategy entails analyzing the </span><strong><span class="koboSpan" id="kobo.13.1">dynamic</span></strong><span class="koboSpan" id="kobo.14.1"> behavior, that is, verifying, for example, that the malicious executable does not download malicious libraries or portions of code (payloads) from the internet, or proceeds to modify its own executable instructions at each execution, thus making the signature-based detection procedures (used by the antiviruses) ineffective.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Anti-analysis tricks</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The countermeasures usually adopted by malware developers, which prevent </span><span><span class="koboSpan" id="kobo.3.1">malware analysis </span></span><span class="koboSpan" id="kobo.4.1">or </span><span><span class="koboSpan" id="kobo.5.1">make it </span></span><span class="koboSpan" id="kobo.6.1">more difficult, rely on encryption of the payloads, the use of packers, of downloaders, and others.</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.7.1">These tricks are normally detectable with dynamic malware analysis; however, even dynamic malware analysis suffers from limitations related to the use of virtual machines—</span><span><span class="koboSpan" id="kobo.8.1">for example—</span></span><span class="koboSpan" id="kobo.9.1">whose presence can be easily detected by malware by exploiting some execution tricks, as follows:</span></p>
<ul>
<li class="mce-root"><span class="koboSpan" id="kobo.10.1">Execution of instructions that expect a default behavior: Th</span><span><span class="koboSpan" id="kobo.11.1">e malware can calculate the time that elapses in the execution of certain operations, and if these were performed more slowly than expected, it can deduce consequently that the execution takes place on a virtual machine.</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.12.1">Hardware-based virtual machine detection: Through the execution of some specific instructions at the hardware level (for example, the instructions that access CPU-protected registers, such as </span><kbd><span class="koboSpan" id="kobo.13.1">sldt</span></kbd><em><span class="koboSpan" id="kobo.14.1">,</span></em> <kbd><span class="koboSpan" id="kobo.15.1">sgdt</span></kbd><em><span class="koboSpan" id="kobo.16.1">,</span></em><span class="koboSpan" id="kobo.17.1"> and</span><em><span class="koboSpan" id="kobo.18.1"> </span></em><kbd><span class="koboSpan" id="kobo.19.1">sidt</span></kbd><span><span class="koboSpan" id="kobo.20.1">).</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.21.1">Accessing certain registry keys such as </span><kbd><span class="koboSpan" id="kobo.22.1">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Disk\Enum</span></kbd><span><span class="koboSpan" id="kobo.23.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.24.1">When the malware detects the presence of a virtual machine, it stops working in the expected way, evading attempts for it to be detected by analysts.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting malware samples</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In the course of our analysis, we will refer mainly to the malware codes developed for the Microsoft Windows platform, as we have a considerable amount of examples available, given the popularity of this platform.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Anyway, a question often asked is: where can we get malware samples from?</span></p>
<p><span class="koboSpan" id="kobo.4.1">There are several sources available online from which to download malware examples, include the following:</span></p>
<ul>
<li class="mce-root"><em><span class="koboSpan" id="kobo.5.1">MALWARE-TRAFFIC-ANALYSIS.NET</span></em><span><span class="koboSpan" id="kobo.6.1">:</span></span> <a href="https://www.malware-traffic-analysis.net/"><span class="koboSpan" id="kobo.7.1">https://www.malware-traffic-analysis.net/</span></a></li>
<li style="color: black"><em><span class="koboSpan" id="kobo.8.1">VIRUSTOTAL</span></em><span class="koboSpan" id="kobo.9.1">: </span><a href="https://www.virustotal.com"><span class="koboSpan" id="kobo.10.1">https://www.virustotal.com</span></a></li>
<li class="mce-root"><em><span class="koboSpan" id="kobo.11.1">VirusShare</span></em><span><span class="koboSpan" id="kobo.12.1">:</span></span> <a href="https://virusshare.com"><span class="koboSpan" id="kobo.13.1">https://virusshare.com</span></a></li>
<li><em><span class="koboSpan" id="kobo.14.1">theZoo</span></em><span class="koboSpan" id="kobo.15.1">: </span><a href="https://github.com/ytisf/theZoo"><span class="koboSpan" id="kobo.16.1">https://github.com/ytisf/theZoo</span></a><span class="koboSpan" id="kobo.17.1"> (defined by the authors as </span><em><span class="koboSpan" id="kobo.18.1">a </span><span class="text-gray-dark mr-2"><span class="koboSpan" id="kobo.19.1">repository of live malware for your own joy and pleasure</span></span></em><span class="koboSpan" id="kobo.20.1">)</span></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1">It is also possible to create your own sample datasets, by acquiring malware samples in the wild through the configuration of a honeypot (or even simply collecting the spam messages received in your own email accounts).</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.22.1">Once we have our malware dataset, it will be necessary to proceed to the preliminary analysis of their characteristics, taking advantage of the scripts that automate the activities of malware analysis.</span></p>
<p><span class="koboSpan" id="kobo.23.1">As we anticipated, in our analysis, we will focus on malware codes developed for the Microsoft Windows platform. </span><span class="koboSpan" id="kobo.23.2">To proceed further in our analysis, we need to understand the executable file format adopted by this platform, which is known as the </span><strong><span class="koboSpan" id="kobo.24.1">Portable Executable</span></strong><span class="koboSpan" id="kobo.25.1"> (</span><strong><span class="koboSpan" id="kobo.26.1">PE</span></strong><span class="koboSpan" id="kobo.27.1">) file format.</span></p>
<p><span class="koboSpan" id="kobo.28.1">Every executable file of the Microsoft platform, whether it is a file with the </span><kbd><span class="koboSpan" id="kobo.29.1">.exe</span></kbd><span class="koboSpan" id="kobo.30.1">, </span><kbd><span class="koboSpan" id="kobo.31.1">.dll</span></kbd><span class="koboSpan" id="kobo.32.1">, or </span><kbd><span class="koboSpan" id="kobo.33.1">.sys</span></kbd> <span><span class="koboSpan" id="kobo.34.1">extension </span></span><span class="koboSpan" id="kobo.35.1">(in the case of device drives), in order to be loaded into runtime memory and then executed by the Windows OS, must comply with the </span><span><span class="koboSpan" id="kobo.36.1">necessary </span></span><span class="koboSpan" id="kobo.37.1">specification contained in the PE file format.</span></p>
<p><span class="koboSpan" id="kobo.38.1">We will examine this file format shortly, illustrating how to extract </span><span><span class="koboSpan" id="kobo.39.1">the features stored in the PE file format </span></span><span class="koboSpan" id="kobo.40.1">from the executable files, in order to create a dataset of </span><strong><span class="koboSpan" id="kobo.41.1">artifacts</span></strong><span class="koboSpan" id="kobo.42.1"> that will be used to train our AI algorithms.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Hacking the PE file format</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In our analysis of the PE file format, we will make use of </span><strong><span class="koboSpan" id="kobo.3.1">PEView</span></strong><span class="koboSpan" id="kobo.4.1"> (available online at </span><a href="http://wjradburn.com/software/PEview.zip"><span class="koboSpan" id="kobo.5.1">http://wjradburn.com/software/PEview.zip</span></a><span class="koboSpan" id="kobo.6.1">), which is a very simple but effective tool for visualizing </span><strong><span class="koboSpan" id="kobo.7.1">PE structures</span></strong><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">As we said, PE is the standard file format of binary images that get executed on a Windows OS.</span></p>
<p><span class="koboSpan" id="kobo.9.1">In fact, when the </span><strong><span class="koboSpan" id="kobo.10.1">Windows OS loader</span></strong><span class="koboSpan" id="kobo.11.1"> loads executables (not limited to </span><kbd><span class="koboSpan" id="kobo.12.1">.exe</span></kbd><span class="koboSpan" id="kobo.13.1">, but also including </span><kbd><span class="koboSpan" id="kobo.14.1">.dll</span></kbd><span class="koboSpan" id="kobo.15.1"> and </span><kbd><span class="koboSpan" id="kobo.16.1">.sys</span></kbd><span class="koboSpan" id="kobo.17.1">) in runtime memory, it executes the loading directives found in the </span><strong><span class="koboSpan" id="kobo.18.1">PE sections</span></strong><span class="koboSpan" id="kobo.19.1"> for the binary image to be loaded.</span></p>
<p><span class="koboSpan" id="kobo.20.1">As such, PE file format artifacts remain one of the </span><strong><span class="koboSpan" id="kobo.21.1">main targets</span></strong><span class="koboSpan" id="kobo.22.1"> for malware developers and virus writers.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The PE file format as a potential vector of infection</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As we will see, PE executables have multiple sections included in the binary file image, and this characteristic can be exploited to hide malicious software.</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.3.1">In fact, each of the PE sections can be thought of as a folder, hosting various binary objects (ranging from graphics files to encrypted libraries), that gets executed and/or decrypted at runtime, potentially infecting other executables on the same machine or remote machines on the network.</span></p>
<p><span class="koboSpan" id="kobo.4.1">For instance, a PE section may contain a </span><kbd><span class="koboSpan" id="kobo.5.1">.sys</span></kbd><span class="koboSpan" id="kobo.6.1"> (malicious driver) file that is aimed at compromising the kernel, along with a startup file containing configuration parameters, or remote links the binary can connect to, in order to download other activation artifacts, C2 backdoors, and others.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Overview of the PE file format</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">PE specification is derived from the Unix </span><strong><span class="koboSpan" id="kobo.3.1">Common Object File Format</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span><span class="koboSpan" id="kobo.5.1">COFF</span></span></strong><span class="koboSpan" id="kobo.6.1">) and it is basically a </span><strong><span class="koboSpan" id="kobo.7.1">data structure</span></strong><span class="koboSpan" id="kobo.8.1"> that covers the information necessary for the Windows </span><strong><span class="koboSpan" id="kobo.9.1">OS loader</span></strong><span class="koboSpan" id="kobo.10.1"> to manage the executable image, that is, when its structures get mapped into runtime memory before getting executed by the OS.</span></p>
<p><span class="koboSpan" id="kobo.11.1">Simply put, a PE file consists of a </span><strong><span class="koboSpan" id="kobo.12.1">PE file header</span></strong><span class="koboSpan" id="kobo.13.1"> and a </span><strong><span class="koboSpan" id="kobo.14.1">section table</span></strong><span class="koboSpan" id="kobo.15.1"> (section headers), followed by the </span><strong><span class="koboSpan" id="kobo.16.1">sections' data</span></strong><span class="koboSpan" id="kobo.17.1">.</span></p>
<p><span class="koboSpan" id="kobo.18.1">The </span><strong><span class="koboSpan" id="kobo.19.1">PE file header</span></strong><span class="koboSpan" id="kobo.20.1"> is encapsulated in the Windows </span><strong><span class="koboSpan" id="kobo.21.1">NT header</span></strong><span class="koboSpan" id="kobo.22.1"> structure (defined in the </span><kbd><span class="koboSpan" id="kobo.23.1">winnt.h</span></kbd><span class="koboSpan" id="kobo.24.1"> header file, along with other C structures) and is composed of the following:</span></p>
<ul>
<li class="mce-root"><span><span class="koboSpan" id="kobo.25.1">MS DOS header</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.26.1">The PE signature</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.27.1">The image file header</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.28.1">An optional header</span></li>
</ul>
<p><span class="koboSpan" id="kobo.29.1">The </span><strong><span class="koboSpan" id="kobo.30.1">file headers</span></strong><span class="koboSpan" id="kobo.31.1"> are followed by </span><strong><span class="koboSpan" id="kobo.32.1">section headers</span></strong><span class="koboSpan" id="kobo.33.1">:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.34.1"><img src="assets/791469ac-0935-42cf-bbdf-8b74aa71845b.png" style="width:9.00em;height:24.42em;"/></span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.35.1">Image credits: https://commons.wikimedia.org/wiki/File:RevEngPEFile.JPG</span></div>
<p><span class="koboSpan" id="kobo.36.1">The </span><strong><span class="koboSpan" id="kobo.37.1">section header</span></strong><span class="koboSpan" id="kobo.38.1"> provides information about its associated section, including location, length, and characteristics. </span><span class="koboSpan" id="kobo.38.2">A section is the basic unit of code or data within a PE file.</span></p>
<p><span class="koboSpan" id="kobo.39.1">Different functional areas, such as code and data areas, are logically separated into sections.</span></p>
<p><span class="koboSpan" id="kobo.40.1">In addition, an image file can contain a number of sections, such as </span><kbd><span class="koboSpan" id="kobo.41.1">.tls</span></kbd><span class="koboSpan" id="kobo.42.1"> and </span><kbd><span class="koboSpan" id="kobo.43.1">.reloc</span></kbd><span class="koboSpan" id="kobo.44.1">, which have special purposes.</span></p>
<p><span class="koboSpan" id="kobo.45.1">The section header provides information about its associated section. </span><span class="koboSpan" id="kobo.45.2">The most common sections in executables are text, data, RSRC, RData, and RELOC.</span></p>
<p><span class="koboSpan" id="kobo.46.1">Most Windows executables contain resources: a general term that refers to objects such as cursors, icons, bitmaps, menus, and fonts. </span><span class="koboSpan" id="kobo.46.2">A PE file can contain a resource directory for all of the resources that the program code in that file uses.</span></p>
<p><span class="koboSpan" id="kobo.47.1">Malware rarely uses graphical resources, so the total number of their resources is relatively fewer than that of benign software.</span></p>
<p><span class="koboSpan" id="kobo.48.1">Many fields of PE file have no mandatory constraint. </span><span class="koboSpan" id="kobo.48.2">There are a number of redundant fields and spaces in PE files that could create opportunities for malware hiding.</span></p>
<p><span class="koboSpan" id="kobo.49.1">In the following screenshot, we execute PEView and load its </span><kbd><span class="koboSpan" id="kobo.50.1">.exe</span></kbd><span class="koboSpan" id="kobo.51.1"> image into memory; the </span><span class="packt_screen"><span class="koboSpan" id="kobo.52.1">Tools</span></span><span class="koboSpan" id="kobo.53.1"> section shows the various sections of its PE format.</span></p>
<p><span class="koboSpan" id="kobo.54.1">We have also outlined the special </span><kbd><span class="koboSpan" id="kobo.55.1">e_magic</span></kbd><span class="koboSpan" id="kobo.56.1"> </span><span><span class="koboSpan" id="kobo.57.1">field </span></span><span class="koboSpan" id="kobo.58.1">of the DOS header, which usually contains the MZ character sequence (corresponding to the byte sequence </span><kbd><span class="koboSpan" id="kobo.59.1">"0x4D 0x5A"</span></kbd><span class="koboSpan" id="kobo.60.1">), and the special </span><kbd><span class="koboSpan" id="kobo.61.1">Signature</span></kbd><span class="koboSpan" id="kobo.62.1"> </span><span><span class="koboSpan" id="kobo.63.1">field </span></span><span class="koboSpan" id="kobo.64.1">of the PE header (defined as the </span><kbd><span class="koboSpan" id="kobo.65.1">IMAGE_NT_HEADERS</span></kbd><span class="koboSpan" id="kobo.66.1"> structure), which contains the </span><strong><span class="koboSpan" id="kobo.67.1">PE</span></strong><span class="koboSpan" id="kobo.68.1"> character sequence, and states that that the binary file is a native Windows executable:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.69.1"><img class="aligncenter size-full wp-image-636 image-border" src="assets/1f23d73c-333e-4b11-ba01-1a0d52b93cd0.png" style="width:78.92em;height:55.92em;"/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The DOS header and DOS stub</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The DOS header is only used for backward compatibility, and precedes the DOS stub that displays an error message stating that the program might not run in DOS mode.</span></p>
<p><span class="koboSpan" id="kobo.3.1">As per the official PE documentation (available at </span><a href="https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#ms-dos-stub-image-only"><span class="koboSpan" id="kobo.4.1">https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#ms-dos-stub-image-only</span></a><span class="koboSpan" id="kobo.5.1">), the MS-DOS stub enables Windows to properly execute the image file, even though it has an MS-DOS stub.</span></p>
<p><span class="koboSpan" id="kobo.6.1">It is placed at the front of the </span><kbd><span class="koboSpan" id="kobo.7.1">EXE</span></kbd><span class="koboSpan" id="kobo.8.1"> image and prints out the message, </span><kbd><span class="koboSpan" id="kobo.9.1">This program cannot be run in DOS mode</span></kbd><span class="koboSpan" id="kobo.10.1">, when the image is run in MS-DOS.</span></p>
<p><span class="koboSpan" id="kobo.11.1">The DOS header includes some fields for backward compatibility, and is defined as follows:</span></p>
<pre><span class="koboSpan" id="kobo.12.1">typedef struct _IMAGE_DOS_HEADER {      </span><br/><span class="regexp"><span class="koboSpan" id="kobo.13.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.14.1">DOS</span></span><span class="koboSpan" id="kobo.15.1"> .</span><span class="constant"><span class="koboSpan" id="kobo.16.1">EXE</span></span><span class="koboSpan" id="kobo.17.1"> header</span><br/>    <span class="constant"><span class="koboSpan" id="kobo.18.1">WORD</span></span><span class="koboSpan" id="kobo.19.1">   e_magic;                     </span><br/><span class="regexp"><span class="koboSpan" id="kobo.20.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.21.1">Magic</span></span><span class="koboSpan" id="kobo.22.1"> number</span><br/>    <span class="constant"><span class="koboSpan" id="kobo.23.1">WORD</span></span><span class="koboSpan" id="kobo.24.1">   e_cblp;                      </span><br/><span class="regexp"><span class="koboSpan" id="kobo.25.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.26.1">Bytes</span></span><span class="koboSpan" id="kobo.27.1"> on last page of file</span><br/>    <span class="constant"><span class="koboSpan" id="kobo.28.1">WORD</span></span><span class="koboSpan" id="kobo.29.1">   e_cp;                        </span><br/><span class="regexp"><span class="koboSpan" id="kobo.30.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.31.1">Pages</span></span> <span class="keyword"><span class="koboSpan" id="kobo.32.1">in</span></span><span class="koboSpan" id="kobo.33.1"> file</span><br/>    <span class="constant"><span class="koboSpan" id="kobo.34.1">WORD</span></span><span class="koboSpan" id="kobo.35.1">   e_crlc;                      </span><br/><span class="regexp"><span class="koboSpan" id="kobo.36.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.37.1">Relocations</span><br/></span>    <span class="constant"><span class="koboSpan" id="kobo.38.1">WORD</span></span><span class="koboSpan" id="kobo.39.1">   e_cparhdr;                   </span><br/><span class="regexp"><span class="koboSpan" id="kobo.40.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.41.1">Size</span></span><span class="koboSpan" id="kobo.42.1"> of header </span><span class="keyword"><span class="koboSpan" id="kobo.43.1">in</span></span><span class="koboSpan" id="kobo.44.1"> paragraphs</span><br/>    <span class="constant"><span class="koboSpan" id="kobo.45.1">WORD</span></span><span class="koboSpan" id="kobo.46.1">   e_minalloc;                  </span><br/><span class="regexp"><span class="koboSpan" id="kobo.47.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.48.1">Minimum</span></span><span class="koboSpan" id="kobo.49.1"> extra paragraphs needed</span><br/>    <span class="constant"><span class="koboSpan" id="kobo.50.1">WORD</span></span><span class="koboSpan" id="kobo.51.1">   e_maxalloc;                  </span><br/><span class="regexp"><span class="koboSpan" id="kobo.52.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.53.1">Maximum</span></span><span class="koboSpan" id="kobo.54.1"> extra paragraphs needed</span><br/>    <span class="constant"><span class="koboSpan" id="kobo.55.1">WORD</span></span><span class="koboSpan" id="kobo.56.1">   e_ss;                        </span><br/><span class="regexp"><span class="koboSpan" id="kobo.57.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.58.1">Initial</span></span><span class="koboSpan" id="kobo.59.1"> (relative) </span><span class="constant"><span class="koboSpan" id="kobo.60.1">SS</span></span><span class="koboSpan" id="kobo.61.1"> value</span><br/>    <span class="constant"><span class="koboSpan" id="kobo.62.1">WORD</span></span><span class="koboSpan" id="kobo.63.1">   e_sp;                        </span><br/><span class="regexp"><span class="koboSpan" id="kobo.64.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.65.1">Initial</span></span> <span class="constant"><span class="koboSpan" id="kobo.66.1">SP</span></span><span class="koboSpan" id="kobo.67.1"> value</span><br/>    <span class="constant"><span class="koboSpan" id="kobo.68.1">WORD</span></span><span class="koboSpan" id="kobo.69.1">   e_csum;                      </span><br/><span class="regexp"><span class="koboSpan" id="kobo.70.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.71.1">Checksum</span><br/></span>    <span class="constant"><span class="koboSpan" id="kobo.72.1">WORD</span></span><span class="koboSpan" id="kobo.73.1">   e_ip;                        </span><br/><span class="regexp"><span class="koboSpan" id="kobo.74.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.75.1">Initial</span></span> <span class="constant"><span class="koboSpan" id="kobo.76.1">IP</span></span><span class="koboSpan" id="kobo.77.1"> value</span><br/>    <span class="constant"><span class="koboSpan" id="kobo.78.1">WORD</span></span><span class="koboSpan" id="kobo.79.1">   e_cs;                        </span><br/><span class="regexp"><span class="koboSpan" id="kobo.80.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.81.1">Initial</span></span><span class="koboSpan" id="kobo.82.1"> (relative) </span><span class="constant"><span class="koboSpan" id="kobo.83.1">CS</span></span><span class="koboSpan" id="kobo.84.1"> value</span><br/>    <span class="constant"><span class="koboSpan" id="kobo.85.1">WORD</span></span><span class="koboSpan" id="kobo.86.1">   e_lfarlc;                    </span><br/><span class="regexp"><span class="koboSpan" id="kobo.87.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.88.1">File</span></span><span class="koboSpan" id="kobo.89.1"> address of relocation table</span><br/>    <span class="constant"><span class="koboSpan" id="kobo.90.1">WORD</span></span><span class="koboSpan" id="kobo.91.1">   e_ovno;                      </span><br/><span class="regexp"><span class="koboSpan" id="kobo.92.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.93.1">Overlay</span></span><span class="koboSpan" id="kobo.94.1"> number</span><br/>    <span class="constant"><span class="koboSpan" id="kobo.95.1">WORD</span></span><span class="koboSpan" id="kobo.96.1">   e_res[</span><span class="number"><span class="koboSpan" id="kobo.97.1">4</span></span><span class="koboSpan" id="kobo.98.1">];                    </span><br/><span class="regexp"><span class="koboSpan" id="kobo.99.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.100.1">Reserved</span></span><span class="koboSpan" id="kobo.101.1"> words</span><br/>    <span class="constant"><span class="koboSpan" id="kobo.102.1">WORD</span></span><span class="koboSpan" id="kobo.103.1">   e_oemid;                     </span><br/><span class="regexp"><span class="koboSpan" id="kobo.104.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.105.1">OEM</span></span><span class="koboSpan" id="kobo.106.1"> identifier (</span><span class="keyword"><span class="koboSpan" id="kobo.107.1">for</span></span><span class="koboSpan" id="kobo.108.1"> e_oeminfo)</span><br/>    <span class="constant"><span class="koboSpan" id="kobo.109.1">WORD</span></span><span class="koboSpan" id="kobo.110.1">   e_oeminfo;                   </span><br/><span class="regexp"><span class="koboSpan" id="kobo.111.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.112.1">OEM</span></span><span class="koboSpan" id="kobo.113.1"> information; e_oemid specific</span><br/>    <span class="constant"><span class="koboSpan" id="kobo.114.1">WORD</span></span><span class="koboSpan" id="kobo.115.1">   e_res2[</span><span class="number"><span class="koboSpan" id="kobo.116.1">10</span></span><span class="koboSpan" id="kobo.117.1">];                  </span><br/><span class="regexp"><span class="koboSpan" id="kobo.118.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.119.1">Reserved</span></span><span class="koboSpan" id="kobo.120.1"> words</span><br/>    <span class="constant"><span class="koboSpan" id="kobo.121.1">LONG</span></span><span class="koboSpan" id="kobo.122.1">   e_lfanew;                    </span><br/><span class="regexp"><span class="koboSpan" id="kobo.123.1">//</span></span> <span class="constant"><span class="koboSpan" id="kobo.124.1">File</span></span><span class="koboSpan" id="kobo.125.1"> address of new exe header</span><br/><span class="koboSpan" id="kobo.126.1">  } </span><span class="constant"><span class="koboSpan" id="kobo.127.1">IMAGE_DOS_HEADER</span></span><span class="koboSpan" id="kobo.128.1">, *</span><span class="constant"><span class="koboSpan" id="kobo.129.1">PIMAGE_DOS_HEADER</span></span><span class="koboSpan" id="kobo.130.1">;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The PE header structure</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">After the DOS header and DOS stub, we find the PE header.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The PE header contains information about different sections used to store code and data, along with the requested imports from other libraries (DLLs) or the exports provided, in case the module is actually a library. </span><span class="koboSpan" id="kobo.3.2">Take a look at the following structure of the PE header:</span></p>
<pre><span class="koboSpan" id="kobo.4.1">typedef struct _IMAGE_NT_HEADERS {</span><br/><span class="koboSpan" id="kobo.5.1">    DWORD Signature</span><span class="comment"><span class="koboSpan" id="kobo.6.1">;</span><br/></span><span class="koboSpan" id="kobo.7.1">    IMAGE_FILE_HEADER FileHeader</span><span class="comment"><span class="koboSpan" id="kobo.8.1">;</span><br/></span><span class="koboSpan" id="kobo.9.1">    IMAGE_OPTIONAL_HEADER32 OptionalHeader</span><span class="comment"><span class="koboSpan" id="kobo.10.1">;</span><br/></span><span class="koboSpan" id="kobo.11.1">} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32</span><span class="comment"><span class="koboSpan" id="kobo.12.1">;</span></span></pre>
<p><span class="koboSpan" id="kobo.13.1">The </span><kbd><span class="koboSpan" id="kobo.14.1">FileHeader</span></kbd><span class="koboSpan" id="kobo.15.1"> structure field describes the format of the file (that is, contents, symbols, and more), and its type is defined in the following structure:</span></p>
<pre><span class="koboSpan" id="kobo.16.1">typedef struct _IMAGE_FILE_HEADER {</span><br/><span class="koboSpan" id="kobo.17.1">    WORD    Machine</span><span class="comment"><span class="koboSpan" id="kobo.18.1">;</span><br/></span><span class="koboSpan" id="kobo.19.1">    WORD    NumberOfSections</span><span class="comment"><span class="koboSpan" id="kobo.20.1">;</span><br/></span><span class="koboSpan" id="kobo.21.1">    DWORD   TimeDateStamp</span><span class="comment"><span class="koboSpan" id="kobo.22.1">;</span><br/></span><span class="koboSpan" id="kobo.23.1">    DWORD   PointerToSymbolTable</span><span class="comment"><span class="koboSpan" id="kobo.24.1">;</span><br/></span><span class="koboSpan" id="kobo.25.1">    DWORD   NumberOfSymbols</span><span class="comment"><span class="koboSpan" id="kobo.26.1">;</span><br/></span><span class="koboSpan" id="kobo.27.1">    WORD    SizeOfOptionalHeader</span><span class="comment"><span class="koboSpan" id="kobo.28.1">;</span><br/></span><span class="koboSpan" id="kobo.29.1">    WORD    Characteristics</span><span class="comment"><span class="koboSpan" id="kobo.30.1">;</span><br/></span><span class="koboSpan" id="kobo.31.1">} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER</span><span class="comment"><span class="koboSpan" id="kobo.32.1">;</span></span></pre>
<p><span class="koboSpan" id="kobo.33.1">The </span><kbd><span class="koboSpan" id="kobo.34.1">OptionalHeader</span></kbd><span class="koboSpan" id="kobo.35.1"> field contains information about the executable module, including the required OS version, memory requirements, and the </span><kbd><span class="koboSpan" id="kobo.36.1">itsentry</span></kbd><span class="koboSpan" id="kobo.37.1"> point (that is, the relative memory address where the actual execution starts from):</span></p>
<pre><span class="koboSpan" id="kobo.38.1">typedef struct _IMAGE_OPTIONAL_HEADER {</span><br/><span class="koboSpan" id="kobo.39.1">    //</span><br/><span class="koboSpan" id="kobo.40.1">    // Standard fields.</span><br/><span class="koboSpan" id="kobo.41.1">    //</span><br/><br/><span class="koboSpan" id="kobo.42.1">    WORD    Magic</span><span class="comment"><span class="koboSpan" id="kobo.43.1">;</span><br/></span><span class="koboSpan" id="kobo.44.1">    BYTE    MajorLinkerVersion</span><span class="comment"><span class="koboSpan" id="kobo.45.1">;</span><br/></span><span class="koboSpan" id="kobo.46.1">    BYTE    MinorLinkerVersion</span><span class="comment"><span class="koboSpan" id="kobo.47.1">;</span><br/></span><span class="koboSpan" id="kobo.48.1">    DWORD   SizeOfCode</span><span class="comment"><span class="koboSpan" id="kobo.49.1">;</span><br/></span><span class="koboSpan" id="kobo.50.1">    DWORD   SizeOfInitializedData</span><span class="comment"><span class="koboSpan" id="kobo.51.1">;</span><br/></span><span class="koboSpan" id="kobo.52.1">    DWORD   SizeOfUninitializedData</span><span class="comment"><span class="koboSpan" id="kobo.53.1">;</span><br/></span><span class="koboSpan" id="kobo.54.1">    DWORD   AddressOfEntryPoint</span><span class="comment"><span class="koboSpan" id="kobo.55.1">;</span><br/></span><span class="koboSpan" id="kobo.56.1">    DWORD   BaseOfCode</span><span class="comment"><span class="koboSpan" id="kobo.57.1">;</span><br/></span><span class="koboSpan" id="kobo.58.1">    DWORD   BaseOfData</span><span class="comment"><span class="koboSpan" id="kobo.59.1">;</span><br/></span><br/><span class="koboSpan" id="kobo.60.1">    //</span><br/><span class="koboSpan" id="kobo.61.1">    // NT additional fields.</span><br/><span class="koboSpan" id="kobo.62.1">    //
</span><br/><span class="koboSpan" id="kobo.63.1">    DWORD   ImageBase</span><span class="comment"><span class="koboSpan" id="kobo.64.1">;</span><br/></span><span class="koboSpan" id="kobo.65.1">    DWORD   SectionAlignment</span><span class="comment"><span class="koboSpan" id="kobo.66.1">;</span><br/></span><span class="koboSpan" id="kobo.67.1">    DWORD   FileAlignment</span><span class="comment"><span class="koboSpan" id="kobo.68.1">;</span><br/></span><span class="koboSpan" id="kobo.69.1">    WORD    MajorOperatingSystemVersion</span><span class="comment"><span class="koboSpan" id="kobo.70.1">;</span><br/></span><span class="koboSpan" id="kobo.71.1">    WORD    MinorOperatingSystemVersion</span><span class="comment"><span class="koboSpan" id="kobo.72.1">;</span><br/></span><span class="koboSpan" id="kobo.73.1">    WORD    MajorImageVersion</span><span class="comment"><span class="koboSpan" id="kobo.74.1">;</span><br/></span><span class="koboSpan" id="kobo.75.1">    WORD    MinorImageVersion</span><span class="comment"><span class="koboSpan" id="kobo.76.1">;</span><br/></span><span class="koboSpan" id="kobo.77.1">    WORD    MajorSubsystemVersion</span><span class="comment"><span class="koboSpan" id="kobo.78.1">;</span><br/></span><span class="koboSpan" id="kobo.79.1">    WORD    MinorSubsystemVersion</span><span class="comment"><span class="koboSpan" id="kobo.80.1">;</span><br/></span><span class="koboSpan" id="kobo.81.1">    DWORD   Win32VersionValue</span><span class="comment"><span class="koboSpan" id="kobo.82.1">;</span><br/></span><span class="koboSpan" id="kobo.83.1">    DWORD   SizeOfImage</span><span class="comment"><span class="koboSpan" id="kobo.84.1">;</span><br/></span><span class="koboSpan" id="kobo.85.1">    DWORD   SizeOfHeaders</span><span class="comment"><span class="koboSpan" id="kobo.86.1">;</span><br/></span><span class="koboSpan" id="kobo.87.1">    DWORD   CheckSum</span><span class="comment"><span class="koboSpan" id="kobo.88.1">;</span><br/></span><span class="koboSpan" id="kobo.89.1">    WORD    Subsystem</span><span class="comment"><span class="koboSpan" id="kobo.90.1">;</span><br/></span><span class="koboSpan" id="kobo.91.1">    WORD    DllCharacteristics</span><span class="comment"><span class="koboSpan" id="kobo.92.1">;</span><br/></span><span class="koboSpan" id="kobo.93.1">    DWORD   SizeOfStackReserve</span><span class="comment"><span class="koboSpan" id="kobo.94.1">;</span><br/></span><span class="koboSpan" id="kobo.95.1">    DWORD   SizeOfStackCommit</span><span class="comment"><span class="koboSpan" id="kobo.96.1">;</span><br/></span><span class="koboSpan" id="kobo.97.1">    DWORD   SizeOfHeapReserve</span><span class="comment"><span class="koboSpan" id="kobo.98.1">;</span><br/></span><span class="koboSpan" id="kobo.99.1">    DWORD   SizeOfHeapCommit</span><span class="comment"><span class="koboSpan" id="kobo.100.1">;</span><br/></span><span class="koboSpan" id="kobo.101.1">    DWORD   LoaderFlags</span><span class="comment"><span class="koboSpan" id="kobo.102.1">;</span><br/></span><span class="koboSpan" id="kobo.103.1">    DWORD   NumberOfRvaAndSizes</span><span class="comment"><span class="koboSpan" id="kobo.104.1">;</span><br/></span><span class="koboSpan" id="kobo.105.1">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]</span><span class="comment"><span class="koboSpan" id="kobo.106.1">;</span><br/></span><span class="koboSpan" id="kobo.107.1">} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32</span><span class="comment"><span class="koboSpan" id="kobo.108.1">;</span></span></pre>
<p><span class="koboSpan" id="kobo.109.1">The special </span><kbd><span class="koboSpan" id="kobo.110.1">AddressOfEntryPoint</span></kbd><span class="koboSpan" id="kobo.111.1"> </span><span><span class="koboSpan" id="kobo.112.1">field </span></span><span class="koboSpan" id="kobo.113.1">included in </span><kbd><span class="koboSpan" id="kobo.114.1">OptionalHeader</span></kbd><span class="koboSpan" id="kobo.115.1"> states the executable entry point, which is usually set at the relative memory address of </span><kbd><span class="koboSpan" id="kobo.116.1">0x1000</span></kbd><span class="koboSpan" id="kobo.117.1">, as we can see outlined in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.118.1"><img src="assets/d337fac7-7e73-4713-9f78-d871b7a008d6.png" style="width:81.92em;height:61.42em;"/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The data directory</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">DataDirectory</span></kbd><span class="koboSpan" id="kobo.4.1"> structure field contains </span><kbd><span class="koboSpan" id="kobo.5.1">IMAGE_NUMBEROF_DIRECTORY_ENTRIES</span></kbd><span class="koboSpan" id="kobo.6.1"> entries that define the logical components of the module. </span><span class="koboSpan" id="kobo.6.2">The relative entries are numbered and defined as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.7.1"><img src="assets/0348d00d-a9ec-4d0f-a320-2cba59b8e3ed.png" style="width:25.50em;height:28.33em;"/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Import and export tables</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The import table lists all of the symbols that need to be resolved and imported at load time from other DLLs:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img src="assets/3821aa0d-c2c5-4234-8752-0f224f4175eb.png" style="width:48.25em;height:36.17em;"/></span></p>
<p class="mce-root"/>
<p><span><span class="koboSpan" id="kobo.4.1">Most types of benign software have a large number of entries in the import address table, because they have complex functions and import different Windows API functions from the import address table:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.5.1"><img src="assets/a6edc288-6116-4010-ae2c-a480ee3e42f8.png" style="width:43.25em;height:32.42em;"/></span></p>
<p><span class="koboSpan" id="kobo.6.1">Windows also allows programs to load and unload DLLs explicitly using </span><kbd><span class="koboSpan" id="kobo.7.1">LoadLibrary</span></kbd><span class="koboSpan" id="kobo.8.1"> and </span><kbd><span class="koboSpan" id="kobo.9.1">FreeLibrary</span></kbd><span class="koboSpan" id="kobo.10.1">, as well as to find the addresses of symbols using </span><kbd><span class="koboSpan" id="kobo.11.1">GetProcAddress</span></kbd><span class="koboSpan" id="kobo.12.1"> (exposed by </span><kbd><span class="koboSpan" id="kobo.13.1">kernel32.dll</span></kbd><span class="koboSpan" id="kobo.14.1">).</span></p>
<p><span class="koboSpan" id="kobo.15.1">Most types of malware use the latter approach, so that the number of symbols in their imports table is relatively fewer than that of benign software.</span></p>
<p><span class="koboSpan" id="kobo.16.1">The exports table contains information about symbols that other PE files can access through dynamic linking. </span><span class="koboSpan" id="kobo.16.2">Exported symbols are generally found in DLL files and most types of malware do not have exported symbols.</span></p>
<p><span class="koboSpan" id="kobo.17.1">Most types of malware load and unload DLLs explicitly using </span><kbd><span class="koboSpan" id="kobo.18.1">LoadLibrary</span></kbd><span class="koboSpan" id="kobo.19.1"> and </span><kbd><span class="koboSpan" id="kobo.20.1">FreeLibrary</span></kbd><span class="koboSpan" id="kobo.21.1"> in order to hide their malicious purposes.</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.22.1">However, there is one notable exception: malware usually imports </span><kbd><span class="koboSpan" id="kobo.23.1">wsock32.dll</span></kbd><span class="koboSpan" id="kobo.24.1">, while benign software rarely imports this DLL, and that explains how malware carries out propagation and damage through network connections.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Extracting malware artifacts in a dataset</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">After having analyzed the PE file format, we are now ready to extract the characteristics of the binary files (whether legitimate or suspect), and store them in a dataset of artifacts with which to train our algorithms.</span></p>
<p><span class="koboSpan" id="kobo.3.1">For this purpose, we will develop Python scripts to automate the extraction of PE file format fields for each single file we analyze.</span></p>
<p><span class="koboSpan" id="kobo.4.1">The Python library that we will use in our scripts is the famous </span><kbd><span class="koboSpan" id="kobo.5.1">pefile</span></kbd><span class="koboSpan" id="kobo.6.1"> library, which was developed by Ero Carrera and is available at </span><a href="https://github.com/erocarrera/pefile"><span class="koboSpan" id="kobo.7.1">https://github.com/erocarrera/pefile</span></a><span class="koboSpan" id="kobo.8.1">.</span><a href="https://github.com/erocarrera/pefile"/></p>
<p><span class="koboSpan" id="kobo.9.1">Once the archive containing the library has been downloaded and unpacked locally, we can proceed with the installation by executing the following command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.10.1">python setup.py install</span></strong></pre>
<p><span class="koboSpan" id="kobo.11.1">If, instead, we have created an environment in Anaconda following the instructions of the previous chapters, we can install the </span><kbd><span class="koboSpan" id="kobo.12.1">pefile</span></kbd><span class="koboSpan" id="kobo.13.1"> library with the following command (assuming that the environment is called </span><kbd><span class="koboSpan" id="kobo.14.1">py35</span></kbd><span class="koboSpan" id="kobo.15.1">):</span></p>
<pre><strong><span class="koboSpan" id="kobo.16.1">conda install -n py35 -c conda-forge pefile</span></strong></pre>
<p><span class="koboSpan" id="kobo.17.1">In this way, we will be able to recall the functions of the library, even inside our Jupyter Notebooks.</span></p>
<p><span class="koboSpan" id="kobo.18.1">After having fed our malware dataset, as previously discussed, we can proceed to extract the artifacts from each single file, reading the corresponding </span><kbd><span class="koboSpan" id="kobo.19.1">pefile</span></kbd><span class="koboSpan" id="kobo.20.1"> format fields using the </span><kbd><span class="koboSpan" id="kobo.21.1">pefile</span></kbd><span class="koboSpan" id="kobo.22.1"> Python library, as shown in the following script:</span></p>
<pre><span class="koboSpan" id="kobo.23.1">import os</span><br/><span class="koboSpan" id="kobo.24.1">import pefile</span><br/><br/><span class="koboSpan" id="kobo.25.1">suspect_pe = pefile.PE("suspect.exe")</span></pre>
<p><span class="koboSpan" id="kobo.26.1">Here, we uploaded the local </span><kbd><span class="koboSpan" id="kobo.27.1">suspect.exe</span></kbd><span class="koboSpan" id="kobo.28.1"> </span><span><span class="koboSpan" id="kobo.29.1">file,</span></span><span class="koboSpan" id="kobo.30.1"> which is part of our malware dataset.</span></p>
<p><span class="koboSpan" id="kobo.31.1">At this point, we are able to extract the individual fields of the PE file format belonging to the </span><kbd><span class="koboSpan" id="kobo.32.1">suspect.exe</span></kbd><span class="koboSpan" id="kobo.33.1"> file, by simply dereferencing the </span><kbd><span class="koboSpan" id="kobo.34.1">suspect_pe</span></kbd><span class="koboSpan" id="kobo.35.1"> object.</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.36.1">Using the following script, we will extract the main fields of the PE file format, recalling them directly to the previously defined object:</span></p>
<pre><span class="koboSpan" id="kobo.37.1">AddressOfEntryPoint = suspect_pe.OPTIONAL_HEADER.AddressOfEntryPoint</span><br/><span class="koboSpan" id="kobo.38.1">MajorImageVersion = suspect_pe.OPTIONAL_HEADER.MajorImageVersion</span><br/><span class="koboSpan" id="kobo.39.1">NumberOfSections = suspect_pe.FILE_HEADER.NumberOfSections</span><br/><span class="koboSpan" id="kobo.40.1">SizeOfStackReserve = suspect_pe.OPTIONAL_HEADER.SizeOfStackReserve</span></pre>
<p><span class="koboSpan" id="kobo.41.1">We can then proceed to extract the artifacts from every single file contained within our dataset, exporting the fields into a </span><kbd><span class="koboSpan" id="kobo.42.1">.csv</span></kbd><span class="koboSpan" id="kobo.43.1"> file.</span></p>
<p><span class="koboSpan" id="kobo.44.1">The final version of our extraction script will therefore be as follows:</span></p>
<pre><span class="koboSpan" id="kobo.45.1">import os</span><br/><span class="koboSpan" id="kobo.46.1">import pefile</span><br/><span class="koboSpan" id="kobo.47.1">import glob</span><br/><br/><span class="koboSpan" id="kobo.48.1">csv = file('MalwareArtifacts.csv','w')</span><br/><br/><span class="koboSpan" id="kobo.49.1">files = glob.glob('c:\\MalwareSamples\\*.exe')</span><br/><br/><span class="koboSpan" id="kobo.50.1">csv.write("AddressOfEntryPoint,MajorLinkerVersion,MajorImageVersion,
MajorOperatingSystemVersion,,DllCharacteristics,SizeOfStackReserve,
NumberOfSections,ResourceSize,\n")</span><br/><br/><span class="koboSpan" id="kobo.51.1">for file in files:</span><br/><span class="koboSpan" id="kobo.52.1">    suspect_pe = pefile.PE(file)</span><br/><span class="koboSpan" id="kobo.53.1">    csv.write( str(suspect_pe.OPTIONAL_HEADER.AddressOfEntryPoint) + ',')</span><br/><span class="koboSpan" id="kobo.54.1">    csv.write( str(suspect_pe.OPTIONAL_HEADER.MajorLinkerVersion) + ',')</span><br/><span class="koboSpan" id="kobo.55.1">    csv.write( str(suspect_pe.OPTIONAL_HEADER.MajorImageVersion) + ',')</span><br/><span class="koboSpan" id="kobo.56.1">    csv.write( str(suspect_pe.OPTIONAL_HEADER.MajorOperatingSystemVersion) + ',')</span><br/><span class="koboSpan" id="kobo.57.1">    csv.write( str(suspect_pe.OPTIONAL_HEADER.DllCharacteristics) + ',')</span><br/><span class="koboSpan" id="kobo.58.1">    csv.write( str(suspect_pe.OPTIONAL_HEADER.SizeOfStackReserve) + ',')</span><br/><span class="koboSpan" id="kobo.59.1">    csv.write( str(suspect_pe.FILE_HEADER.NumberOfSections) + ',')</span><br/><span class="koboSpan" id="kobo.60.1">    csv.write( str(suspect_pe.OPTIONAL_HEADER.DATA_DIRECTORY[2].Size) + "\n")</span><br/><br/><span class="koboSpan" id="kobo.61.1">csv.close()</span><br/><br/><br/></pre>
<p><span class="koboSpan" id="kobo.62.1">We can also extract the artifacts related to legitimate files </span><span><span class="koboSpan" id="kobo.63.1">inside our </span></span><kbd><span class="koboSpan" id="kobo.64.1">.csv</span></kbd><span><span class="koboSpan" id="kobo.65.1"> file</span></span><span class="koboSpan" id="kobo.66.1">, by storing them together with malware samples, in order to be able to carry out the training by comparing the two types of files.</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.67.1">Obviously, we will have to add an additional column to the </span><kbd><span class="koboSpan" id="kobo.68.1">.csv</span></kbd><span class="koboSpan" id="kobo.69.1"> file specifying whether the file is legitimate or not, valuing the field with the value </span><kbd><span class="koboSpan" id="kobo.70.1">1</span></kbd><span class="koboSpan" id="kobo.71.1"> (legitimate) or with the value </span><kbd><span class="koboSpan" id="kobo.72.1">0</span></kbd><span class="koboSpan" id="kobo.73.1"> (suspect), respectively.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Telling different malware families apart</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We have seen the advantages and limitations associated with traditional malware analysis methodologies, and we have understood why—in light of the high prevalence of malware threats—it is necessary to introduce algorithmic automation methods for malware detection.</span></p>
<p><span class="koboSpan" id="kobo.3.1">In particular, it is increasingly important that the similarities in malware behavior are correctly identified, which means that malware samples must be associated to classes or families of the same type, even if the individual malware signatures are not comparable to each other, due to, for example, the presence of polymorphic codes that alter the hash checksums accordingly.</span></p>
<p><span class="koboSpan" id="kobo.4.1">The analysis of similarities can be carried out in an automated form, by using </span><strong><span class="koboSpan" id="kobo.5.1">clustering algorithms</span></strong><span class="koboSpan" id="kobo.6.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Understanding clustering algorithms</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The intuition underlying clustering algorithms consists of identifying and exploiting the similarities that characterize certain types of phenomena.</span></p>
<p><span class="koboSpan" id="kobo.3.1">In technical terms, it is a matter of distinguishing and recognizing, within a dataset, the features whose values ​​change with high frequency, from those features whose values are shown to remain systematically stable</span><span><span class="koboSpan" id="kobo.4.1"> ​​instead</span></span><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">Only these latter features are taken into consideration for the detection of phenomena characterized by similarity.</span></p>
<p><span class="koboSpan" id="kobo.6.1">We can follow these two types of approaches in identifying similarities:</span></p>
<ul>
<li>
<p><strong><span class="koboSpan" id="kobo.7.1">Supervised</span></strong><span class="koboSpan" id="kobo.8.1">: The similarities are identified on the basis of previously categorized samples (for example, the </span><strong><span class="koboSpan" id="kobo.9.1">k-Nearest Neighbors</span></strong><span class="koboSpan" id="kobo.10.1"> (</span><strong><span class="koboSpan" id="kobo.11.1">k-NNs</span></strong><span class="koboSpan" id="kobo.12.1">) algorithms).</span></p>
</li>
<li>
<p><strong><span class="koboSpan" id="kobo.13.1">Unsupervised</span></strong><span class="koboSpan" id="kobo.14.1">: Similarities are identified independently by the algorithm itself (for example, the </span><strong><span class="koboSpan" id="kobo.15.1">K-Means</span></strong><span class="koboSpan" id="kobo.16.1"> algorithm).</span></p>
</li>
</ul>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.17.1">The estimate of the similarity between the features is carried out by associating them with a definition of </span><strong><span class="koboSpan" id="kobo.18.1">distance</span></strong><span class="koboSpan" id="kobo.19.1">.</span></p>
<p><span class="koboSpan" id="kobo.20.1">If we consider the individual features as points in an </span><em><span class="koboSpan" id="kobo.21.1">n</span></em><span class="koboSpan" id="kobo.22.1">-dimensional space (in association with the number of analyzed features), we can choose a suitable mathematical criterion to estimate the distance existing between single points (which individually identify an algebraic vector).</span></p>
<p><span class="koboSpan" id="kobo.23.1">Some of the measures that can be selected to identify the distances between numerical vectors are as follows:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.24.1">Euclidean distance</span></strong><span class="koboSpan" id="kobo.25.1">: This feature identifies the shortest path (the straight line) that unites two points in the Cartesian space, and is calculated with the following mathematical formula:</span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.26.1"><img class="fm-editor-equation" src="assets/33692b1d-932e-44a8-ba04-068ed929d14d.png" style="width:13.00em;height:2.58em;"/></span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.27.1">Manhattan distance</span></strong><span class="koboSpan" id="kobo.28.1">: This feature is obtained from the sum of the absolute values of the differences calculated on the elements of the vectors. </span><span class="koboSpan" id="kobo.28.2">Unlike the Euclidean distance, the Manhattan distance identifies the longest route that joins the two points; in formulas, it is equivalent to the following:</span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.29.1"><img class="fm-editor-equation" src="assets/e49a8733-2abb-4858-8057-140cac0c8be3.png" style="width:12.25em;height:2.08em;"/></span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.30.1">Chebyshev distance</span></strong><span class="koboSpan" id="kobo.31.1">: This is obtained by calculating the maximum value of the absolute differences between the elements of the vectors; </span><span><span class="koboSpan" id="kobo.32.1">in formulas, it is equivalent to the following</span></span><span class="koboSpan" id="kobo.33.1">:</span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.34.1"><img class="fm-editor-equation" src="assets/e2b14b0f-2b5d-451d-af51-cbfa417e1fab.png" style="width:12.33em;height:1.58em;"/></span></p>
<p style="padding-left: 60px" class="CDPAlignLeft CDPAlign"><span><span class="koboSpan" id="kobo.35.1">The use of the Chebyshev distance is particularly useful if the number of dimensions to be taken into account is particularly high, although most of them are irrelevant for analysis purposes.</span></span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">From distances to clusters</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The clustering process therefore consists of classifying together elements that show certain similarities between them.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Having defined the concept of similarity using some mathematical definitions of distance, the clustering process is thus reduced in the exploration of the various dimensions of a given data space in every direction, starting from a given point, and then aggregating together the samples that fall into a certain distance.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Clustering algorithms</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Different types of clustering algorithms are conceivable, from the simplest and most intuitive, to the most complex and abstract ones.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Some of the most commonly used algorithms are listed as follows:</span></p>
<ul>
<li>
<p><strong><span class="koboSpan" id="kobo.4.1">K-Means</span></strong><span class="koboSpan" id="kobo.5.1">: One of the most widespread among the unsupervised clustering algorithms. </span><span class="koboSpan" id="kobo.5.2">K-Means can enlist among its strengths the simplicity of implementation and the capability of unveiling hidden patterns within the data. </span><span class="koboSpan" id="kobo.5.3">This can be achieved by proceeding to the independent identification of possible labels.</span></p>
</li>
<li>
<p><strong><span class="koboSpan" id="kobo.6.1">K-NNs</span></strong><span class="koboSpan" id="kobo.7.1">: This is an example of a lazy learning model. </span><span class="koboSpan" id="kobo.7.2">The K-NN algorithm only starts working in the evaluation phase, while in the training phase it simply limits itself to memorizing the observational data. </span><span class="koboSpan" id="kobo.7.3">Due to these characteristics, the use of k-NN is inefficient in the presence of large datasets.</span></p>
</li>
<li>
<p><strong><span class="koboSpan" id="kobo.8.1">Density-Based Spatial Clustering of Applications with Noise</span></strong><span><span class="koboSpan" id="kobo.9.1"> (</span></span><strong><span class="koboSpan" id="kobo.10.1">DBSCAN</span></strong><span><span class="koboSpan" id="kobo.11.1">)</span></span><span class="koboSpan" id="kobo.12.1">: Unlike K-Means, which is a distance-based algorithm, DBSCAN is an example of a density-based algorithm. </span><span class="koboSpan" id="kobo.12.2">As such, the algorithm tries to classify data by identifying high-density regions.</span></p>
</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Evaluating clustering with the Silhouette coefficient</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">One of the recurring problems with clustering algorithms is the evaluation of the results.</span></p>
<p><span class="koboSpan" id="kobo.3.1">While in the case of supervised algorithms, by already knowing the classification labels, we are able to evaluate the results obtained by the algorithm simply by counting out the number of samples incorrectly classified and comparing them with those correctly classified. </span><span class="koboSpan" id="kobo.3.2">In the case of unsupervised algorithms, the evaluation of results is less intuitive.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Not having the classification labels available beforehand, we will have to evaluate the results by analyzing the behavior of the algorithm itself, only considering the clustering process as successful if the samples classified in the same cluster are all actually similar.</span></p>
<p><span class="koboSpan" id="kobo.5.1">For the distance-based clustering algorithms, we can use as a metric of evaluation called the </span><strong><span class="koboSpan" id="kobo.6.1">Silhouette coefficient</span></strong><span class="koboSpan" id="kobo.7.1">, which takes the following mathematical formula:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.8.1"><img class="fm-editor-equation" src="assets/c457bc07-df77-4dab-80d8-53126453c120.png" style="width:14.17em;height:1.50em;"/></span></p>
<p><span class="koboSpan" id="kobo.9.1">Here, </span><em><span class="koboSpan" id="kobo.10.1">m</span></em><span class="koboSpan" id="kobo.11.1"> represents the average distance existing between each single sample and all the other samples of the </span><strong><span class="koboSpan" id="kobo.12.1">nearest</span></strong><span class="koboSpan" id="kobo.13.1"> cluster, while </span><em><span class="koboSpan" id="kobo.14.1">n </span></em><span class="koboSpan" id="kobo.15.1">represents the average distance existing between each single sample and all the other samples of the </span><strong><span class="koboSpan" id="kobo.16.1">same</span></strong><span class="koboSpan" id="kobo.17.1"> cluster.</span></p>
<p><span class="koboSpan" id="kobo.18.1">The Silhouette coefficient is calculated for each single sample (as such, the calculation process becomes particularly slow when dealing with large datasets), and the estimate of the distance is determined by the particular metric we chose (such as the Euclidean distance or the Manhattan distance).</span></p>
<p><span class="koboSpan" id="kobo.19.1">The main features of the Silhouette coefficient are the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.20.1">The value of </span><em><span class="koboSpan" id="kobo.21.1">Sc</span></em><span class="koboSpan" id="kobo.22.1"> can vary between </span><kbd><span class="koboSpan" id="kobo.23.1">-1</span></kbd><span class="koboSpan" id="kobo.24.1"> and </span><kbd><span class="koboSpan" id="kobo.25.1">+1</span></kbd><span class="koboSpan" id="kobo.26.1">, depending on the goodness of the clustering process</span></li>
<li><span class="koboSpan" id="kobo.27.1">The value of </span><em><span class="koboSpan" id="kobo.28.1">Sc</span></em><span class="koboSpan" id="kobo.29.1"> will tend toward </span><kbd><span class="koboSpan" id="kobo.30.1">+1</span></kbd><span class="koboSpan" id="kobo.31.1"> in the case of optimal clustering, while it will tend toward </span><kbd><span class="koboSpan" id="kobo.32.1">-1</span></kbd><span class="koboSpan" id="kobo.33.1"> in the opposite case of non optimal clustering</span></li>
<li><span class="koboSpan" id="kobo.34.1">If the value of </span><em><span class="koboSpan" id="kobo.35.1">Sc</span></em><span class="koboSpan" id="kobo.36.1"> is close to </span><kbd><span class="koboSpan" id="kobo.37.1">0</span></kbd><span class="koboSpan" id="kobo.38.1">, we will be in the presence of clusters that overlap each other</span></li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">K-Means in depth</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We will now deal with the K-Means clustering algorithm </span><span><span class="koboSpan" id="kobo.3.1">in more depth</span></span><span class="koboSpan" id="kobo.4.1">.</span></p>
<p><span class="koboSpan" id="kobo.5.1">As previously stated, K-Means is an unsupervised algorithm, that is, it does not presuppose the prior knowledge of the labels associated with the data.</span></p>
<p><span class="koboSpan" id="kobo.6.1">The algorithm takes its name from the fact that its final purpose is to divide the data into k different subgroups. </span><span class="koboSpan" id="kobo.6.2">Being a clustering algorithm, it proceeds to the subdivision of the data into different subgroups on the basis of a chosen measure to represent the distance of the single samples (usually, this measure is the Euclidean distance) from the center of the respective cluster (also known as </span><strong><span class="koboSpan" id="kobo.7.1">centroid</span></strong><span class="koboSpan" id="kobo.8.1">).</span></p>
<p><span class="koboSpan" id="kobo.9.1">In other words, the K-Means algorithm proceeds to group the data into distinct clusters, </span><strong><span class="koboSpan" id="kobo.10.1">minimizing a cost function</span></strong><span class="koboSpan" id="kobo.11.1"> represented by the Euclidean distance calculated between the data (considered as points in space) and the respective centroids.</span></p>
<p><span class="koboSpan" id="kobo.12.1">At the end of its elaboration, the algorithm returns the individual samples grouped in correspondence of each cluster, whose centroids constitute the set of distinctive features identified by the algorithm as representative of the different categories that can be identified within the dataset.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">K-Means steps</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The K-Means algorithm is characterized by the following steps:</span></p>
<ol>
<li class="mce-root"><span><strong><span class="koboSpan" id="kobo.3.1">Initialization</span></strong><span class="koboSpan" id="kobo.4.1">: This is the phase in which the centroids are identified on the basis of the number of clusters defined by the analyst (usually, we are not able to know the number of </span><strong><span class="koboSpan" id="kobo.5.1">real</span></strong><span class="koboSpan" id="kobo.6.1"> clusters in advance, so it is often necessary to proceed by trial and error when defining the number of clusters).</span></span></li>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.7.1">Data assignment to the clusters</span></strong><span class="koboSpan" id="kobo.8.1">: Based on the definition of the centroids carried out in the initialization phase, the data is assigned to the closest cluster, on the basis of the minimum Euclidean distance calculated between the data and their respective centroids.</span></li>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.9.1">Centroids update</span></strong><span class="koboSpan" id="kobo.10.1">: Being an iterative process, the K-Means algorithm proceeds again to the estimation of the centroids by estimating the average of the data included in the single clusters. </span><span class="koboSpan" id="kobo.10.2">Then the algorithm proceeds to the reassignment of the average, until the Euclidean distance between the data and the respective centroids is not minimized, or the number of iterations defined by the analyst as an input parameter has not been exceeded.</span></li>
</ol>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.11.1">To use the implementation of the K-Means algorithm that comes with the </span><kbd><span class="koboSpan" id="kobo.12.1">scikit-learn</span></kbd><span class="koboSpan" id="kobo.13.1"> library, we must appropriately choose a series of input parameters in order to define the phases of the algorithm iterative process, as identified previously.</span></p>
<p><span class="koboSpan" id="kobo.14.1">In particular, it will be necessary to identify the number of clusters (representative of the parameter </span><kbd><span class="koboSpan" id="kobo.15.1">k</span></kbd><span class="koboSpan" id="kobo.16.1">) and the mode of initialization of the centroids.</span></p>
<p><span class="koboSpan" id="kobo.17.1">The choice of the number of clusters by the analyst has consequences on the result obtained by the algorithm: if the number of clusters set as an initialization parameter is excessive, the purpose of clustering is disregarded (algorithm behavior at the limit will tend to identify a different cluster for each single data).</span></p>
<p><span class="koboSpan" id="kobo.18.1">To this end, it may be useful to conduct a preliminary phase of </span><strong><span class="koboSpan" id="kobo.19.1">exploratory data analysis</span></strong><span class="koboSpan" id="kobo.20.1"> (</span><strong><span class="koboSpan" id="kobo.21.1">EDA</span></strong><span class="koboSpan" id="kobo.22.1">)—performed with the aid of data plotting—by visually identifying the number of possible distinct subgroups into which the data can be distributed.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">K-Means pros and cons</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Among the advantages of the K-Means algorithm we can remember, in addition to its simplicity of use, its high scalability makes it preferable in the presence of large datasets.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The disadvantages instead are essentially due to the inappropriate choice of the </span><kbd><span class="koboSpan" id="kobo.4.1">k</span></kbd><span class="koboSpan" id="kobo.5.1"> par</span><span><span class="koboSpan" id="kobo.6.1">ameter,</span></span><span class="koboSpan" id="kobo.7.1"> representative of the number of clusters, which, as we have seen, requires particular attention on behalf of the analyst, who will be called to carefully evaluate this choice on the basis of an EDA, or proceeding by trial and error.</span></p>
<p><span class="koboSpan" id="kobo.8.1">Another disadvantage associated with the using the K-Means algorithm is determined by the fact that it provides poorly representative results in the presence of datasets characterized by high dimensions.</span></p>
<p><span class="koboSpan" id="kobo.9.1">As a result, the phenomenon known as the </span><strong><span class="koboSpan" id="kobo.10.1">curse of dimensionality</span></strong><span class="koboSpan" id="kobo.11.1"> takes place, in which this is in </span><strong><span class="koboSpan" id="kobo.12.1">sparse</span></strong><span class="koboSpan" id="kobo.13.1"> form in the n-dimensional space.</span></p>
<p><span class="koboSpan" id="kobo.14.1">This entails that the cost function of distance minimization (used as a selective criterion for the clusters) is not very representative (in fact, the data may lie equidistant from each other in the n-dimensional space).</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Clustering malware with K-Means</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In the following example, we will see the K-Means clustering algorithm applied to our previously created dataset of artifacts.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Remember that our dataset of artifacts contains the fields extracted from the PE file format of the individual samples, consisting of the </span><kbd><span class="koboSpan" id="kobo.4.1">.exe</span></kbd><span class="koboSpan" id="kobo.5.1"> files previously stored, including both the legitimate and the suspect files.</span></p>
<p><span class="koboSpan" id="kobo.6.1">The number of clusters that we will assign to the </span><kbd><span class="koboSpan" id="kobo.7.1">k</span></kbd> <span><span class="koboSpan" id="kobo.8.1">parameter </span></span><span class="koboSpan" id="kobo.9.1">in the algorithm initialization phase will therefore be </span><kbd><span class="koboSpan" id="kobo.10.1">2</span></kbd><span class="koboSpan" id="kobo.11.1">, while the features that we will select as distinctive criteria of the possible malware correspond to the </span><kbd><span class="koboSpan" id="kobo.12.1">MajorLinkerVersion</span></kbd><span class="koboSpan" id="kobo.13.1">, </span><kbd><span class="koboSpan" id="kobo.14.1">MajorImageVersion</span></kbd><span class="koboSpan" id="kobo.15.1">, </span><kbd><span class="koboSpan" id="kobo.16.1">MajorOperatingSystemVersion</span></kbd><span class="koboSpan" id="kobo.17.1">, and </span><kbd><span class="koboSpan" id="kobo.18.1">DllCharacteristics</span></kbd><span class="koboSpan" id="kobo.19.1"> </span><span><span class="koboSpan" id="kobo.20.1">fields:</span></span></p>
<pre><span class="koboSpan" id="kobo.21.1">import numpy as np </span><br/><span class="koboSpan" id="kobo.22.1">import pandas as pd </span><br/><span class="koboSpan" id="kobo.23.1">import matplotlib.pyplot as plt </span><br/><br/><span class="koboSpan" id="kobo.24.1">from sklearn.cluster import KMeans </span><br/><span class="koboSpan" id="kobo.25.1">from sklearn.metrics import silhouette_score </span><br/><br/><span class="koboSpan" id="kobo.26.1">malware_dataset = pd.read_csv('../datasets/MalwareArtifacts.csv', delimiter=',')</span><br/><br/><span class="koboSpan" id="kobo.27.1"># Extracting artifacts samples fields </span><br/><span class="koboSpan" id="kobo.28.1"># MajorLinkerVersion,MajorImageVersion,</span><br/><span class="koboSpan" id="kobo.29.1"># MajorOperatingSystemVersion,DllCharacteristics</span><br/><br/><span class="koboSpan" id="kobo.30.1">samples = malware_dataset.iloc[:, [1,2,3,4]].values</span><br/><span class="koboSpan" id="kobo.31.1">targets = malware_dataset.iloc[:, 8].values</span></pre>
<p><span><span class="koboSpan" id="kobo.32.1">Once the fields of interest from our dataset are selected, we can proceed to instantiate the</span></span> <kbd><span class="koboSpan" id="kobo.33.1">KMeans</span></kbd> <span><span class="koboSpan" id="kobo.34.1">class of </span><kbd><span class="koboSpan" id="kobo.35.1">scikit-learn</span></kbd><span class="koboSpan" id="kobo.36.1">, passing the</span></span><span class="koboSpan" id="kobo.37.1"> </span><kbd><span class="koboSpan" id="kobo.38.1">k</span></kbd><span><span class="koboSpan" id="kobo.39.1"> value as an input parameters representing the number of clusters, equal to </span><kbd><span class="koboSpan" id="kobo.40.1">2</span></kbd><span class="koboSpan" id="kobo.41.1"> (</span></span><kbd><span class="koboSpan" id="kobo.42.1">n_clusters = 2</span></kbd><span><span class="koboSpan" id="kobo.43.1">), and defining the maximum</span></span> <strong><span class="koboSpan" id="kobo.44.1">number of iterations</span></strong><em><span class="koboSpan" id="kobo.45.1"> </span></em><span><span class="koboSpan" id="kobo.46.1">that the algorithm can execute, equal to </span><kbd><span class="koboSpan" id="kobo.47.1">300</span></kbd><span class="koboSpan" id="kobo.48.1"> (</span></span><kbd><span class="koboSpan" id="kobo.49.1">max_iter = 300</span></kbd><span><span class="koboSpan" id="kobo.50.1">) in our case:</span></span></p>
<pre><span class="koboSpan" id="kobo.51.1">k_means = KMeans(n_clusters=2,max_iter=300)</span></pre>
<p><span><span class="koboSpan" id="kobo.52.1">We can then invoke the</span></span> <kbd><span class="koboSpan" id="kobo.53.1">fit()</span></kbd> <span><span class="koboSpan" id="kobo.54.1">method on the</span></span> <kbd><span class="koboSpan" id="kobo.55.1">k_means</span></kbd> <span><span class="koboSpan" id="kobo.56.1">object, thus proceeding to start the iterative algorithm process:</span></span></p>
<pre><span class="koboSpan" id="kobo.57.1">k_means.fit(samples)</span></pre>
<p><span><span class="koboSpan" id="kobo.58.1">We just have to evaluate the results obtained by the algorithm. </span><span class="koboSpan" id="kobo.58.2">To this end, we will use the</span></span><span class="koboSpan" id="kobo.59.1"> Silhouette coefficient </span><span><span class="koboSpan" id="kobo.60.1">we introduced previously, calculated by using the Euclidean distance as a metric, together with the</span></span><span class="koboSpan" id="kobo.61.1"> </span><strong><span class="koboSpan" id="kobo.62.1">confusion matrix</span></strong> <span><span class="koboSpan" id="kobo.63.1">of the results. </span><span class="koboSpan" id="kobo.63.2">This will show us a table with the respective clustering results, divided between correct and incorrect forecasts:</span></span></p>
<pre><span class="koboSpan" id="kobo.64.1">k_means = KMeans(n_clusters=2,max_iter=300)</span><br/><span class="koboSpan" id="kobo.65.1">k_means.fit(samples) </span><br/><br/><span class="koboSpan" id="kobo.66.1">print("K-means labels: " + str(k_means.labels_))</span><br/><br/><span class="koboSpan" id="kobo.67.1">print ("\nK-means Clustering Results:\n\n", pd.crosstab(targets,</span><br/><span class="koboSpan" id="kobo.68.1">k_means.labels_,rownames = ["Observed"],colnames = ["Predicted"]) )      </span><br/><br/><span class="koboSpan" id="kobo.69.1">print ("\nSilhouette coefficient: %0.3f" % silhouette_score(samples, k_means.labels_, metric='euclidean')) </span></pre>
<p><span><span class="koboSpan" id="kobo.70.1">The results of the process are as follows:</span></span></p>
<pre><span class="koboSpan" id="kobo.71.1">K-means labels: [0 0 0 ... </span><span class="koboSpan" id="kobo.71.2">0 1 0]</span><br/><span class="koboSpan" id="kobo.72.1">K-means Clustering Results:</span><br/><br/><span class="koboSpan" id="kobo.73.1">Predicted      0      1</span><br/><span class="koboSpan" id="kobo.74.1">Observed               </span><br/><span class="koboSpan" id="kobo.75.1">0           83419  13107</span><br/><span class="koboSpan" id="kobo.76.1">1            7995  32923</span><br/><br/><span class="koboSpan" id="kobo.77.1">Silhouette coefficient: 0.975</span></pre>
<p><span class="koboSpan" id="kobo.78.1">We can see how the clustering algorithm was able to successfully identify the labels corresponding to the clusters to be associated with the individual samples, and from the confusion matrix, it is possible to detect how </span><kbd><span class="koboSpan" id="kobo.79.1">83419</span></kbd><span class="koboSpan" id="kobo.80.1"> samples (out of a total of 96,526) belonging to the suspect category have been correctly identified (having being classified under label </span><kbd><span class="koboSpan" id="kobo.81.1">0</span></kbd><span class="koboSpan" id="kobo.82.1">), while only </span><kbd><span class="koboSpan" id="kobo.83.1">13107</span></kbd><span class="koboSpan" id="kobo.84.1"> (13.58% of the total) were mistakenly considered as </span><strong><span class="koboSpan" id="kobo.85.1">legitimate</span></strong><span class="koboSpan" id="kobo.86.1">.</span></p>
<p><span class="koboSpan" id="kobo.87.1">In the same way, only </span><kbd><span class="koboSpan" id="kobo.88.1">7995</span></kbd><span class="koboSpan" id="kobo.89.1"> samples (out of a total of 40,918) were classified as suspect (equal to 19.54% of the total), despite being truly legitimate </span><span><span class="koboSpan" id="kobo.90.1">instead,</span></span><span class="koboSpan" id="kobo.91.1"> compared to </span><kbd><span class="koboSpan" id="kobo.92.1">32923</span></kbd><span class="koboSpan" id="kobo.93.1"> samples correctly classified as legitimate.</span></p>
<p><span class="koboSpan" id="kobo.94.1">The </span><kbd><span class="koboSpan" id="kobo.95.1">Silhouette coefficient</span></kbd><span class="koboSpan" id="kobo.96.1"> is equal to </span><kbd><span class="koboSpan" id="kobo.97.1">0.975</span></kbd><span class="koboSpan" id="kobo.98.1">, which is very close to 1, reflecting the goodness of the results obtained by the clustering algorithm.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Decision tree malware detectors</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In addition to clustering algorithms, it is possible to use classification algorithms for the detection of malware threats. </span><span class="koboSpan" id="kobo.2.2">Of particular importance is the classification of the malware carried out by using </span><em><span class="koboSpan" id="kobo.3.1">decision trees</span></em><span class="koboSpan" id="kobo.4.1">.</span></p>
<p><span class="koboSpan" id="kobo.5.1">We have already met decision trees in </span><a href="aaf59353-00b3-4625-8732-63aad02cc8e5.xhtml"><span class="koboSpan" id="kobo.6.1">Chapter 3</span></a><span class="koboSpan" id="kobo.7.1">, </span><em><span class="koboSpan" id="kobo.8.1">Ham or Spam? </span><span class="koboSpan" id="kobo.8.2">Detecting Email Cybersecurity Threats with AI</span></em><span class="koboSpan" id="kobo.9.1">, when we discussed the problem of </span><strong><span class="koboSpan" id="kobo.10.1">spam detection</span></strong><span class="koboSpan" id="kobo.11.1">. </span><span class="koboSpan" id="kobo.11.2">Now, we will deal with the classification problems solved by decision trees in the context of detecting malware threats.</span></p>
<p><span class="koboSpan" id="kobo.12.1">The distinctive feature of decision trees is that these algorithms achieve the goal of classifying data in certain classes by modeling the learning process based on a sequence of if-then-else decisions.</span></p>
<p><span class="koboSpan" id="kobo.13.1">For this characteristic, decision trees represent a type of non-linear classifier, whose decision boundaries are not reducible to straight lines or hyperplanes in space.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Decision trees classification strategy</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Decision trees, therefore, shape their learning process based on a tree structure. </span><span class="koboSpan" id="kobo.2.2">Starting from a root node, subsequent decisions branch into various branches of different depths.</span></p>
<p><span class="koboSpan" id="kobo.3.1">In essence, the samples dataset is divided by the algorithm in an iterative way, based on the decisions that are taken at each node, thus giving rise to the various branches. </span><span class="koboSpan" id="kobo.3.2">Branches, on the other hand, represent nothing more than the various ways in which data can be classified, based on the possible choices made at the various decision nodes.</span></p>
<p><span class="koboSpan" id="kobo.4.1">This iterative process of subdividing the dataset is determined by a predefined measure of the quality of the subdivision conditions. </span><span class="koboSpan" id="kobo.4.2">The most commonly used metrics for measuring the quality of subdivision are the following:</span></p>
<ul>
<li class="mce-root"><span><span class="koboSpan" id="kobo.5.1">Gini impurity</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.6.1">Variance reduction</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.7.1">Information gain</span></li>
</ul>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.8.1">Despite their high explanatory capacity, decision trees do, however, suffer from some important limitations:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">As the number of features considered increases, the complexity of the structure representing the associated decision tree grows accordingly, translating this complexity into the phenomenon known as </span><strong><span class="koboSpan" id="kobo.10.1">overfitting</span></strong><span class="koboSpan" id="kobo.11.1"> (that is, the algorithm tends to model the </span><strong><span class="koboSpan" id="kobo.12.1">noise</span></strong><span class="koboSpan" id="kobo.13.1"> in the data, rather than the </span><strong><span class="koboSpan" id="kobo.14.1">signal</span></strong><span class="koboSpan" id="kobo.15.1">, leading to less precise forecasts on the test data)</span></li>
<li><span class="koboSpan" id="kobo.16.1">Decision trees are particularly sensitive to even small variations in sample data, making forecasts unstable</span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">One way to overcome these limitations is to create tree ensembles, associating a </span><strong><span class="koboSpan" id="kobo.18.1">vote</span></strong><span class="koboSpan" id="kobo.19.1"> to each tree. </span><span class="koboSpan" id="kobo.19.2">The mechanism for assigning samples to the respective classes is therefore reduced to counting the votes assigned by the various trees; an example of a tree ensemble is the </span><strong><span class="koboSpan" id="kobo.20.1">random forest</span></strong><span class="koboSpan" id="kobo.21.1"> algorithm.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Detecting malwares with decision trees</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We have already met decision trees before, when we addressed the topic of </span><em><span class="koboSpan" id="kobo.3.1">phishing</span></em><span class="koboSpan" id="kobo.4.1"> detection. </span><span class="koboSpan" id="kobo.4.2">Obviously, we can also use decision trees to perform malware detection.</span></p>
<p><span class="koboSpan" id="kobo.5.1">In our example, we will use the </span><kbd><span class="koboSpan" id="kobo.6.1">AddressOfEntryPoint</span></kbd><span class="koboSpan" id="kobo.7.1"> and </span><kbd><span class="koboSpan" id="kobo.8.1">DllCharacteristics</span></kbd><span class="koboSpan" id="kobo.9.1"> fields as potentially distinctive features for detecting the suspect </span><kbd><span class="koboSpan" id="kobo.10.1">.exe</span></kbd><span class="koboSpan" id="kobo.11.1">:</span></p>
<pre><span class="koboSpan" id="kobo.12.1">import pandas as pd</span><br/><span class="koboSpan" id="kobo.13.1">import numpy as np</span><br/><span class="koboSpan" id="kobo.14.1">from sklearn import *</span><br/><br/><span class="koboSpan" id="kobo.15.1">from sklearn.metrics import accuracy_score</span><br/><br/><span class="koboSpan" id="kobo.16.1">malware_dataset = pd.read_csv('../datasets/MalwareArtifacts.csv', delimiter=',')</span><br/><br/><span class="koboSpan" id="kobo.17.1"># Extracting artifacts samples fields "AddressOfEntryPoint" and</span><br/><span class="koboSpan" id="kobo.18.1"># "DllCharacteristics"</span><br/><span class="koboSpan" id="kobo.19.1">samples = malware_dataset.iloc[:, [0, 4]].values</span><br/><span class="koboSpan" id="kobo.20.1">targets = malware_dataset.iloc[:, 8].values</span><br/><br/><span class="koboSpan" id="kobo.21.1">from sklearn.model_selection import train_test_split</span><br/><br/><span class="koboSpan" id="kobo.22.1">training_samples, testing_samples, training_targets, </span><br/><span class="koboSpan" id="kobo.23.1">testing_targets = train_test_split(samples, targets, </span><br/><span class="koboSpan" id="kobo.24.1">                    test_size=0.2, random_state=0)</span><br/><br/><span class="koboSpan" id="kobo.25.1">from sklearn import tree</span><br/><span class="koboSpan" id="kobo.26.1">tree_classifier = tree.DecisionTreeClassifier()</span><br/><br/><span class="koboSpan" id="kobo.27.1">tree_classifier.fit(training_samples, training_targets)</span><br/><br/><span class="koboSpan" id="kobo.28.1">predictions = tree_classifier.predict(testing_samples)</span><br/><br/><span class="koboSpan" id="kobo.29.1">accuracy = 100.0 * accuracy_score(testing_targets, predictions)</span><br/><br/><span class="koboSpan" id="kobo.30.1">print ("Decision Tree accuracy: " + str(accuracy))</span><br/><span class="koboSpan" id="kobo.31.1">Decision Tree accuracy: 96.25860195581312</span></pre>
<p><span class="koboSpan" id="kobo.32.1">As we can see from the results obtained, the accuracy of the forecasts made by selecting the </span><kbd><span class="koboSpan" id="kobo.33.1">AddressOfEntryPoint</span></kbd><span class="koboSpan" id="kobo.34.1"> and </span><kbd><span class="koboSpan" id="kobo.35.1">DllCharacteristics</span></kbd> <span><span class="koboSpan" id="kobo.36.1">fields </span></span><span class="koboSpan" id="kobo.37.1">proves particularly effective, being higher than 96%.</span></p>
<p><span class="koboSpan" id="kobo.38.1">We can try to select different fields as characterizing features, and evaluate the results obtained by comparing them.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Decision trees on steroids – random forests</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We have seen that decision trees suffer from some important limitations, which can lead to unstable results that are caused even by small variations in the training data. </span><span class="koboSpan" id="kobo.2.2">To improve forecasts, you can use </span><strong><span class="koboSpan" id="kobo.3.1">ensemble</span></strong><span class="koboSpan" id="kobo.4.1"> algorithms, such as </span><strong><span class="koboSpan" id="kobo.5.1">random forest</span></strong><span class="koboSpan" id="kobo.6.1">.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Random forest is nothing but a decision tree ensemble in which each tree is given a vote. </span><span class="koboSpan" id="kobo.7.2">The improvement in forecasts is consequently determined by the count of the votes attributed to them: the forecasts that obtain the highest number of votes are those that are selected to achieve the final result of the algorithm.</span></p>
<p><span class="koboSpan" id="kobo.8.1">The creator of the Random Forest algorithm, Leo Breiman, noted that the results obtained by an ensemble of trees improved if the trees were </span><strong><span class="koboSpan" id="kobo.9.1">statistically uncorrelated</span></strong><span class="koboSpan" id="kobo.10.1"> and </span><strong><span class="koboSpan" id="kobo.11.1">independent</span></strong><span class="koboSpan" id="kobo.12.1"> of each other. </span><span class="koboSpan" id="kobo.12.2">Next, we will see an example of the </span><strong><span class="koboSpan" id="kobo.13.1">Random Forest Malware Classifier</span></strong><span class="koboSpan" id="kobo.14.1">, implemented using the </span><kbd><span class="koboSpan" id="kobo.15.1">scikit-learn</span></kbd><span class="koboSpan" id="kobo.16.1"> library.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Random Forest Malware Classifier</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The following is an example of the Random Forest Malware Classifier implemented with the </span><kbd><span class="koboSpan" id="kobo.3.1">scikit-learn</span></kbd><span class="koboSpan" id="kobo.4.1"> library:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">import pandas as pd</span><br/><span class="koboSpan" id="kobo.6.1">import numpy as np</span><br/><span class="koboSpan" id="kobo.7.1">from sklearn import *</span><br/><br/><span class="koboSpan" id="kobo.8.1">malware_dataset = pd.read_csv('../datasets/MalwareArtifacts.csv', delimiter=',')</span><br/><br/><span class="koboSpan" id="kobo.9.1"># Extracting artifacts samples fields "AddressOfEntryPoint" and</span><br/><span class="koboSpan" id="kobo.10.1"># "DllCharacteristics"</span><br/><br/><span class="koboSpan" id="kobo.11.1">samples = malware_dataset.iloc[:, [0,4]].values</span><br/><span class="koboSpan" id="kobo.12.1">targets = malware_dataset.iloc[:, 8].values</span><br/><br/><span class="koboSpan" id="kobo.13.1">from sklearn.model_selection import train_test_split</span><br/><br/><span class="koboSpan" id="kobo.14.1">training_samples, testing_samples, </span><br/><span class="koboSpan" id="kobo.15.1">training_targets, testing_targets = train_test_split(samples, targets,</span><br/><span class="koboSpan" id="kobo.16.1">test_size=0.2)</span><br/><br/><span class="koboSpan" id="kobo.17.1">rfc =  ensemble.RandomForestClassifier(n_estimators=50)</span><br/><span class="koboSpan" id="kobo.18.1">rfc.fit(training_samples, training_targets)</span><br/><span class="koboSpan" id="kobo.19.1">accuracy = rfc.score(testing_samples, testing_targets)</span><br/><br/><span class="koboSpan" id="kobo.20.1">print("Random Forest Classifier accuracy: " + str(accuracy*100) )</span></pre>
<p><span><span class="koboSpan" id="kobo.21.1">As we can see from the results, the random forest classifier improves the performances obtained by the decision tree; to check this, just compare the accuracy of the respective algorithms:</span></span></p>
<pre><span class="koboSpan" id="kobo.22.1">Decision Tree accuracy: 96.25860195581312</span><br/><span class="koboSpan" id="kobo.23.1">Random Forest accuracy: 96.46142701919594</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Detecting metamorphic malware with HMMs</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The examples of algorithms applied to malware detection that have been shown so far were intended to automate some of the routine activities performed by malware analysts.</span></p>
<p><span class="koboSpan" id="kobo.3.1">However, the analysis methodology on which they are based is essentially static malware analysis.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Many of the concrete cases of malware threats, however, are not easily identifiable with this method of analysis, as the malware developers have learned how to work around the detection techniques based on signatures.</span></p>
<p><span class="koboSpan" id="kobo.5.1">It will therefore be necessary to adopt a different methodology to identify the malicious behavior of more advanced malware, and to this end, we will have to move to an approach based on dynamic malware analysis, combining it with the appropriate algorithms.</span></p>
<p><span class="koboSpan" id="kobo.6.1">But to adequately address the problem, it is necessary to understand in detail the limits of traditional detection strategies based on signatures.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How malware circumvents detection?</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The most commonly used detection strategy is the one that uses signatures associated with executable files recognized as malicious.</span></p>
<p><span class="koboSpan" id="kobo.3.1">This strategy offers undoubted advantages, and is widely implemented by antivirus software.</span></p>
<p><span class="koboSpan" id="kobo.4.1">It is based on the search for specific patterns (consisting of sequences of bits considered representative of the malicious executable), conducting the search of these patterns on each of the files stored in the system, and carrying out the systematic scanning of the resources (including the runtime memory) of the system.</span></p>
<p><span class="koboSpan" id="kobo.5.1">The search for patterns takes place on the basis of a database, which contains the signatures of malicious files. </span><span class="koboSpan" id="kobo.5.2">These must be updated promptly and constantly, in order to be able to search and compare files in the system, thus preventing threats from going undetected.</span></p>
<p><span class="koboSpan" id="kobo.6.1">The advantages associated with the signature-based detection strategy are essentially the following:</span></p>
<ul>
<li class="mce-root"><span><span class="koboSpan" id="kobo.7.1">Efficiency in identifying threats already known and present in the signatures database</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.8.1">Low frequency of false positives, which together with false negatives, is the main weakness of malware detection software</span></li>
</ul>
<p><span class="koboSpan" id="kobo.9.1">Instead, the limits of this detection strategy are substantially represented by the basic assumption: that is to say that malicious software, once identified, does not change its binary representation, so it is therefore considered to be adequately photographed by the corresponding signature.</span></p>
<p><span class="koboSpan" id="kobo.10.1">In reality, these assumptions have quickly proved unrealistic. </span><span class="koboSpan" id="kobo.10.2">Over time, in fact, we have witnessed the creativity effort by malware developers to try to create software that was able to change its shape, thus targeting the detection mechanism based on signatures, while maintaining its own offensive potential.</span></p>
<p><span class="koboSpan" id="kobo.11.1">One of the first countermeasures adopted by the authors of malware was obfuscation. To this end, it is possible to perform the encryption of the executable portions of a malware, each time using different encryption keys to alter the signatures associated by the antivirus software to the payload of the malware, while the executable instructions remain unaltered and are decrypted before being sent to execution.</span></p>
<p><span class="koboSpan" id="kobo.12.1">A more sophisticated variant of obfuscation is the creation of polymorphic malware, in which not only the malware encryption key is constantly changed, but also the malware decryption instructions themselves are changed.</span></p>
<p><span class="koboSpan" id="kobo.13.1">The subsequent evolution of polymorphic malware leads to metamorphic malware, in which even the executable instructions of the payload are modified at each execution, thus preventing the most advanced antiviruses from identifying the malicious payload by scanning the runtime memory, once the payload has been decrypted.</span></p>
<p><span class="koboSpan" id="kobo.14.1">In order to alter the payload executable instructions, metamorphic malware implements a </span><strong><span class="koboSpan" id="kobo.15.1">mutation engine</span></strong><span class="koboSpan" id="kobo.16.1"> by adopting the following methods:</span></p>
<ul>
<li class="mce-root"><span><span class="koboSpan" id="kobo.17.1">Inserting additional instructions (dead code) that do not alter the logic and operation of the malware.</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.18.1">Changing the order of the instructions, without altering the logic and overall functionality. </span><span class="koboSpan" id="kobo.18.2">This technique is particularly effective in generating many </span><strong><span class="koboSpan" id="kobo.19.1">variations on the theme</span></strong><span class="koboSpan" id="kobo.20.1">.</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.21.1">Replacement of some instructions with other equivalent instructions.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Polymorphic malware detection strategies</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In the constant </span><em><span class="koboSpan" id="kobo.3.1">cat and mouse game</span></em><span class="koboSpan" id="kobo.4.1"> established between malware developers and antivirus software producers, the latter have tried to keep up the pace, adapting their detection strategies to the different forms of polymorphism.</span></p>
<p><span class="koboSpan" id="kobo.5.1">In the case of polymorphic malware, one of the strategies adopted consists of code emulation: the execution of the malware inside a controlled environment (such as the sandbox), allowing the malware to carry out the decrypt phase of the payload, to which the traditional signature-based detection performed by the antivirus</span><span><span class="koboSpan" id="kobo.6.1"> software follows</span></span><span class="koboSpan" id="kobo.7.1">.</span></p>
<p><span class="koboSpan" id="kobo.8.1">In the case of metamorphic malware, as well as zero days, the detection activity carried out by the most sophisticated antivirus software tries to analyze the behavior of the suspect file, making sense of the logic of the instructions that get executed.</span></p>
<p><span class="koboSpan" id="kobo.9.1">However, this detection strategy suffers from some of the following important limitations:</span></p>
<ul>
<li class="mce-root"><span><span class="koboSpan" id="kobo.10.1">It leads to a high rate of false positives</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.11.1">The analysis of the instructions being executed is carried out on the fly, which can lead to significant impacts in computational terms</span></li>
</ul>
<p><span class="koboSpan" id="kobo.12.1">An alternative strategy in the detection of metamorphic malwares (as well as of zero days) is the one that uses ML algorithms based on HMMs.</span></p>
<p><span class="koboSpan" id="kobo.13.1">To understand what these are, we will first have to introduce these types of algorithms.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">HMM fundamentals</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To understand what an HMM is, we need to introduce Markov processes.</span></p>
<p><span class="koboSpan" id="kobo.3.1">A Markov process (or Markov chain) is a stochastic model that changes its status based on a predefined set of probabilities.</span></p>
<p><span class="koboSpan" id="kobo.4.1">One of the assumptions of the Markov process prescribes that the </span><strong><span class="koboSpan" id="kobo.5.1">probability distribution</span></strong><span class="koboSpan" id="kobo.6.1"> of </span><strong><span class="koboSpan" id="kobo.7.1">future states</span></strong><span class="koboSpan" id="kobo.8.1"> depends exclusively on the </span><strong><span class="koboSpan" id="kobo.9.1">current state</span></strong><span class="koboSpan" id="kobo.10.1">.</span></p>
<p><span class="koboSpan" id="kobo.11.1">Therefore, an HMM is a Markov process of which it is </span><strong><span class="koboSpan" id="kobo.12.1">not</span></strong><span class="koboSpan" id="kobo.13.1"> possible to </span><strong><span class="koboSpan" id="kobo.14.1">directly observe</span></strong><span class="koboSpan" id="kobo.15.1"> the state of the system: the only observable elements are the events and secondary effects associated with the state of the system; however, the probabilities of the events being determined by each state of the system are fixed.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p><span class="koboSpan" id="kobo.16.1">Consequently, the </span><strong><span class="koboSpan" id="kobo.17.1">observations</span></strong><span class="koboSpan" id="kobo.18.1"> on each state of the system are made </span><strong><span class="koboSpan" id="kobo.19.1">indirectly</span></strong><span class="koboSpan" id="kobo.20.1"> on the basis of the events determined by such hidden states, to which probability estimates can be associated:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.21.1"><img src="assets/1351bb6c-8eb2-4bb1-8189-7740455a6c8c.png" style="width:22.75em;height:18.25em;"/></span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span><span class="koboSpan" id="kobo.22.1">(Image credits: https://en.wikipedia.org/wiki/File:HiddenMarkovModel.svg)</span></span></div>
<p><span class="koboSpan" id="kobo.23.1">To intuitively understand how HMMs work, we present the following example: imagine an executable that is launched on a host machine. </span><span class="koboSpan" id="kobo.23.2">At a given time, the machine can continue to function properly, or stop working properly; this behavior represents the observable event.</span></p>
<p><span class="koboSpan" id="kobo.24.1">Let's assume for simplicity that the reasons why the machine stops working regularly can be reduced to the following:</span></p>
<ul>
<li class="mce-root"><span><span class="koboSpan" id="kobo.25.1">The executable executed a </span><strong><span class="koboSpan" id="kobo.26.1">malicious</span></strong><span class="koboSpan" id="kobo.27.1"> instruction</span></span></li>
<li><span><span class="koboSpan" id="kobo.28.1">The executable executed a </span><strong><span class="koboSpan" id="kobo.29.1">legitimate</span></strong><span class="koboSpan" id="kobo.30.1"> instruction</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.31.1">The information relating to the specific reason why the machine stops working properly is the entity unknown to us, which we can only infer based on observable events.</span></p>
<p><span class="koboSpan" id="kobo.32.1">These observable events, in our example, are reduced to the following:</span></p>
<ul>
<li class="mce-root"><span><span class="koboSpan" id="kobo.33.1">The machine works regularly (working)</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.34.1">The machine stops working (not working)</span></li>
</ul>
<p><span class="koboSpan" id="kobo.35.1">Similarly, the hidden entities of our example are represented by the instructions executed by the program:</span></p>
<ul>
<li class="mce-root"><span><strong><span class="koboSpan" id="kobo.36.1">Malicious</span></strong><span class="koboSpan" id="kobo.37.1"> instruction</span></span></li>
<li class="mce-root"><strong><span class="koboSpan" id="kobo.38.1">Legitimate</span></strong><span class="koboSpan" id="kobo.39.1"> instruction</span></li>
</ul>
<p class="mce-root"><span class="koboSpan" id="kobo.40.1">Finally, imagine assigning the probability estimates to the various events and states of the system. </span><span class="koboSpan" id="kobo.40.2">We summarize this in the following table, also known as the </span><strong><span class="koboSpan" id="kobo.41.1">emission matrix</span></strong><span class="koboSpan" id="kobo.42.1">, which summarizes the probabilities that a given observation is associated with a particular observable state (remember that the sum of the probabilities associated to each hidden entity, subdivided according to the possible events, must account to 1):</span></p>
<pre><span class="koboSpan" id="kobo.43.1">                 Working   Not Working</span><br/><br/><span class="koboSpan" id="kobo.44.1">Malicious          0.2         0.8</span><br/><br/><span class="koboSpan" id="kobo.45.1">Legitimate         0.4         0.6</span></pre>
<p><span class="koboSpan" id="kobo.46.1">At this point, we must estimate the probabilities associated with the </span><strong><span class="koboSpan" id="kobo.47.1">next instruction</span></strong><span class="koboSpan" id="kobo.48.1"> executed by the program, which can be summarized in the </span><strong><span class="koboSpan" id="kobo.49.1">transition matrix</span></strong><span class="koboSpan" id="kobo.50.1">:</span></p>
<p><span class="koboSpan" id="kobo.51.1">Therefore, if the program has previously executed a malicious (instead of a legitimate) instruction, the probability that the next instruction executed is malicious (rather than legitimate) is equal to the following:</span></p>
<pre><span class="koboSpan" id="kobo.52.1">             Malicious  Legitimate</span><br/><br/><span class="koboSpan" id="kobo.53.1">Malicious        0.7       0.3</span><br/><br/><span class="koboSpan" id="kobo.54.1">Legitimate       0.1       0.9</span></pre>
<p><span><span class="koboSpan" id="kobo.55.1">Finally, we must assign the probability associated with the starting state of the HMM; in other words, the probability associated with the first hidden state corresponds to the probability that the first instruction executed by the program is </span><strong><span class="koboSpan" id="kobo.56.1">malicious</span></strong><span class="koboSpan" id="kobo.57.1"> or </span><strong><span class="koboSpan" id="kobo.58.1">legitimate</span></strong><span class="koboSpan" id="kobo.59.1">:</span></span></p>
<p><span class="koboSpan" id="kobo.60.1"> </span></p>
<pre><span class="koboSpan" id="kobo.61.1">Malicious        0.1 </span><br/><br/><span class="koboSpan" id="kobo.62.1">Legitimate       0.9</span></pre>
<p><span class="koboSpan" id="kobo.63.1">At this point, the task of our HMM is to identify hidden entities (in our example, if the instructions executed by the program are malicious or legitimate) based on the observation of the behavior of the machine.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">HMM example</span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">In our example, the possible observations are as follows:</span></span></p>
<pre><span class="koboSpan" id="kobo.3.1">ob_types = (‘W’,‘N’ )</span></pre>
<p><span class="koboSpan" id="kobo.4.1">Here, </span><kbd><span class="koboSpan" id="kobo.5.1">W</span></kbd><span class="koboSpan" id="kobo.6.1"> stands for Working and </span><kbd><span class="koboSpan" id="kobo.7.1">N</span></kbd><span class="koboSpan" id="kobo.8.1"> for Not Working, while the hidden states</span><span><span class="koboSpan" id="kobo.9.1"> </span></span><span><span class="koboSpan" id="kobo.10.1">are</span></span> <span><span class="koboSpan" id="kobo.11.1">as follows</span></span><span class="koboSpan" id="kobo.12.1">:</span></p>
<pre><span class="koboSpan" id="kobo.13.1">states = (‘L’, ’M')</span></pre>
<p><span class="koboSpan" id="kobo.14.1">Here, </span><kbd><span class="koboSpan" id="kobo.15.1">M</span></kbd><span class="koboSpan" id="kobo.16.1"> corresponds to Malicious and </span><kbd><span class="koboSpan" id="kobo.17.1">L</span></kbd><span class="koboSpan" id="kobo.18.1"> corresponds to Legitimate.</span></p>
<p><span class="koboSpan" id="kobo.19.1">The sequence of observations comes next, which is associated to the single instructions that get executed by the program:</span></p>
<pre><span class="koboSpan" id="kobo.20.1">observations = (‘W’,‘W’,‘W’,‘N’)</span></pre>
<p><span class="koboSpan" id="kobo.21.1">This sequence of observations tells us that after the execution of the first three instructions of the program, the machine worked properly, while it stopped working only after executing the fourth instruction.</span></p>
<p><span class="koboSpan" id="kobo.22.1">On the basis of this sequence of observable events, we must proceed with the training of the HMM. </span><span class="koboSpan" id="kobo.22.2">To this end, we will pass our probability matrices (as defined previously) to the algorithm, corresponding to the </span><kbd><span class="koboSpan" id="kobo.23.1">start</span></kbd><span class="koboSpan" id="kobo.24.1"> matrix:</span></p>
<pre><span class="koboSpan" id="kobo.25.1">start = np.matrix(‘0.1 0.9’)</span></pre>
<p><span><span class="koboSpan" id="kobo.26.1">The </span><kbd><span class="koboSpan" id="kobo.27.1">transition</span></kbd><span class="koboSpan" id="kobo.28.1"> matrix is as follows:</span></span></p>
<pre><span class="koboSpan" id="kobo.29.1">transition = np.matrix(‘0.7 0.3 ; 0.1 0.9’)</span></pre>
<p><span><span class="koboSpan" id="kobo.30.1">The </span><kbd><span class="koboSpan" id="kobo.31.1">emission</span></kbd><span class="koboSpan" id="kobo.32.1"> matrix is as follows:</span></span></p>
<pre><span class="koboSpan" id="kobo.33.1">emission = np.matrix(‘0.2 0.8 ; 0.4 0.6’)</span></pre>
<p><span><span class="koboSpan" id="kobo.34.1">The following code uses the Hidden Markov library, which is available at</span></span><span class="koboSpan" id="kobo.35.1"> </span><a href="https://github.com/rahul13ramesh/hidden_markov"><span class="koboSpan" id="kobo.36.1">https://github.com/rahul13ramesh/hidden_markov</span></a><span class="koboSpan" id="kobo.37.1">:</span><a href="https://github.com/rahul13ramesh/hidden_markov"/></p>
<pre><span class="koboSpan" id="kobo.38.1">import numpy as np</span><br/><span class="koboSpan" id="kobo.39.1">from hidden_markov import hmm</span><br/><br/><span class="koboSpan" id="kobo.40.1">ob_types = ('W','N' )</span><br/><br/><span class="koboSpan" id="kobo.41.1">states = ('L', 'M')</span><br/><br/><span class="koboSpan" id="kobo.42.1">observations = ('W','W','W','N')</span><br/><br/><span class="koboSpan" id="kobo.43.1">start = np.matrix('0.1 0.9')</span><br/><span class="koboSpan" id="kobo.44.1">transition = np.matrix('0.7 0.3 ; 0.1 0.9')</span><br/><span class="koboSpan" id="kobo.45.1">emission = np.matrix('0.2 0.8 ; 0.4 0.6')</span><br/><br/><span class="koboSpan" id="kobo.46.1">_hmm = hmm(states,ob_types,start,transition,emission)</span><br/><br/><span class="koboSpan" id="kobo.47.1">print("Forward algorithm: ")</span><br/><span class="koboSpan" id="kobo.48.1">print ( _hmm.forward_algo(observations) )</span><br/><br/><span class="koboSpan" id="kobo.49.1">print("\nViterbi algorithm: ")</span><br/><span class="koboSpan" id="kobo.50.1">print( _hmm.viterbi(observations) )</span></pre>
<p><span class="koboSpan" id="kobo.51.1">These are the results of the script:</span></p>
<pre><span class="koboSpan" id="kobo.52.1">Forward algorithm: 0.033196</span><br/><span class="koboSpan" id="kobo.53.1">Viterbi algorithm: [’M', ’M', ’M', ’M']</span></pre>
<p><span><kbd><span class="koboSpan" id="kobo.54.1">Forward algorithm</span></kbd><span class="koboSpan" id="kobo.55.1"> gives us the probability of an observed sequence in the HMM, while </span><kbd><span class="koboSpan" id="kobo.56.1">Viterbi algorithm</span></kbd><span class="koboSpan" id="kobo.57.1"> is used to find out the most likely sequence of hidden states that can generate the given set of observations.</span><br/></span></p>
<p><span class="koboSpan" id="kobo.58.1">For more information about the Hidden Markov library, please refer to the documentation available at </span><a href="http://hidden-markov.readthedocs.io/en/latest/"><span class="koboSpan" id="kobo.59.1">http://hidden-markov.readthedocs.io/en/latest/</span></a><span class="koboSpan" id="kobo.60.1">.</span><a href="http://hidden-markov.readthedocs.io/en/latest/"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Advanced malware detection with deep learning</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In the last part of the chapter, we will introduce—for the sake of completeness—some solutions of malware detection that make use of experimental methodologies based on neural networks.</span></p>
<p><span class="koboSpan" id="kobo.3.1">We will have a more in-depth look at the topic of deep learning techniques later on in </span><a href="18f56dc2-fd40-4669-bef1-0b594d9e1572.xhtml"><span class="koboSpan" id="kobo.4.1">Chapter 8</span></a><span class="koboSpan" id="kobo.5.1">, GANS – Attacks and Defenses (especially when we will talk about </span><strong><span class="koboSpan" id="kobo.6.1">Generative Adversarial Networks</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong><span class="koboSpan" id="kobo.8.1">GANs</span></strong><span class="koboSpan" id="kobo.9.1">)).</span></p>
<p><span class="koboSpan" id="kobo.10.1">Here, we will introduce the topic to show an innovative and unconventional approach to the problem of the classification of different families of malware, which makes use of deep learning algorithms developed in a completely different field of research, such as that of image recognition using </span><strong><span class="koboSpan" id="kobo.11.1">Convolutional Neural Networks</span></strong><span class="koboSpan" id="kobo.12.1"> (</span><strong><span class="koboSpan" id="kobo.13.1">CNNs</span></strong><span class="koboSpan" id="kobo.14.1">).</span></p>
<p><span class="koboSpan" id="kobo.15.1">But before going into that, let's briefly introduce </span><strong><span class="koboSpan" id="kobo.16.1">Neural Networks</span></strong><span class="koboSpan" id="kobo.17.1"> (</span><strong><span class="koboSpan" id="kobo.18.1">NNs</span></strong><span class="koboSpan" id="kobo.19.1">) and their main features in the field of malware detection.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">NNs in a nutshell</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">NNs constitute a category of algorithms that try to imitate the learning mechanisms typical of the human brain, artificially reproducing its substrate, which is constituted by neurons.</span></p>
<p><span class="koboSpan" id="kobo.3.1">There are different types of neural networks, but here we focus on two types in particular: the CNN, and the </span><strong><span class="koboSpan" id="kobo.4.1">Feedforward Networks</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong><span class="koboSpan" id="kobo.6.1">FFN</span></strong><span class="koboSpan" id="kobo.7.1">), which are the basis of CNNs; we start by describing FFNs.</span></p>
<p><span class="koboSpan" id="kobo.8.1">The FFN is composed of at least three layers of neurons, divided as follows:</span></p>
<ol>
<li class="mce-root"><span><span class="koboSpan" id="kobo.9.1">Input layer</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.10.1">Output layer</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.11.1">Hidden layer (one or more)</span></li>
</ol>
<p><span class="koboSpan" id="kobo.12.1">This layered organization of the FFN allows us to have a first layer for the management of input data, and a layer that returns the output results.</span></p>
<p><span class="koboSpan" id="kobo.13.1">The individual neurons in the various layers connect directly to the adjacent layers, while there are no connections between the neurons belonging to the same layer.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">CNNs</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A CNN is a particular type of FFN, characterized by the fact that the organization of the neuronal layers follows the same organization of the existing visual apparatus in the biological world, with the superposition of regions of neurons within the visual field.</span></p>
<p><span class="koboSpan" id="kobo.3.1">As we have said, in CNNs, each neuron is connected to a contiguous region of input neurons, in order to map the corresponding regions of pixels of an image.</span></p>
<p><span class="koboSpan" id="kobo.4.1">In this way, it is possible to identify the spatial correlations through local connectivity schemes between neurons lying on adjacent layers, which allow, for example, the identification of objects.</span></p>
<p><span class="koboSpan" id="kobo.5.1">In the CNNs, the contiguous regions of neurons are in fact organized by emulating the three-dimensional quantities of width, height, and depth, which map the corresponding characteristics of c width and height of the images, while the depth is constituted by the RGB channels.</span></p>
<p><span class="koboSpan" id="kobo.6.1">Therefore, CNNs are optimized for image recognition thanks to the convolutional layer (which, together with the pooling layer and the fully-connected layer, constitutes the three characteristic layers of such neural networks).</span></p>
<p><span class="koboSpan" id="kobo.7.1">In particular, the convolutional layer allows us to extract the relevant features of the input images through the convolution operations, which create a new image starting from the original image, by highlighting the most relevant features, and by blurring the less relevant ones; in so doing, the convolutional layer can spot similar images in spite of their actual position or orientation.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">From images to malware</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In the description that follows, we will show an alternative approach to malware detection that takes advantage of the typical skills of CNNs in image recognition. </span><span class="koboSpan" id="kobo.2.2">But in order to do this, it is first necessary to represent the executable code of the malware in the form of an image to be fed to the CNN.</span></p>
<p><span class="koboSpan" id="kobo.3.1">This approach was described in the paper entitled </span><em><span class="koboSpan" id="kobo.4.1">Towards Building an Intelligent Anti-Malware System: A Deep Learning Approach using Support Vector Machine (SVM) for Malware Classification</span></em><span class="koboSpan" id="kobo.5.1"> by Abien Fred M. </span><span class="koboSpan" id="kobo.5.2">Agarap, in which each executable malware is treated as a binary sequence of zeros and ones, which is then translated into a gray-scale image.</span></p>
<p><span class="koboSpan" id="kobo.6.1">In this way, it is possible to recognize the malware families based on the similarities in terms of layouts and textures existing in the images that represent them.</span></p>
<p><span class="koboSpan" id="kobo.7.1">To perform the classification of the images, a k-NN clustering algorithm was used, in which </span><span><span class="koboSpan" id="kobo.8.1">the Euclidean distance was</span></span><span class="koboSpan" id="kobo.9.1"> adopted as the metric used to represent the distance.</span></p>
<p><span class="koboSpan" id="kobo.10.1">The experimental results obtained showed a classification rate of 99.29%, with extremely reduced computational loads:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.11.1"><img src="assets/e55d81ff-5eac-4f88-914c-712b3ffc21ab.png"/></span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1">Image credits: Towards Building an Intelligent Anti-Malware System: A Deep Learning Approach using Support Vector Machine (SVM) for Malware Classification by Abien Fred M. </span><span class="koboSpan" id="kobo.12.2">Agarap</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Why should we use images for malware detection?</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The advantages of representing malware as images are follow ass:</span></p>
<ul>
<li class="mce-root"><span><span class="koboSpan" id="kobo.3.1">The ability to recognize specific sections of the malware code, such as those modified by malware developers in an attempt to create different variants of the original code.</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.4.1">Through the images, it is possible to identify the minor modifications intervened in the code, while preserving the overall structure of the malware image.</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.5.1">These characteristics have the consequence that the different variants of the malware belonging to the same family are easily recognizable on the basis of the similarity of the respective images that represent them. </span><span class="koboSpan" id="kobo.5.2">This is because </span><span><span class="koboSpan" id="kobo.6.1">different types of images correspond to</span></span><span class="koboSpan" id="kobo.7.1"> different families of malware.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Detecting malware from images with CNNs</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">From the original paper described previously, a tool was developed that leverages CNNs to recognize and classify the images that represent malware codes.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The tool can be downloaded from the GitHub repository, by executing the following command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.4.1">git clone https://github.com/AFAgarap/malware-classification.git/</span></strong></pre>
<p><span class="koboSpan" id="kobo.5.1">Inside the archive, there is also a dataset of images of malware codes (</span><kbd><span class="koboSpan" id="kobo.6.1">malimg.npz</span></kbd><span class="koboSpan" id="kobo.7.1">). </span><span class="koboSpan" id="kobo.7.2">To convert your malware codes to grayscale images, you can also use the Python script developed by Chiheb Chebbi, which is available at </span><a href="https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/blob/master/Chapter04/MalwareConvert.py"><span class="koboSpan" id="kobo.8.1">https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/blob/master/Chapter04/MalwareConvert.py</span></a><span class="koboSpan" id="kobo.9.1">.</span><a href="https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/blob/master/Chapter04/MalwareConvert.py"/></p>
<p><span><span class="koboSpan" id="kobo.10.1">We show some examples of the tool's usage as follows:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.11.1">Usage: main.py [-h] -m MODEL -d DATASET -n NUM_EPOCHS -c PENALTY_PARAMETER -k CHECKPOINT_PATH -l LOG_PATH -r RESULT_PATH</span></strong></pre>
<p><span><span class="koboSpan" id="kobo.12.1">To use the CNN-SVM model, set the </span><kbd><span class="koboSpan" id="kobo.13.1">-model</span></kbd><span class="koboSpan" id="kobo.14.1"> parameter to </span><kbd><span class="koboSpan" id="kobo.15.1">1</span></kbd><span class="koboSpan" id="kobo.16.1">, as in the following example:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.17.1">main.py –model 1 –dataset ./dataset/malimg.npz –num_epochs 100 –penalty_parameter 10 -c ./checkpoint/ -l ./logs/ -r ./results/</span></strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this chapter, we addressed the different strategies of malware threats detection, making use of various AI algorithms.</span></p>
<p><span class="koboSpan" id="kobo.3.1">We saw how malwares can trick the analyst, using advanced techniques such as polymorphism, forcing the adoption of algorithmic-based detection tools.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Therefore, we introduced the clustering and classification algorithms, up to the more advanced ones, which are based on HMMs and neural networks, in the form of CNNs, in order to deal with such advanced threats.</span><br/></p>
<p><span class="koboSpan" id="kobo.5.1">In the next chapter, we will deal with Network Anomalies Detection techniques that leverage Artificial Intelligence.</span></p>


            </article>

            
        </section>
    </body></html>