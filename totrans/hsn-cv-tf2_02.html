<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Computer Vision and Neural Networks</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="">In recent years, computer vision has grown into a key domain for innovation, with more and more applications reshaping businesses and lifestyles. We will start this book with a brief presentation of this field and its history so that we can get some background information. We will then introduce artificial neural networks and explain how they have revolutionized computer vision. Since we believe in learning through practice, by the end of this first chapter, we will even have implemented our own network from scratch!</span></p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li><span>Computer vision and why it is a fascinating contemporary domain</span></li>
<li>How we got there—from local hand-crafted descriptors to deep neural networks</li>
<li>Neural networks, what they actually are, and how to implement our own for a basic recognition task</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>Throughout this book, we will be using Python 3.5 (or higher). As a general-purpose programming language, Python has become the main tool for data scientists thanks to its useful built-in features and renowned libraries.</p>
<p>For this introductory chapter, we will only use two cornerstone libraries—NumPy and Matplotlib. They can be found at and installed from <a href="http://www.numpy.org/">www.numpy.org</a> and <a href="https://matplotlib.org/">matplotlib.org</a>. However, we recommend using Anaconda <span>(</span><em><span><a href="https://www.anaconda.com"/></span></em><span><a href="https://www.anaconda.com">www.anaconda.com</a></span><span>)</span>, a free Python distribution <span>that makes package management and deployment easy.</span></p>
<p>Complete installation instructions—as well as all the code presented alongside this chapter—can be found in the GitHub repository at <a href="https://github.com/PacktPublishing/Hands-On-Computer-Vision-with-TensorFlow2/tree/master/Chapter01">github.com/PacktPublishing/Hands-On-Computer-Vision-with-TensorFlow2/tree/master/Chapter01</a><span>.</span></p>
<div class="packt_infobox">We assume that our readers already have some knowledge of Python and a basic understanding of image representation (pixels, channels, and so on) and matrix manipulation (shapes, products, and so on).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Computer vision in the wild</h1>
                </header>
            
            <article>
                
<p>Computer vision is everywhere nowadays, to the point that its definition can drastically vary from one expert to another. In this introductory section, we will paint a global picture of computer vision, highlighting its domains of application and the challenges it faces.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing computer vision</h1>
                </header>
            
            <article>
                
<p>Computer vision can be hard to define because it sits at the junction of several research and development fields, such as <em>computer science</em> (algorithms, data processing, and graphics), <em>physics</em> (optics and sensors), <em>mathematics</em> (calculus and information theory), and <em>biology</em> (visual stimuli and neural processing). At its core, computer vision can be summarized as the <em>automated extraction of information from</em> <em>digital images</em>.</p>
<p>Our brain works wonders when it comes to vision. Our ability to decipher the visual stimuli our eyes constantly capture, to instantly tell one object from another, and to recognize the face of someone we have met only once, is just incredible. For computers, images are just blobs of pixels, matrices of red-green-blue values with no further meaning.</p>
<p>The goal of computer vision is to teach computers <em>how to make sense of these pixels</em> the way humans (and other creatures) do, or even better. Indeed, computer vision has come a long way and, since the rise of deep learning, it has started achieving <em>super human</em> performance in some tasks, such as face verification and handwritten text recognition.</p>
<p>With a hyper active research community fueled by the biggest IT companies, and the ever-increasing availability of data and visual sensors, more and more ambitious problems are being tackled: vision-based navigation for autonomous driving, content-based image and video retrieval, and automated annotation and enhancement, among others. It is truly an exciting time for experts and newcomers alike.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Main tasks and their applications</h1>
                </header>
            
            <article>
                
<p class="mce-root">New computer vision-based products are appearing every day (for instance, control systems for industries, interactive smartphone apps, and surveillance systems) that cover a wide range of tasks. In this section, we will go through the main ones, detailing their applications in relation to real-life problems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Content recognition</h1>
                </header>
            
            <article>
                
<p>A central goal in computer vision is to <em>make sense</em> of images, that is, to extract meaningful, semantic information from pixels (such as the objects present in images, their location, and their number). This generic problem can be divided into several sub-domains. Here is a non-exhaustive list.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object classification</h1>
                </header>
            
            <article>
                
<p class="mce-root"><strong>Object classification</strong> (or <strong>image classification</strong>) is the task of assigning proper labels (or classes) to images among a predefined set and is illustrated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fd9258d3-5f2a-4bf7-8b63-a752edc36d03.png"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.1: Example of a classifier for the labels of people and cars applied to an image set</div>
<p class="mce-root">Object classification became famous for being the first success story of deep convolutional neural networks being applied to computer vision back in 2012 (this will be presented later in this chapter). Progress in this domain has been so fast since then that super human performance is now achieved in various use cases (a well-known example is the classification of dog breeds; deep learning methods have become extremely efficient at spotting the discriminative features of man's best friend).</p>
<p>Common applications are text digitization (using character recognition) and the automatic annotation of image databases.</p>
<p>In <a href="061eb54a-4e3f-44e8-afb1-bacf796511f4.xhtml">Chapter 4</a>, <em>Influential Classification Tools</em>, we will present advanced classification methods and their impact on computer vision in general.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object identification</h1>
                </header>
            
            <article>
                
<p>While <em>object classification</em> methods assign labels from a predefined set, <em>object identification</em> (or <em>instance classification</em>) methods learn to <em>recognize specific instances of a class</em>.</p>
<p>For example, an <em>object classification</em> tool could be configured to return images containing faces, while an <em>identification</em> method would focus on the face's features to identify the person and recognize them in other images (<em>identifying</em> each face in all of the images, as shown in the following diagram):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a2479d1e-b3e6-4302-a9bb-63f142231b17.png"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.2: Example of an identifier applied to portraits</div>
<p>Therefore, object identification can be seen as a procedure to <em>cluster</em> a dataset, often applying some dataset analysis concepts (which will be presented in <a href="c4bb2429-f9f5-424d-8462-e376fd81f5a4.xhtml">Chapter 6</a>, <em>Enhancing and Segmenting Images)</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object detection and localization</h1>
                </header>
            
            <article>
                
<p>Another task is the <em>detection of specific elements in an image</em>. It is commonly applied to face detection for surveillance applications or even advanced camera apps, the detection of cancerous cells in medicine, the detection of damaged components in industrial plants, and so on.</p>
<p>Detection is often a preliminary step before further computations, providing smaller patches of the image to be analyzed separately (for instance, cropping someone's face for facial recognition, or providing a bounding box around an object to evaluate its pose for augmented reality applications), as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e667b9c5-8c1c-4fae-8e3c-dc8811da1825.png"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.3: Example of a car detector, returning bounding boxes for the candidates</div>
<p>State-of-the-art solutions will be detailed in <a href="593ada62-2ff4-4085-a15e-44f8f5e3d071.xhtml">Chapter 5</a>, <em>Object Detection Models</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object and instance segmentation</h1>
                </header>
            
            <article>
                
<p>Segmentation can be seen as a more advanced type of detection. Instead of simply providing bounding boxes for the recognized elements, segmentation methods <em>return masks labeling all the pixels</em> belonging to a specific class or to a specific instance of a class (refer to the following <em>Figure 1.4</em>). This makes the task much more complex, and actually one of the few in computer vision where deep neural networks are still far from human performance (our brain is indeed remarkably efficient at drawing the precise boundaries/contours of visual elements). Object segmentation and instance segmentation are illustrated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0918369a-e623-454c-befa-803d8424ee2a.png" style="width:51.58em;height:18.58em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.4: Comparing the results of object segmentation methods and instance segmentation methods for cars</div>
<p>In <em>Figure 1.4</em>, while the object segmentation algorithm returns a single mask for all pixels belonging to the <em>car</em> class, the instance segmentation one returns a different mask for each <em>car </em>instance that it recognized. This is a key task for robots and smart cars in order to understand their surroundings (for example, to identify all the elements in front of a vehicle), but it is also used in medical imagery. Precisely segmenting the different tissues in medical scans can enable faster diagnosis and easier visualization (such as coloring each organ differently or removing clutter from the view). This will be demonstrated in <a href="c4bb2429-f9f5-424d-8462-e376fd81f5a4.xhtml">Chapter 6</a>, <em>Enhancing and Segmenting Images</em>, with concrete experiments for autonomous driving applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pose estimation</h1>
                </header>
            
            <article>
                
<p>Pose estimation can have different meanings depending on the targeted tasks. For rigid objects, it usually means <em>the estimation of the objects' positions and orientations</em> relative to the camera in the 3D space. This is especially useful for robots so that they can interact with their environment (object picking, collision avoidance, and so on). It is also often used in augmented reality to overlay 3D information on top of objects.</p>
<p>For non-rigid elements, pose estimation can also mean <em>the estimation of the positions of their sub-parts relative to each other</em>. More concretely, when considering humans as non-rigid targets, typical applications are the recognition of human poses (standing, sitting, running, and so on) or <span>understanding </span>sign language. These different cases are illustrated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1aab463e-4e8b-4894-827c-b0cc110515b5.png" style="width:54.83em;height:19.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.5: Examples of rigid and non-rigid pose estimation</div>
<p>In both cases—that is, for whole or partial elements—the algorithms are tasked with evaluating their actual position and orientation relative to the camera in the 3D world, based on their 2D representation in an image.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Video analysis</h1>
                </header>
            
            <article>
                
<p>Computer vision not only applies to single images, but also to videos. If video streams are sometimes analyzed frame by frame, some tasks require that you consider an image sequence as a whole in order to take temporal consistency into account (this will be one of the topics of <a href="97884989-bb57-4611-8c66-ebe8ab387965.xhtml">Chapter 8</a>, <em>Video and Recurrent Neural Networks</em>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Instance tracking</h1>
                </header>
            
            <article>
                
<p>Some tasks relating video streams could naively be <span><span>accomplished </span></span>by studying each frame separately (memory less), but more efficient methods either take into account <span>differences from image to image</span> to guide the process to new frames or take complete image sequences as input for their predictions. <em>Tracking</em>, that is, <em>localizing specific elements in a video stream</em>, is a good example of such a task.</p>
<p>Tracking could be done frame by frame by applying detection and identification methods to each frame. However, it is much more efficient to use previous results to model the motion of the instances in order to partially predict their locations in future frames. <strong>Motion continuity</strong> is, therefore, a key predicate here, though it does not always hold (such as for fast-moving objects).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Action recognition</h1>
                </header>
            
            <article>
                
<p>On the other hand, <strong>action recognition</strong> belongs to the list of tasks that can only be run with a sequence of images. Similar to how we cannot understand a sentence when we are given the words separately and unordered, we cannot recognize an action without studying a continuous sequence of images (refer to <em>Figure 1.6</em>).</p>
<p>Recognizing an action means recognizing a particular motion among a predefined set (for instance, for human actions—dancing, swimming, drawing a square, or drawing a circle). Applications range from surveillance (such as the detection of abnormal or suspicious behavior) to human-machine interactions (such as for gesture-controlled devices):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cbb6ea03-2af4-4aba-abbf-b000dddf7d5a.png" style="width:26.67em;height:17.92em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.6: Is Barack Obama in the middle of waving, pointing at someone, swatting a mosquito, or something else?<br/>
Only the complete sequence of frames could help to label this action</div>
<div class="packt_infobox">Since object recognition can be split into object classification, detection, segmentation, and so on, so can action recognition (action classification, detection, and so on).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Motion estimation</h1>
                </header>
            
            <article>
                
<p>Instead of trying to recognize moving elements, some methods focus on <em>estimating the actual velocity/trajectory</em> that is captured in videos. It is also common to evaluate the motion of the camera itself relative to the represented scene (<em>egomotion</em>). This is particularly useful in the entertainment industry, for example, to capture motion in order to apply visual effects or to overlay 3D information in TV streams such as sports broadcasting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Content-aware image edition</h1>
                </header>
            
            <article>
                
<p>Besides the analysis of their content, computer vision methods can also be applied to <em>improve the images themselves</em>. More and more, basic image processing tools (such as low-pass filters for image denoising) are being replaced by <em>smarter</em> methods that are able to use prior knowledge of the image content to improve its visual quality. For instance, if a method learns what a bird typically looks like, it can apply this knowledge in order to replace noisy pixels with coherent ones in bird pictures. This concept applies to any type of image restoration, whether it be denoising, deblurring, or resolution enhancing (<em>super-resolution</em>, as illustrated in the following diagram):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/21c96ec9-8078-4c70-a912-935040d9034a.png" style="width:37.00em;height:18.00em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.7: Comparison of traditional and deep learning methods for image super-resolution. Notice how the details are sharper in the second image</div>
<p>Content-aware algorithms are also used in some photography or art applications, such as the <em>smart portrait</em> or <em>beauty</em> modes for smartphones, which aim to enhance some of the models' features, or the <em>smart removing/editing</em> tools, which get rid of unwanted elements and replace them with a coherent background.</p>
<p>In <a href="c4bb2429-f9f5-424d-8462-e376fd81f5a4.xhtml">Chapter 6</a>, <em>Enhancing and Segmenting Images</em>, and in <a href="337ec077-c215-4782-b56c-beae4d94d718.xhtml">Chapter 7</a>, <em>Training on Complex and Scarce Datasets</em>, we will demonstrate how such <em>generative</em> methods can be built and served.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scene reconstruction</h1>
                </header>
            
            <article>
                
<p>Finally, though we won't tackle it in this book, <em>scene reconstruction</em> is the task of <em>recovering the 3D geometry of a scene,</em> given one or more images. A simple example, based on human vision, is stereo matching. This is the process of finding correspondences between two images of a scene from different viewpoints in order to derive the distance of each visualized element. More advanced methods take several images and match their content together in order to obtain a 3D model of the target scene. This can be applied to the 3D scanning of objects, people, buildings, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A brief history of computer vision</h1>
                </header>
            
            <article>
                
<div class="packt_quote"><span class="ui_qtext_rendered_qtext">"Study the past if you would define the future."</span></div>
<div class="packt_quote CDPAlignRight CDPAlign"><span class="ui_qtext_rendered_qtext">– Confucius                            <br/></span></div>
<p>In order to better understand the current stand of the heart and current challenges of computer vision, we suggest that we quickly have a look at where it came from and how it has evolved in the past decades.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">First steps to initial successes</h1>
                </header>
            
            <article>
                
<p>Scientists have long dreamed of developing artificial intelligence, including <em>visual intelligence</em>. The first advances in computer vision were driven by this idea.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Underestimating the perception task</h1>
                </header>
            
            <article>
                
<p>Computer vision as a domain started as early as the 60s, among the <strong>Artificial Intelligence</strong> (<strong>AI</strong>) research community. Still heavily influenced by the <em>symbolist</em> philosophy, which considered playing chess and other purely intellectual activities the epitome of human intelligence, these researchers underestimated the complexity of <em>lower animal functions</em> such as <strong>perception</strong>. How these researchers believed they could reproduce human perception through a single summer project in 1966 is a famous anecdote in the computer vision community.</p>
<p>Marvin Minsky was one of the first to outline an approach toward building AI systems based on perception (in <em>Steps toward artificial intelligence</em>, Proceedings of the IRE, 1961). He argued that with the use of lower functions such as pattern recognition, learning, planning, and induction, it could be possible to build machines capable of solving a broad variety of problems. However, this theory was only properly explored from the 80s onward. In <em>Locomotion, Vision, and Intelligence</em> in 1984, Hans Moravec noted that our nervous system, through the process of evolution, has developed to tackle perceptual tasks (more than 30% of our brain is dedicated to vision!).</p>
<p>As he noted, even if computers are pretty good at arithmetic, they cannot compete with our perceptual abilities. In this sense, programming a computer to solve purely intellectual tasks (for example, playing chess) does not necessarily contribute to the development of systems that are intelligent in a general sense or relative to human intelligence.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hand-crafting local features</h1>
                </header>
            
            <article>
                
<p>Inspired by human perception, the basic mechanisms of computer vision are straightforward and have not evolved much since the early years—the idea is to <em>first extract meaningful features from the raw pixels</em>, and <em>then match these features to known, labeled ones</em> in order to achieve recognition.</p>
<div class="packt_infobox">In computer vision, a <strong>feature</strong> is a piece of information (often mathematically represented as a one or two-dimensional vector) that is extracted from data that is relevant to the task at hand. Features include some key points in the images, specific edges, discriminative patches, and so on. They should be easy to obtain from new images and contain the necessary information for further recognition.</div>
<p>Researchers used to come up with more and more complex features. The extraction of edges and lines was first considered for the basic geometrical understanding of scenes or for character recognition; then, texture and lighting information was also taken into account, leading to early object classifiers.</p>
<p>In the 90s, features based on statistical analysis, such as <strong>principal component analysis</strong> (<strong>PCA</strong>), were successfully applied for the first time to complex recognition problems such as face classification. A classic example is the <em>Eigenface</em> method introduced by Matthew Turk and Alex Pentland (<em>Eigenfaces for Recognition</em>, MIT Press, 1991). Given a database of face images, the mean image and the <em>eigenvectors/images</em> (also known as <strong>characteristic vectors/images</strong>) were computed through PCA. This small set of <em>eigenimages</em> can theoretically be linearly combined to reconstruct any face in the original dataset, or beyond. In other words, each face picture can be approximated through a weighted sum of the <em>eigenimages</em> (refer to <em>Figure 1.8</em>). This means that a particular face can simply be defined by the list of reconstruction weights for each <em>eigenimage</em>. As a result, classifying a new face is just a matter of decomposing it into <em>eigenimages</em> to obtain its weight vector, and then comparing it with the vectors of known faces:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ba6a5070-1243-47b6-a044-0e9a2dbc7b7a.png"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.8: Decomposition of a portrait image into the mean image and weighted sum of eigenimages. These mean and eigenimages were computed over a larger face dataset</div>
<p>Another method that appeared in the late 90s and revolutionized the domain is called <strong>Scale Invariant Feature Transform</strong> (<strong>SIFT</strong>). As its name suggests, this method, introduced by David Lowe (in <em>Distinctive Image Features from Scale-Invariant Keypoints</em>, Elsevier), represents visual objects by a set of features that are robust to changes in scale and orientation. In the simplest terms, this method looks for some <strong>key points</strong> in images (searching for discontinuities in their <em>gradient</em>), extracts a patch around each key point, and computes a feature vector for each (for example, a histogram of the values in the patch or in its gradient). The <strong>local features</strong> of an image, along with their corresponding key points, can then be used to match similar visual elements across other images. In the following image, the SIFT method was applied to a picture using OpenCV (<a href="https://docs.opencv.org/3.1.0/da/df5/tutorial_py_sift_intro.html">https://docs.opencv.org/3.1.0/da/df5/tutorial_py_sift_intro.html</a>). For each <span>localized key point, the radius of the circle represents the size of the patch considered for the feature computation, and the line shows the feature orientation (that is, the main orientation of the neighborhood's gradient):</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/69a21917-259b-4c6b-a9cb-345589cdbc4e.png" style="width:30.08em;height:22.58em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.9: Representation of the SIFT key points extracted from an image (using OpenCV)</div>
<p><span>M</span>ore advanced methods were developed over the years—with more robust ways of extracting key points, or computing and combining discriminative features—but they followed the same overall procedure (extracting features from one image, and comparing them to the features of others).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding some machine learning on top</h1>
                </header>
            
            <article>
                
<p>It soon appeared clear, however, that extracting robust, discriminative features was only half the job for recognition tasks. For instance, different elements from the same class can look quite different (such as different-looking dogs) and, as a result, share only a small set of common features. Therefore, unlike image-matching tasks, higher-level problems such as semantic classification cannot be solved by simply comparing pixel features from query images with those from labeled pictures (such a procedure can also become sub-optimal in terms of processing time if the comparison has to be done with every image from a large labeled dataset).</p>
<p>This is where <em>machine learning</em> come into play. With an increasing number of researchers trying to tackle image classification in the 90s, more statistical ways to discriminate images based on their features started to appear. <strong>Support vector machines</strong> (<strong>SVMs</strong>), which were standardized by Vladimir Vapnik and Corinna Cortes (<em>Support-vector networks</em>, Springer, 1995), were, for a long time, the default solution for learning a mapping from complex structures (such as images) to simpler labels (such as classes).</p>
<p>Given a set of image features and their binary labels (for example, <em>cat</em> or <em>not cat,</em> as illustrated in <em>Figure 1.10</em>), an SVM can be optimized to learn the function to separate one class from another, based on extracted features. Once this function is obtained, it is just a matter of applying it to the feature vector of an unknown image so that we can map it to one of the two classes (SVMs that could extend to a larger number of classes were later developed). In the following diagram, an SVM was taught to regress a linear function separating two classes based on features extracted from their images (features as vectors of only two values in this example):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6fb96b6d-1f26-491c-90c2-6b00a1362d04.png" style="width:35.42em;height:14.42em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.10: An illustration of a linear function regressed by an SVM. Note that using a concept known as the kernel trick, SVMs can also find non-linear solutions to separate classes</div>
<p class="mce-root">Other machine learning algorithms were adapted over the years by the computer vision community, such as <em>random forests</em>, <em>bags of words</em>, <em>Bayesian</em> <em>models</em>, and obviously <em>neural networks</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rise of deep learning</h1>
                </header>
            
            <article>
                
<p>So, how did neural networks take over computer vision and become what we nowadays know as <strong>deep learning</strong>? This section offers some answers, detailing the technical development of this powerful tool.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Early attempts and failures</h1>
                </header>
            
            <article>
                
<p>It may be surprising to learn that artificial neural networks appeared even before modern computer vision. Their development is the typical story of an invention too early for its time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rise and fall of the perceptron</h1>
                </header>
            
            <article>
                
<p>In the 50s, Frank Rosenblatt came up with the <strong>perceptron</strong>, a machine learning algorithm inspired by neurons and the underlying block of the first neural networks (<em>The Perceptron: A Probabilistic Model for Information Storage and Organization in the Brain</em>, American Psychological Association, 1958). With the proper learning procedure, this method was already able to recognize characters. However, the hype was short-lived. Marvin Minsky (one of the fathers of AI) and Seymor Papert quickly demonstrated that the perceptron could not learn a function as simple as <kbd>XOR</kbd> (exclusive <em>OR</em>, the function that, given two binary input values, returns <kbd>1</kbd> if one, and only one, input is <kbd>1</kbd>, and returns <kbd>0</kbd> otherwise). This makes sense to us nowadays—as the perceptron back then was modeled with a linear function while <kbd>XOR</kbd> is a non-linear one—but, at that time, it simply discouraged any further research for years.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Too heavy to scale</h1>
                </header>
            
            <article>
                
<p>It was only in the late 70s to early 80s that neural networks got some attention put back on them. Several research papers introduced how neural networks, with multiple <em>layers</em> of perceptrons put one after the other, could be trained using a rather straightforward scheme—backpropagation. As we will detail in the next section, this training procedure works by computing the network's error and backpropagating it through the layers of perceptrons to update their parameters using <em>derivatives</em>. Soon after, the first <strong>convolutional neural network</strong> (<strong>CNN</strong>), the ancestor of current recognition methods, was developed and applied to the recognition of handwritten characters with some success.</p>
<p>Alas, these methods were computationally heavy, and just could not scale to larger problems. Instead, researchers adopted lighter machine learning methods such as SVMs, and the use of neural networks stalled for another decade. So, what brought them back and led to the deep learning era we know of today?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reasons for the comeback</h1>
                </header>
            
            <article>
                
<p>The reasons for this comeback are twofold and rooted in the explosive evolution of the internet and hardware efficiency.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The internet – the new El Dorado of data science</h1>
                </header>
            
            <article>
                
<p>The internet was not only a revolution in communication; it also deeply transformed data science. It became much easier for scientists to share images and content by uploading them online, leading to the creation of public datasets for experimentation and benchmarking. Moreover, not only researchers but soon everyone, all over the world, started adding new content online, sharing images, videos, and more at an exponential rate. This started <em>big data</em> and the <em>golden age of data science</em>, with the internet as the new El Dorado.</p>
<p>By simply indexing the content that is constantly published online, image and video datasets reached sizes that were never imagined before, from <em>Caltech-101</em> (10,000 images, published in 2003 by Li Fei-Fei et al., Elsevier) to <em>ImageNet</em> (14+ million images, published in 2009 by Jia Deng et al., IEEE) or <em>Youtube-8M</em> (8+ million videos, published in 2016 by Sami Abu-El-Haija et al., including Google). Even companies and governments soon understood the numerous advantages of gathering and releasing datasets to boost innovation in their specific domains (for example, the i-LIDS datasets for video surveillance released by the British government and the COCO dataset for image captioning sponsored by Facebook and Microsoft, among others).</p>
<p>With so much data available covering so many use cases, new doors were opened (<em>data-hungry</em> algorithms, that is, methods requiring a lot of training samples to converge could finally be applied with success), and new challenges were raised (such as how to efficiently process all this information).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">More power than ever</h1>
                </header>
            
            <article>
                
<p>Luckily, since the internet was booming, so was computing power. Hardware kept becoming cheaper as well as faster, seemingly following Moore's famous law (which states that <span class="ILfuVd NA6bn">processor speeds should double every two years—this has been true for almost four decades, though a deceleration is now being observed).</span> As computers got faster, they also became better designed for computer vision. And for this, we have to thank video games.</p>
<p>The <strong>graphical processing unit</strong> (<strong>GPU</strong>) is a computer component, that is, a chip specifically designed to handle the kind of operations needed to run 3D games. Therefore, a GPU is optimized to generate or manipulate images, parallelizing these heavy matrix operations. Though the first GPUs were conceived in the 80s, they became affordable and popular only with the advent of the new millennium.</p>
<p>In 2007, NVIDIA, one of the main companies designing GPUs, released the first version of <strong>CUDA</strong>, a programming language that allows developers to directly program for compatible GPUs. <strong>OpenCL</strong>, a similar language, appeared soon after. With these new tools, people started to harness the power of GPUs for new tasks, such as machine learning and computer vision.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deep learning or the rebranding of artificial neural networks</h1>
                </header>
            
            <article>
                
<p>The conditions were finally there for data-hungry, computationally-intensive algorithms to shine. Along with <em>big data</em> and <em>cloud computing</em>, <em>deep learning</em> was suddenly everywhere.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What makes learning deep?</h1>
                </header>
            
            <article>
                
<p>Actually, the term <strong>deep learning</strong> had already been coined back in the 80s, when neural networks first began stacking two or three layers of neurons. As opposed to the early, simpler solutions, <em>deep learning</em> regroups <em>deeper</em> neural networks, that is, networks with multiple <em>hidden layers—</em><span>a</span>dditional layers set between their input and output layers. Each layer processes its inputs and passes the results to the next layer, all trained to extract increasingly abstract information. For instance, the first layer of a neural network would learn to react to basic features in the images, such as edges, lines, or color gradients; the next layer would learn to use these cues to extract more advanced features; and so on until the last layer, which infers the desired output (such as predicted class or detection results).</p>
<p>However, <em>deep learning</em> <span>only </span>really started being used from 2006, when Geoff Hinton and his colleagues proposed an effective solution to train these deeper models, one layer at a time, until reaching the desired depth (<em>A Fast Learning Algorithm for Deep Belief Nets</em>, MIT Press, 2006).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deep learning era</h1>
                </header>
            
            <article>
                
<p>With research into neural networks once again back on track, deep learning started growing, until a major breakthrough in 2012, which finally gave it its contemporary prominence. Since the publication of ImageNet, a competition (<strong>ImageNet Large Scale Visual Recognition Challenge</strong> (<strong>ILSVRC</strong>)—<a href="http://image-net.org/challenges/LSVRC/">image-net.org/challenges/LSVRC</a>) has been organized every year for researchers to submit their latest classification algorithms and compare their performance on ImageNet with others. The winning solutions in 2010 and 2011 had classification errors of 28% and 26% respectively, and applied traditional concepts such as SIFT features and SVMs. Then came the 2012 edition, and a new team of researchers reduced the recognition error to a staggering 16%, leaving all the other contestants far behind.</p>
<p>In their paper describing this achievement (<em>Imagenet Classification with Deep Convolutional Neural Networks</em>, NIPS, 2012), Alex Krizhevsky, Ilya Sutskever, and Geoff Hinton presented what would become the basis for modern recognition methods. They conceived an 8-layer neural network, later named <strong>AlexNet</strong>, with several <em>convolutional layers</em> and other modern components such as <strong>dropout</strong> and <strong>rectified linear activation units</strong> (<strong>ReLUs</strong>), which will all be presented in detail in <a href="dd1d3406-d506-4690-bf13-e5e0584ea9d1.xhtml">Chapter 3</a>, <em>Modern Neural Networks</em>, as they have became central to computer vision. More importantly, they used CUDA to implement their method so that it can be run on GPUs, finally making it possible to train deep neural networks in a reasonable time, iterating over datasets as big as ImageNet.</p>
<p>That same year, Google demonstrated how advances in <strong>cloud computing</strong> could also be applied to computer vision. Using a dataset of 10 million random images extracted from YouTube videos, they taught a neural network to identify images containing cats and parallelized the training process over 16,000 machines to finally double the accuracy compared to previous methods.</p>
<p>And so started the deep learning era we are currently in. Everyone jumped on board, coming up with deeper and deeper models, more advanced training schemes, and lighter solutions for portable devices. It is an exciting period, as the more efficient deep learning solutions become, the more people try to apply them to new applications and domains. With this book, we hope to convey some of this current enthusiasm and provide you with an overview of the modern methods and how to develop solutions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with neural networks</h1>
                </header>
            
            <article>
                
<p>By now, we know that neural networks form the core of deep learning and are powerful tools for modern computer vision. But what are they exactly? How do they work? In the following section, not only will we tackle the theoretical explanations behind their efficiency, but we will also directly apply this knowledge to the implementation and application of a simple network to a recognition task.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a neural network</h1>
                </header>
            
            <article>
                
<p class="mce-root"><strong>Artificial neural networks</strong> (<strong>ANNs</strong>), or simply <strong>neural networks</strong> (<strong>NNs</strong>), are powerful machine learning tools that are excellent at processing information, recognizing usual patterns or detecting new ones, and approximating complex processes. They have to thank their structure for this, which we will now explore.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Imitating neurons</h1>
                </header>
            
            <article>
                
<p>It is well-known that neurons are the elemental supports of our thoughts and reactions. What might be less evident is how they actually work and how they can be simulated.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Biological inspiration</h1>
                </header>
            
            <article>
                
<p>ANNs are loosely inspired by how animals' brains work. Our brain is a complex network of neurons, each passing information to each other and processing sensory inputs (as electrical and chemical signals) into thoughts and actions. Each neuron receives its electrical inputs from its <em>dendrites</em>, which are cell fibers that propagate the electrical signal from the <em>synapses</em> (the junctions with preceding neurons) to the <em>soma</em> (the neuron's main body). If the accumulated electrical stimulation exceeds a specific threshold, the cell is <em>activated</em> and the electrical impulse is <em>propagated further</em> to the next neurons through the cell's <em>axon</em> (the neuron's <em>output cable</em>, ending with several synapses linking to other neurons). Each neuron can, therefore, be seen as a really <em>simple signal processing unit</em>, which—once stacked together—can achieve the thoughts we are having right now, for instance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mathematical model</h1>
                </header>
            
            <article>
                
<p>Inspired by its biological counterpart (represented in <em>Figure 1.11</em>), the artificial neuron takes several <em>inputs</em> (each a number), sums them together, and finally applies an <em>activation function</em> to obtain the <em>output</em> signal, which can be passed to the following neurons in the network (this can be seen as a directed graph):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ff29311c-b8a5-44cb-9823-92c9c8475829.png" style="width:41.50em;height:29.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.11: On the left, we can see a simplified biological neuron. On the right, we can see its artificial counterpart</div>
<p class="CDPAlignLeft CDPAlign">The summation of the inputs is usually done in a weighted way. Each <strong>input</strong> is scaled up or down, depending on a weight specific to this particular <strong>input</strong>. These <em>weights</em> are the parameters that are adjusted during the training phase of the network in order for the neuron to react to the correct features. Often, another parameter is also trained and used for this summation process—the neuron's <em>bias</em>. Its value is simply added to the weighted sum as an <em>offset</em>.</p>
<p class="CDPAlignLeft CDPAlign">Let's quickly formalize this process mathematically. Suppose we have a neuron that takes two input values, <em>x</em><sub>0</sub> and <em>x</em><sub>1</sub>. Each of these values would be weighted by a factor, <em>w</em><sub>0</sub> and <em>w</em><sub>1</sub>, respectively, before being summed together, with an optional bias, <em>b</em>. For simplification, we can express the input values as a horizontal vector, <em>x</em>, and the weights as a vertical vector, <em>w</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/194aefc5-8738-44ff-a5e0-8c475607c401.png" style="width:16.17em;height:3.58em;"/></p>
<p>With this formulation, the whole operation can simply be expressed as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/5932c702-38e9-4f57-a380-52fc732f36ee.png" style="width:7.58em;height:1.33em;"/></p>
<p>This step is straightforward, isn't it? The <em>dot product</em> between the two vectors takes care of the weighted summation:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/ad4c7615-419e-47dd-857c-b5a2c17fe3d7.png" style="width:19.25em;height:3.25em;"/></p>
<p>Now that the inputs have been scaled and summed together into the result, <em>z</em>, we have to apply the <em>activation function</em> to it in order to get the neuron's output. If we go back to the analogy with the biological neuron, its activation function would be a binary function such as <em>if</em> <em>y</em> <em>is above a threshold</em> <em>t</em><em>, return an electrical impulse that is 1, or else return 0</em> (with <em>t</em> = 0 usually). If we formalize this, the activation function, <em>y</em> = <em>f</em>(<em>z</em>), can be expressed as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/49c11b52-fdff-4288-aa93-f9a6d7ff217e.png" style="width:13.25em;height:3.33em;"/></p>
<p>The <strong>step function</strong> is a key component of the original perceptron, but more advanced activation functions have been introduced since then with more advantageous properties, such as <em>non-linearity</em> (to model more complex behaviors) and <em>continuous differentiability</em> (important for the training process, which we will explain later). The most common activation functions are as follows:</p>
<ul>
<li>The <strong>sigmoid</strong> function,  <img class="fm-editor-equation" src="assets/16c9208a-00ed-4907-90cf-58e1032b1ec5.png" style="width:8.92em;height:3.08em;"/> (with 𝑒 the exponential function)</li>
<li>The <strong>hyperbolic tangent</strong>, <img class="fm-editor-equation" src="assets/d24e0919-a1ab-4c88-b522-585dfcc8e905.png" style="width:11.17em;height:3.08em;"/></li>
<li>The <strong>REctified Linear Unit </strong>(<strong>ReLU</strong>),  <img class="fm-editor-equation" src="assets/9a4211de-d66d-4c68-b300-67c9e81acca8.png" style="width:18.58em;height:3.00em;"/></li>
</ul>
<p>Plots of the aforementioned common activation functions are shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c243ef46-fa4e-453b-8d4c-fc1c89efff73.png"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.12: Plotting common activation functions</div>
<p>In any case, that's it! We have modeled a simple artificial neuron. It is able to receive a signal, process it, and output a value that can be <em>forwarded</em> (a term that is commonly used in machine learning) to other neurons, building a network.</p>
<div class="packt_infobox">Chaining neurons with no non-linear activation functions would be equivalent to having a single neuron. For instance, if we had a linear neuron with parameters <em>w</em><sub><em>A</em></sub> and <em>b</em><sub><em>A</em></sub> followed by a linear neuron with parameters <em>w</em><sub><em>B</em></sub> and <em>b</em><sub><em>B</em></sub>, then <img class="fm-editor-equation" src="assets/b218a0de-15c0-4dc1-8be8-36f0cf1e1015.png" style="width:30.42em;height:1.50em;"/>, where <em>w</em> = <em>w</em><sub><em>A</em><em><sup><img class="fm-editor-equation" src="assets/7d79fcb3-e427-486e-9eef-3060c702b2c1.png" style="width:0.42em;height:0.58em;"/></sup></em></sub><em>w</em><sub><em>B</em></sub> and <em>b</em> =<sub> </sub><em>b</em><sub><em>A</em></sub> + <em>b</em><sub><em>B</em></sub>. Therefore, non-linear activation functions are a necessity if we want to create complex models.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementation</h1>
                </header>
            
            <article>
                
<p>Such a model can be implemented<span> really easily </span>in Python (using NumPy for vector and matrix manipulations):</p>
<pre><span>import </span>numpy <span>as </span>np<br/><br/><span>class </span>Neuron(<span>object</span>):<br/>    <span>"""</span><span>A simple feed-forward artificial neuron.<br/></span><span>    Args:<br/></span><span>        num_inputs (int): The input vector size / number of input values.<br/></span><span>        activation_fn (callable): The activation function.<br/></span><span>    Attributes:<br/></span><span>        W (ndarray): The weight values for each input.<br/></span><span>        b (float): The bias value, added to the weighted sum.<br/></span><span>        activation_fn (callable): The activation function.<br/></span><span>    """</span><span><br/></span><span>    </span><span>def </span><span>__init__</span>(<span>self</span><span>, </span>num_inputs<span>, </span>activation_fn):<br/>        <span>super</span>().<span>__init__</span>()<br/>        <span># Randomly initializing the weight vector and bias value:<br/></span><span>        </span><span>self</span>.W = np.random.rand(num_inputs)<br/>        <span>self</span>.b = np.random.rand(<span>1</span>)<br/>        <span>self</span>.activation_fn = activation_fn<br/><br/>    <span>def </span><span>forward</span>(<span>self</span><span>, </span>x):<br/>        <span>"""Forward the input signal through the neuron."""<br/></span><span>        </span>z = np.dot(x<span>, </span><span>self</span>.W) + <span>self</span>.b<br/>        <span>return </span><span>self</span>.activation_function(z)</pre>
<p>As we can see, this is a direct adaptation of the mathematical model we defined previously. Using this artificial neuron is just as straightforward. Let's instantiate a perceptron (a neuron with the step function for the activation method) and forward a random input through it:</p>
<pre># Fixing the random number generator's seed, for reproducible results:<br/>np.random.seed(<span>42</span>)<span><br/></span><span># Random input column array of 3 values (shape = `(1, 3)`)<br/></span>x = np.random.rand(<span>3</span>).reshape(<span>1</span><span>, </span><span>3</span>)<span><br/></span><span># &gt; [[0.37454012 0.95071431 0.73199394]]<br/></span><span><br/></span><span># Instantiating a Perceptron (simple neuron with step function):<br/></span>step_fn = <span>lambda </span>y: <span>0 </span><span>if </span>y &lt;= <span>0 </span><span>else </span><span>1</span><span><br/></span>perceptron = Neuron(<span>num_inputs</span>=x.size<span>, </span><span>activation_fn</span>=step_fn)<br/><span># &gt; perceptron.weights    = [0.59865848 0.15601864 0.15599452]<br/></span><span># &gt; perceptron.bias       = [0.05808361]<br/></span><span><br/></span>out = perceptron.forward(x)<br/><span># &gt; 1</span></pre>
<p>We suggest that you take some time and experiment with different inputs and neuron parameters before we scale up their dimensions in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Layering neurons together</h1>
                </header>
            
            <article>
                
<p>Usually, neural networks are organized into <em>layers</em>, that is, sets of neurons that typically receive the same input and apply the same operation (for example, by applying the same activation function, though each neuron first sums the inputs with its own specific weights).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mathematical model</h1>
                </header>
            
            <article>
                
<p>In networks, the information flows from the input layer to the output layer, with one or more <em>hidden</em> layers in-between. In <em>Figure 1.13</em>, the three neurons <strong>A</strong>, <strong>B</strong>, and <strong>C</strong> belong to the input layer, the neuron <strong>H</strong> belongs to the output or activation layer, and the neurons <strong>D</strong>, <strong>E</strong>, <strong>F</strong>, and <strong>G</strong> belong to the hidden layer. The first layer has an input, <em>x</em>, of size 2, the second (hidden) layer takes the three activation values of the previous layer as input, and so on. Such layers, with each neuron connected to all the values from the previous layer, are classed as being <strong>fully connected</strong> or <strong>dense</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e5d3267d-951a-46f0-b216-9823d147580a.png" style="width:24.33em;height:17.33em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.13: A 3-layer neural network, with two input values and one final output</div>
<p>Once again, we can compact the calculations by representing these elements with vectors and matrices. The following operations are done by the first layers:</p>
<p style="padding-left: 210px"><img src="assets/f948048e-840f-4561-bd3c-4691966f767c.png" style="width:10.83em;height:5.00em;"/></p>
<p>This can be expressed as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/b712dec9-383e-46af-a7dc-bcb79e7928d7.png" style="width:8.00em;height:1.33em;"/></p>
<p>In order to obtain the previous equation, we must define the variables as follows:</p>
<p style="padding-left: 30px"><img src="assets/29647de3-3ec2-48f8-b302-dbe8963eaa8b.png" style="width:43.92em;height:5.58em;"/></p>
<p>The activation of the first layer can, therefore, be written as a vector, <img class="fm-editor-equation" src="assets/20f4ff4b-4c6c-4e71-8e39-692e6e3fe7d7.png" style="width:17.00em;height:1.33em;"/>, which can be directly passed as an input vector to the next layer, and so on until the last layer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementation</h1>
                </header>
            
            <article>
                
<p>Like the single neuron, this model can be implemented in Python. Actually, we do not even have to make too many edits compared to our <kbd>Neuron</kbd> class:</p>
<pre><span>import </span>numpy <span>as </span>np<br/><br/><span>class </span>FullyConnectedLayer(<span>object</span>):<br/>    <span>"""A simple fully-connected NN layer.<br/></span><span>    Args:<br/></span><span>        num_inputs (int): The input vector size/number of input values.<br/></span><span>        layer_size (int): The output vector size/number of neurons.<br/></span><span>        activation_fn (callable): The activation function for this layer.<br/></span><span>    Attributes:<br/></span><span>        W (ndarray): The weight values for each input.<br/></span><span>        b (ndarray): The bias value, added to the weighted sum.<br/></span><span>        size (int): The layer size/number of neurons.<br/></span><span>        activation_fn (callable): The neurons' activation function.</span><span><br/></span><span>    """</span><span><br/></span><span>    </span><span>def </span><span>__init__</span>(<span>self</span><span>, </span>num_inputs<span>, </span>layer_size<span>, </span>activation_fn):<br/>        <span>super</span>().<span>__init__</span>()<br/>        <span># Randomly initializing the parameters (using a normal distribution this time):<br/></span><span>        </span><span>self</span>.W = np.random.standard_normal((num_inputs<span>, </span>layer_size))<br/>        <span>self</span>.b = np.random.standard_normal(layer_size)<br/>        <span>self</span>.size = layer_size<br/>        <span>self</span>.activation_fn = activation_fn<span><br/></span><span><br/></span><span>    def </span><span>forward</span>(<span>self</span><span>, </span>x):<br/>        <span>"""</span><span>Forward the input signal through the layer.</span><span>"""<br/></span><span>        </span>z = np.dot(x<span>, </span><span>self</span>.W) + <span>self</span>.b<br/>        return <span>self</span>.activation_fn(z)</pre>
<p class="mce-root"/>
<p>We just have to change the <em>dimensionality</em> of some of the variables in order to reflect the multiplicity of neurons inside a layer. With this implementation, our layer can even process several inputs at once! Passing a single column vector <em>x</em> (of shape 1 <span class="js-about-item-abstr">×</span> <em>s</em> with <em>s</em> number of values in <em>x</em>) or a stack of column vectors (of shape <em>n</em> <span class="js-about-item-abstr">×</span> <em>s</em> with <em>n</em> number of samples) does not change anything with regard to our matrix calculations, and our layer will correctly output the stacked results (assuming <em>b</em> is added to each row):</p>
<pre>np.random.seed(<span>42</span>)<span><br/># Random input column-vectors of 2 values (shape = `(1, 2)`):<br/></span>x1 = np.random.uniform(-<span>1</span><span>, </span><span>1</span><span>, </span><span>2</span>).reshape(<span>1</span><span>, </span><span>2</span>)<br/><span># &gt; [[-0.25091976  0.90142861]]<br/></span>x2 = np.random.uniform(-<span>1</span><span>, </span><span>1</span><span>, </span><span>2</span>).reshape(<span>1</span><span>, </span><span>2</span>)    <span><br/></span><span># &gt; [[0.46398788 0.19731697]]<br/></span><span><br/></span>relu_fn = <span>lambda </span>y: np.maximum(y<span>, </span><span>0</span>)    <span># Defining our activation function</span><span><br/></span>layer = FullyConnectedLayer(<span>2</span><span>, </span><span>3</span><span>, </span>relu_fn)<br/><br/><span># Our layer can process x1 and x2 separately...<br/></span>out1 = layer.forward(x1)<br/><span># &gt; [[0.28712364 0.         0.33478571]]<br/></span>out2 = layer.forward(x2)<br/><span># &gt; [[0.         0.         1.08175419]]</span><span><br/></span><span># ... or together:<br/></span>x12 = np.concatenate((x1<span>, </span>x2))  <span># stack of input vectors, of shape `(2, 2)`<br/></span>out12 = layer.forward(x12)<br/><span># &gt; [[0.28712364 0.         0.33478571]<br/></span><span>#    [0.         0.         1.08175419]]<br/></span></pre>
<div class="packt_infobox">A stack of input data is commonly called a <strong>batch</strong>.</div>
<p>With this implementation, it is now just a matter of chaining fully connected layers together to build simple neural networks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applying our network to classification</h1>
                </header>
            
            <article>
                
<p>We know how to define layers, but have yet to initialize and connect them into networks for computer vision. To demonstrate how to do this, we will tackle a famous recognition task.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the task</h1>
                </header>
            
            <article>
                
<p>Classifying images of handwritten digits (that is, recognizing whether an image contains a <kbd>0</kbd> or a <kbd>1</kbd> and so on) is a historical problem in computer vision. The <strong>Modified National Institute of Standards and Technology</strong> (<strong>MNIST</strong>) dataset (<a href="http://yann.lecun.com/exdb/mnist/">http://yann.lecun.com/exdb/mnist/</a>), which contains 70,000 grayscale images (<em>28 <span class="js-about-item-abstr">×</span> 28</em> pixels) of such digits, has been used as a reference over the years so that people can test their methods for this recognition task (Yann LeCun and Corinna Cortes hold all copyrights for this dataset, which is shown in the following diagram):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9c1f9cf5-56a6-4297-b1e9-42b757bced01.png" style="width:17.17em;height:17.25em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.14: Ten samples of each digit from the MNIST dataset</div>
<p>For digit classification, what we want is a network that takes one of these images as input and returns an output vector expressing <em>how strongly the network believes the image corresponds to each class</em>. The input vector has <em>28 × 28 = 784</em> values, while the output has 10 values (for the 10 different digits, from <kbd>0</kbd> to <kbd>9</kbd>). In-between all of this, it is up to us to define the number of hidden layers and their sizes. To predict the class of an image, it is then just a matter of <em>forwarding the image vector through the network, collecting the output</em>, and <em>returning the class with the highest belief score</em>.</p>
<div class="packt_tip">These <em>belief</em> scores are commonly transformed into probabilities to simplify further computations or the interpretation. For instance, let's suppose that a classification network gives a score of 9 to the class <em>dog</em>, and a score of 1 to the other class, <em>cat</em>. This is equivalent to saying that <em>according to this network, there is a 9/10 probability that the image shows a dog and a 1/10 probability it shows a cat</em>.</div>
<p>Before we implement a solution, let's prepare the data by loading the MNIST data for training and testing methods. For simplicity, we will use the <kbd>mnist</kbd> <span>Python module</span> (<a href="https://github.com/datapythonista/mnist">https://github.com/datapythonista/mnist</a>), which was developed by Marc Garcia (under the BSD 3-Clause <em>New</em> or <em>Revised</em> license, and is already installed in this chapter's source directory):</p>
<pre><span>import </span>numpy <span>as </span>np<br/><span>import </span>mnist<br/>np.random.seed(<span>42</span>)<br/><br/><span># Loading the training and testing data:<br/></span>X_train<span>, </span>y_train = mnist.train_images()<span>, </span>mnist.train_labels()<br/>X_test<span>,  </span>y_test  = mnist.test_images()<span>, </span>mnist.test_labels()<br/>num_classes = <span>10    </span><span># classes are the digits from 0 to 9</span><span><br/></span><span><br/></span><span># We transform the images into column vectors (as inputs for our NN):<br/></span>X_train<span>, </span>X_test = X_train.reshape(-<span>1</span><span>, </span><span>28</span>*<span>28</span>)<span>, </span>X_test.reshape(-<span>1</span><span>, </span><span>28</span>*<span>28</span>)<br/># We "one-hot" the labels (as targets for our NN), for instance, transform label `4` into vector `[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]`:<br/>y_train = np.eye(num_classes)[y_train]</pre>
<div class="mce-root packt_tip">More detailed operations for the preprocessing and visualization of the dataset can be found in this chapter's source code.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the network</h1>
                </header>
            
            <article>
                
<p>For the neural network itself, we have to wrap the layers together and add some methods to forward through the complete network and to predict the class according to the output vector. After the layer's implementation, the following code should be self-explanatory:</p>
<pre><span>import </span>numpy <span>as </span>np<br/><span>from </span>layer <span>import </span>FullyConnectedLayer<br/><br/>def sigmoid(x): # Apply the sigmoid function to the elements of x.<br/>    return 1 / (1 + np.exp(-x)) # y<br/><br/><span>class </span>SimpleNetwork(<span>object</span>):<br/>    <span>"""A simple fully-connected NN.<br/></span><span>    Args:<br/></span><span>        num_inputs (int): The input vector size / number of input values.<br/></span><span>        num_outputs (int): The output vector size.<br/></span><span>        hidden_layers_sizes (list): A list of sizes for each hidden layer to be added to the network<br/></span><span>    Attributes:<br/></span><span>        layers (list): The list of layers forming this simple network.</span><span><br/></span><span>    """<br/></span><span><br/></span><span>    </span><span>def </span><span>__init__</span>(<span>self</span><span>, </span>num_inputs<span>, </span>num_outputs<span>, </span>hidden_layers_sizes=(<span>64</span><span>, </span><span>32</span>)):<br/>        <span>super</span>().<span>__init__</span>()<br/>        <span># We build the list of layers composing the network:<br/></span><span>        </span>sizes = [num_inputs<span>, </span>*hidden_layers_sizes<span>, </span>num_outputs]<br/>        <span>self</span>.layers = [<br/>            FullyConnectedLayer(sizes[i]<span>, </span>sizes[i + <span>1</span>]<span>, sigmoid</span>)<br/>            <span>for </span>i <span>in </span><span>range</span>(<span>len</span>(sizes) - <span>1</span>)]<br/><br/>    <span>def </span><span>forward</span>(<span>self</span><span>, </span>x):<br/>        <span>"""Forward the input vector `x` through the layers."""<br/></span><span>        </span><span>for </span>layer <span>in </span><span>self</span>.layers:<span> # from the input layer to the output one<br/></span><span>            </span>x = layer.forward(x)<br/>        <span>return </span>x<br/><br/>    <span>def </span><span>predict</span>(<span>self</span><span>, </span>x):<br/>        <span>"""Compute the output corresponding to `x`, and return the index of the largest output value"""<br/></span><span>        </span>estimations = <span>self</span>.forward(x)<br/>        best_class = np.argmax(estimations)<br/>        <span>return </span>best_class<br/><br/>    <span>def </span><span>evaluate_accuracy</span>(<span>self</span><span>, </span>X_val<span>, </span>y_val):<br/>        <span>"""Evaluate the network's accuracy on a validation dataset."""<br/></span><span>        </span>num_corrects = <span>0<br/></span><span>        </span><span>for </span>i <span>in </span><span>range</span>(<span>len</span>(X_val)):<br/>            <span>if </span>self.predict(X_val[i]) == y_val[i]:<br/>                num_corrects += <span>1<br/></span><span>        </span><span>return </span>num_corrects / <span>len</span>(X_val)</pre>
<p>We just implemented a feed-forward neural network that can be used for classification! It is now time to apply it to our problem:</p>
<pre><span># Network for MNIST images, with 2 hidden layers of size 64 and 32:<br/></span>mnist_classifier = SimpleNetwork(X_train.shape[<span>1</span>]<span>, </span>num_classes<span>, </span>[<span>64</span><span>, </span><span>32</span>])<span><br/></span><span><br/></span><span># ... and we evaluate its accuracy on the MNIST test set:<br/></span>accuracy = mnist_classifier.evaluate_accuracy(X_test<span>, </span>y_test)<span><br/></span><span>print</span>(<span>"accuracy = {:.2f}%"</span>.format(accuracy * <span>100</span>))<br/># &gt; accuracy = 12.06%</pre>
<p>We only got an accuracy of ~12.06%. This may look disappointing since it is an accuracy that's barely better than random guessing. But it makes sense—right now, our network is defined by random parameters. We need to train it according to our use case, which is a task that we will tackle in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Training a neural network</h1>
                </header>
            
            <article>
                
<p><strong>Neural networks</strong> are a particular kind of algorithm because they need to be <em>trained</em>, that is, their parameters need to be optimized for a specific task by making them learn from available data. Once the networks are optimized to perform well on this <em>training dataset</em>, they can be used on new, similar data to provide satisfying results (if the training was done properly).</p>
<p>Before solving the problem of our MNIST task, we will provide some theoretical background, cover different learning strategies, and present how training is actually done. Then, we will directly apply some of these notions to our example so that our simple network finally learns how to solve the recognition task!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning strategies</h1>
                </header>
            
            <article>
                
<p class="mce-root">When it comes to teaching neural networks, there are three main paradigms, depending on the task and the availability of training data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Supervised learning</h1>
                </header>
            
            <article>
                
<p class="mce-root"><em>Supervised learning</em> may be the most common paradigm, and it is certainly the easiest to grasp. It applies when we want to <em>teach neural networks a mapping between two modalities</em> (for example, mapping images to their class labels or to their semantic masks). It requires access to a training dataset containing both the <em>images</em> and their <em>ground truth labels</em> (such as the class information per image or the semantic masks).</p>
<p>With this, the training is then straightforward:</p>
<ul>
<li>Give the images to the network and collect its results (that is, predicted labels).</li>
<li>Evaluate the network's <em>loss</em>, that is, how wrong its predictions are when comparing it to the ground truth labels.</li>
<li>Adjust the network parameters accordingly to reduce this loss.</li>
<li>Repeat until the network <em>converges,</em> that is, until it cannot improve further on this training data.</li>
</ul>
<p class="mce-root">Therefore, this strategy deserves the adjective <em>supervised—</em>an entity (us) supervises the training of the network by providing it with feedback for each prediction (the loss computed from the ground truths) so that the method can learn by repetition (<em>it was correct/false</em>; <em>try again</em>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unsupervised learning</h1>
                </header>
            
            <article>
                
<p>However, how do we train a network when we do not have any ground truth information available? <em>Unsupervised learning</em> is one answer to this. The idea here is to craft a function that <em>computes the network's loss only based on its input and its corresponding output</em>.</p>
<p>This strategy applies very well to applications such as clustering (grouping images with similar properties together) or compression (reducing the content size while preserving some properties). For clustering, the loss function could measure how similar images from one cluster are compared to images from other clusters. For compression, the loss function could measure how well preserved the important properties are in the compressed data compared to the original ones.</p>
<p>Unsupervised learning thus requires some <em>expertise</em> regarding the use cases so that we can come up with meaningful loss functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reinforcement learning</h1>
                </header>
            
            <article>
                
<p class="mce-root"><em>Reinforcement learning</em> is an <strong>interactive strategy</strong>. An <em>agent</em> navigates through an <em>environment</em> (for example, a robot moving around a room or a video game character going through a level). The agent has a predefined list of actions it can make (<em>walk</em>, <em>turn</em>, <em>jump</em>, and so on) and, after each action, it ends up in a new <em>state</em>. Some states can bring <em>rewards</em>, which are immediate or delayed, and positive or negative (for instance, a positive reward when the video game character touches a bonus item, and a negative reward when it is hit by an enemy). </p>
<p class="mce-root">At each instant, the neural network is provided only with <em>observations</em> from the environment (for example, the robot's visual feed, or the video game screen) and reward feedback (the <em>carrot and stick</em>). From this, it has to learn what brings higher rewards and <em>estimate the best short-term or long-term policy for the agent</em> accordingly. In other words, it has to estimate the series of actions that would maximize its end reward.</p>
<p>Reinforcement learning is a powerful paradigm, but it is less commonly applied to computer vision use cases. It won't be presented further here, though we encourage machine learning enthusiasts to learn more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Teaching time</h1>
                </header>
            
            <article>
                
<p>Whatever the learning strategy, the overall training steps are the same. Given some training data, the network makes its predictions and receives some feedback (such as the results of a loss function), which is then used to update the network's parameters. These steps are then repeated until the network cannot be optimized further. In this section, we will detail and implement this process, from loss computation to weights optimization.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Evaluating the loss</h1>
                </header>
            
            <article>
                
<p>The goal of the <em>loss function</em> is to evaluate how well the network, with its current weights, is performing. More formally, this function expresses the <em>quality of the predictions as a function of the network's parameters</em> (such as its weights and biases). The smaller the loss, the better the parameters are for the chosen task.</p>
<p>Since loss functions represent the goal of networks (<em>return the correct labels</em>, <em>compress the image while preserving the content</em>, and so on), there are as many different functions as there are tasks. Still, some loss functions are more commonly used than others. This is the case for the <em>sum-of-squares</em> function, also called <strong>L2 loss</strong> (based on the L2 norm), which is omnipresent in supervised learning. This function simply computes the squared difference between each element of the output vector <em>y</em> (the per-class probabilities estimated by our network) and each element of the ground truth vector <em>y<sup>true</sup></em> (the target vector with null values for every class but the correct one):</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/0e0dfbfc-c782-426c-a6fe-76401aa59515.png" style="width:18.00em;height:3.25em;"/></p>
<p>There are plenty of other losses with different properties, such as <strong>L1 loss</strong>, which computes the <em>absolute difference</em> between the vectors, or <strong>binary cross-entropy</strong> (<strong>BCE</strong>) loss, which converts the predicted probabilities into a logarithmic scale before comparing them to the expected values:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/e5968b1f-69bc-4df1-bae3-7981bc4fd5f7.png" style="width:58.75em;height:3.25em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<div class="packt_infobox">The logarithmic operation converts the probabilities from [0, 1] into [-<img class="fm-editor-equation" src="assets/e7bf8923-5c1e-4e3d-bc50-0f943f7d31e7.png" style="width:1.42em;height:0.83em;"/>, 0]. So, by multiplying the results by -1, the loss value moves from +<img class="fm-editor-equation" src="assets/edb35237-2b09-485c-84e3-05e05cf4f2ba.png" style="width:1.42em;height:0.83em;"/>  to 0 as the neural network learns to predict properly. Note that the cross-entropy function can also be applied to multi-class problems (not just binary).<br/>
<br/>
It is also common for people to divide the losses by the number of elements in the vectors, that is, computing the mean instead of the sum. The <strong>mean square error</strong> (<strong>MSE</strong>) is the averaged version of the L2 loss, and the <strong>mean absolute error</strong> (<strong>MAE</strong>) is the average version of the L1 loss.</div>
<p>For now, we will stick with the L2 loss as an example. We will use it for the rest of the theoretical explanations, as well as to train our MNIST classifier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Backpropagating the loss</h1>
                </header>
            
            <article>
                
<p>How can we update the network parameters so that they minimize the loss? For each parameter, what we need to know is how slightly changing its value would affect the loss. If we know which changes would slightly decrease the loss, then it is just a matter of applying these changes and repeating the process until reaching a minimum. This is exactly what the <em>gradient</em> of the loss function expresses, and what the <em>gradient descent</em> process is.</p>
<p>At each training iteration, the derivatives of the loss with respect to each parameter of the network are computed. These derivatives indicate which small changes to the parameters need to be applied (with a -1 coefficient since the gradient indicates the direction of increase of the function, while we want to minimize it). It can be seen as walking step by step down the <em>slope</em> of the loss function with respect to each parameter, hence the name <strong>gradient descent</strong> for this iterative process (refer to the following diagram):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2cec2eab-f584-4603-a985-15aa12a040ba.png" style="width:36.17em;height:15.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1.15: Illustrating the gradient descent to optimize a parameter <em>P</em> of the neural network</div>
<p>The question now is, how can we compute all of these derivatives (the <em>slope</em> values as a function of each parameter)? This is where the <strong>chain rule</strong> comes to our aid. Without going too deep into calculus, the chain rule tells us that the derivatives <span>with respect to</span> the parameters of a layer, <em>k</em>, can be <em>simply</em> computed with the input and output values of that layer (<em>x</em><sub><em>k</em></sub>, <em>y</em><sub><em>k</em></sub>), and the derivatives of the following layer, <em>k</em> + 1. More formally, for the layer's weights, <em>W</em><sub><em>k</em></sub>, we have the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/aa5594e4-861d-4262-bf99-d7a22d877e22.png" style="width:66.33em;height:3.50em;"/></p>
<p class="CDPAlignLeft CDPAlign">Here, <em>l</em>'<sub><em>k</em>+1</sub> is the derivative that is computed for layer <em>k</em> + 1 <span>with respect to</span> its input, <em>x</em><sub><em>k</em>+1</sub> = <em>y</em><sub><em>k</em></sub>, with <em>f</em>'<sub><em>k</em></sub> being the derivative of the layer's activation function, and <img class="fm-editor-equation" src="assets/8df72250-938a-4586-a84c-345f20534504.png" style="width:1.50em;height:1.25em;"/> being the <em>transpose</em> of <em>x</em>. Note that <em>z</em><sub><em>k</em></sub> represents the result of the weighted sum performed by the layer <em>k</em> (that is, before the input of the layer's activation function), as defined in the <em>Layering neurons together </em><span>section</span>. Finally, the <img class="fm-editor-equation" src="assets/48ca7008-9ba0-43bc-b7b1-f6e517d07566.png" style="width:1.08em;height:1.08em;"/> symbol represents the <em>element-wise multiplication</em> between two vectors/matrices. It is also known as the <em>Hadamard product</em>. As shown in the following equation, it basically consists of multiplying the elements pair-wise:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/b9c4ac95-ae33-4c81-be83-e8d48a69ace1.png" style="width:22.83em;height:2.83em;"/></p>
<p>Back to the chain rule, the derivatives with respect to the bias can be computed in a similar fashion, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/8970bce6-2446-4d8f-9913-4df643ef4a6e.png" style="width:32.67em;height:2.67em;"/></p>
<p>Finally, to be exhaustive, we have the following equation:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/24941b4e-17b3-4ddf-af12-40a787c5ce4a.png" style="width:38.50em;height:2.83em;"/></p>
<p class="graf graf--p graf-after--h4">These calculations may look complex, but we only need to understand what they represent—we can compute how each parameter affects the loss recursively, layer by layer, going backward (using the derivatives for a layer to compute the derivatives for the previous layer). This concept can also be illustrated by representing neural networks as <em>computational graphs</em>, that is, as graphs of mathematical operations chained together (the weighted summation of the first layer is performed and its result is passed to the first activation function, then its own output is passed to the operations of the second layer, and so on). Therefore, computing the result of a whole neural network <span>with respect to</span> some inputs consists of <em>forwarding</em> the data through this computational graph, while obtaining the derivatives <span>with respect to</span> each of its parameters consists of propagating the resulting loss through the graph backward, hence the term <strong>backpropagation</strong>.</p>
<p class="graf graf--p graf-after--h4">To start this process by the output layer, the derivatives of the loss itself <span>with respect to</span> the output values are needed (refer to the previous equation). Therefore, it is primordial that the loss function can be easily derived. For instance, the derivative of the L2 loss is simply the following:</p>
<p class="graf graf--p graf-after--h4 CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/ed9c6804-44af-4058-aab8-6014e2e23030.png" style="width:15.17em;height:3.17em;"/></p>
<p class="graf graf--p graf-after--h4">As we mentioned earlier, once we know the loss derivatives <span>with respect to</span> each parameter, it is just a matter of updating them accordingly:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/71e98db2-8295-4c1e-b096-7f5f25d6e86a.png" style="width:19.33em;height:2.67em;"/></p>
<p>As we can see, the derivatives are often multiplied by a factor <img class="fm-editor-equation" src="assets/5b725f39-5b64-4faf-80c2-6ca9ce5b412d.png" style="width:0.58em;height:0.83em;"/> (<em>epsilon</em>) before being used to update the parameters. This factor is called the <strong>learning rate</strong>. It helps to control how strongly each parameter should be updated at each iteration. A large learning rate may allow the network to learn faster, but with the risk of making steps so big that the network may <em>miss</em> the loss minimum. Therefore, its value should be set with care. Let's now summarize the complete training process:</p>
<ol>
<li>Select the <em>n</em> next training images and feed them to the network.</li>
<li>Compute and backpropagate the loss, using the chain rule to get the derivatives <span>with respect to</span> the parameters of the layers.</li>
<li>Update the parameters with the values of the corresponding derivatives (scaled with the learning rate).</li>
<li>Repeat steps 1 to 3 to iterate over the whole training set.</li>
<li>Repeat steps 1 to 4 until convergence or until a fixed number of iterations.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<p>One iteration over the whole training set (<em>steps 1</em> to<em> 4</em>) is called an <strong>epoch</strong>. If <em>n</em> = 1 and the training sample is randomly selected among the remaining images, this process is called <strong>stochastic gradient descent</strong> (<strong>SGD</strong>), which is easy to implement and visualize, but slower (more updates are done) and <em>noisier</em>. People tend to prefer <em>mini-batch stochastic gradient descent</em>. It implies using larger <em>n</em> values (limited by the capabilities of the computer) so that the gradient is averaged over each <em>mini-batch</em> (or, more simply, named <em>batch</em>) of <em>n</em> random training samples (and is thus less noisy).</p>
<div class="packt_infobox">Nowadays, the term SGD is commonly used, regardless of the value of <em>n</em>.</div>
<p>In this section, we have covered how neural networks are trained. It is now time to put this into practice!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Teaching our network to classify</h1>
                </header>
            
            <article>
                
<p class="mce-root">So far, we have only implemented the feed-forward functionality for our network and its layers. First, let's update our <kbd>FullyConnectedLayer</kbd> class so that we can add methods for backpropagation and optimization:</p>
<pre><span>class </span>FullyConnectedLayer(<span>object</span>):<br/>    <span># [...] (</span><span>code unchanged)<br/></span><span>    </span><span>def </span><span>__init__</span>(<span>self</span><span>, </span>num_inputs<span>, </span>layer_size<span>, </span>activation_fn<span>, </span>d_activation_fn):<br/>        <span># [...] (code unchanged)</span><br/>        <span>self</span>.d_activation_fn = d_activation_fn # Deriv. activation function <br/>        <span>self</span>.x<span>, </span><span>self</span>.y, self.dL_dW, self.dL_db = 0, 0, <span>0, 0 # Storage attr.</span><span><br/></span><span><br/></span><span>    def </span><span>forward</span>(<span>self</span><span>, </span>x):<span><br/></span><span>        </span>z = np.dot(x<span>, </span><span>self</span>.W) + <span>self</span>.b<br/>        <span>self</span>.y = <span>self</span>.activation_fn(z)<br/>        <span>self</span>.x = x  <span># we store values for back-propagation<br/></span><span>        </span><span>return </span><span>self</span>.y<br/><br/>    <span>def </span><span>backward</span>(<span>self</span><span>, </span>dL_dy):<br/>        <span>"""</span><span>Back-propagate the loss.</span><span>"""<br/></span><span>        </span>dy_dz = <span>self</span>.d_activation_fn(<span>self</span>.y)  <span># = f'<br/></span><span>        </span>dL_dz = (dL_dy * dy_dz) <span># dL/dz = dL/dy * dy/dz = l'_{k+1} * f'<br/></span><span>        </span>dz_dw = <span>self</span>.x.T<br/>        dz_dx = <span>self</span>.W.T<br/>        dz_db = np.ones(dL_dy.shape[<span>0</span>]) <span># dz/db = "ones"-vector</span><span><br/></span><span>        # Computing and storing dL w.r.t. the layer's parameters:<br/></span><span>        </span><span>self</span>.dL_dW = np.dot(dz_dw<span>, </span>dL_dz)<br/>        <span>self</span>.dL_db = np.dot(dz_db<span>, </span>dL_dz)<br/>        <span># Computing the derivative w.r.t. x for the previous layers:<br/></span><span>        </span>dL_dx = np.dot(dL_dz<span>, </span>dz_dx)<br/>        <span>return </span>dL_dx<br/><br/>    <span>def </span><span>optimize</span>(<span>self</span><span>, </span>epsilon):<br/>        <span>"""</span><span>Optimize the layer's parameters w.r.t. the derivative values.</span><span>"""<br/></span><span>        </span><span>self</span>.W -= epsilon * <span>self</span>.dL_dW<br/>        <span>self</span>.b -= epsilon * <span>self</span>.dL_db</pre>
<div class="packt_infobox">The code presented in this section has been simplified and stripped of comments to keep its length reasonable. The complete sources are available in this book's GitHub repository, along with a Jupyter notebook that connects everything together.</div>
<p class="mce-root">Now, we need to update the <kbd>SimpleNetwork</kbd> class by adding methods to backpropagate and optimize layer by layer, and a final method to cover the complete training:</p>
<pre><span>def </span><span>derivated_sigmoid</span>(y):  # sigmoid derivative function<br/>    <span>return </span>y * (<span>1 </span>- y)<br/><br/><span>def </span><span>loss_L2</span>(pred<span>, </span>target): # L2 loss function<br/>    <span>return </span>np.sum(np.square(pred - target)) / pred.shape[<span>0</span>] <span># opt. for results not depending on the batch size (pred.shape[0]), we divide the loss by it<br/></span><span><br/></span><span>def </span><span>derivated_loss_L2</span>(pred<span>, </span>target):    # L2 derivative function<br/>    <span>return </span><span>2 </span>* (pred - target) # we could add the batch size division here too, but it wouldn't really affect the training (just scaling down the derivatives).<br/><br/><span>class </span>SimpleNetwork(<span>object</span>):<br/> <span># [...] (code unchanged)<br/></span><span> </span><span>def </span><span>__init__</span>(<span>self</span><span>, </span>num_inputs<span>, </span>num_outputs<span>, </span>hidden_layers_sizes=(<span>64</span><span>, </span><span>32</span>)<span>, </span>loss_fn=loss_L2<span>, </span>d_loss_fn=derivated_loss_L2):<br/>        # [...] (code unchanged, except for FC layers new params.)<br/>        <span>self</span>.loss_fn, self.d_loss_fn = loss_fn, d_loss_fn<br/><br/>    # [...] (code unchanged)<br/><br/>    <span>def </span><span>backward</span>(<span>self</span><span>, </span>dL_dy):<br/>        <span>"""Back-propagate the loss derivative from last to 1st layer."""<br/></span><span>        </span><span>for </span>layer <span>in </span><span>reversed</span>(<span>self</span>.layers):<span><br/></span><span>            </span>dL_dy = layer.backward(dL_dy)<br/>        <span>return </span>dL_dy<br/><br/> <span>def </span><span>optimize</span>(<span>self</span><span>, </span>epsilon):<br/>        <span>"""Optimize the parameters according to the stored gradients."""<br/></span><span>        </span><span>for </span>layer <span>in </span><span>self</span>.layers:<span><br/></span><span>            </span>layer.optimize(epsilon)<br/><br/>    <span>def </span><span>train</span>(self<span>, </span>X_train<span>, </span>y_train<span>, </span>X_val<span>, </span>y_val<span>, </span>batch_size=<span>32</span><span>, </span>num_epochs=<span>5</span><span>, </span>learning_rate=<span>5e-3</span>):<br/>        <span>"""Train (and evaluate) the network on the provided dataset."""<br/></span><span>        </span>num_batches_per_epoch = <span>len</span>(X_train) // batch_size<br/>        loss<span>, </span>accuracy = []<span>, </span>[]<br/>        <span>for </span>i <span>in </span><span>range</span>(num_epochs): <span># for each training epoch<br/></span><span>            </span>epoch_loss = <span>0<br/></span><span>            </span><span>for </span>b <span>in </span><span>range</span>(num_batches_per_epoch): <span># for each batch<br/></span><span>                # Get batch:<br/></span><span>                </span>b_idx = b * batch_size<br/>                b_idx_e = b_idx + batch_size<br/>                x<span>, </span>y_true = X_train[b_idx:b_idx_e]<span>, </span>y_train[b_idx:b_idx_e]<br/>                <span># Optimize on batch:<br/></span><span>                </span>y = self.forward(x) <span># forward pass<br/></span><span>                </span>epoch_loss += self.loss_fn(y<span>, </span>y_true) <span># loss <br/></span><span>                </span>dL_dy = self.d_loss_fn(y<span>, </span>y_true) <span># loss derivation<br/></span><span>                </span>self.backward(dL_dy) <span># back-propagation pass<br/></span><span>                </span>self.optimize(learning_rate) <span># optimization<br/></span><span>            <br/></span><span>            </span>loss.append(epoch_loss / num_batches_per_epoch)<br/>            <span># After each epoch, we "validate" our network, i.e., we measure its accuracy over the test/validation set:<br/></span><span>            </span>accuracy.append(self.evaluate_accuracy(X_val<span>, </span>y_val))<br/>            <span>print</span>(<span>"Epoch {:4d}: training loss = {:.6f} | val accuracy = {:.2f}%"</span>.format(i<span>, </span>loss[i]<span>, </span>accuracy[i] * <span>100</span>))</pre>
<p class="mce-root">Everything is now ready! We can train our model and see how it performs:</p>
<pre>losses<span>, </span>accuracies = mnist_classifier.train(<br/>    X_train<span>, </span>y_train<span>, </span>X_test<span>, </span>y_test<span>, </span><span>batch_size</span>=3<span>0</span><span>, </span><span>num_epochs</span>=<span>500</span>)<br/># &gt; Epoch    0: training loss = 1.096978 | val accuracy = 19.10%
# &gt; Epoch    1: training loss = 0.886127 | val accuracy = 32.17%
# &gt; Epoch    2: training loss = 0.785361 | val accuracy = 44.06%<br/># [...]<br/># &gt; Epoch  498: training loss = 0.046022 | val accuracy = 94.83%
# &gt; Epoch  499: training loss = 0.045963 | val accuracy = 94.83%</pre>
<p class="mce-root">Congratulations! If your machine is powerful enough to complete this training (this simple implementation does not take advantage of the GPU), we just obtained our very own neural network that is able to classify handwritten digits with an accuracy of ~94.8%!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Training considerations – underfitting and overfitting</h1>
                </header>
            
            <article>
                
<p class="mce-root">We invite you to play around with the framework we just implemented, trying different <em>hyperparameters</em> (layer sizes, learning rate, batch size, and so on). Choosing the proper topography (as well as other <em>hyperparameters</em>) can require lots of tweaking and testing. While the sizes of the input and output layers are conditioned by the use case (for example, for classification, the input size would be the number of pixel values in the images, and the output size would be the number of classes to predict from), the hidden layers should be carefully engineered.</p>
<p class="mce-root">For instance, if the network has too few <span>layers, </span>or the layers are too small, the accuracy may stagnate. This means the network is <strong>underfitting</strong>, that is, it does not have enough parameters for the complexity of the task. In this case, the only solution is to adopt a new architecture that is more suited to the application.</p>
<p class="mce-root">On the other hand, if the network is too complex and/or the training dataset is too small, the network may start <strong>overfitting</strong> the training data. This means that the network will learn to fit very well to the training distribution (that is, its particular noise, details, and so on), but won't generalize to new samples (since these new images may have a slightly different noise, for instance). The following diagram highlights the differences between these two problems. T<span>he regression method on the extreme left does not have enough parameters to model the data variations, while the method on the extreme right has too many, which means it will struggle to generalize:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/df4d89d2-9ef3-4ba9-bb46-d20f537ea3ec.png"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.16: A common illustration of underfitting and overfitting</div>
<p class="mce-root">While gathering a larger, more diverse training dataset seems the logical solution to overfitting, it is not always possible in practice (for example, due to limited access to the target objects). Another solution is to adapt the network or its training in order to constrain how much detail the network learns. Such methods will be detailed in <a href="dd1d3406-d506-4690-bf13-e5e0584ea9d1.xhtml">Chapter 3</a>, <em>Modern Neural Networks</em>, among other advanced neural network solutions.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">We covered a lot of ground in this first chapter. We introduced computer vision, the challenges associated with it, and some historical methods, such as SIFT and SVMs. We got familiar with neural networks and saw how they are built, trained, and applied. After implementing our own classifier network from scratch, we can now better understand and appreciate how machine learning frameworks work.</p>
<p class="mce-root">With this knowledge, we are now more than ready to start with TensorFlow in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Which of the following tasks does not belong to computer vision?
<ul>
<li>A web search for images similar to a query</li>
<li>A 3D scene reconstruction from image sequences</li>
<li>Animation of a video character</li>
</ul>
</li>
<li>Which activation function were the original perceptrons using?</li>
<li>Suppose we want to train a method to detect whether a handwritten digit is a 4 or not. How should we adapt the network that we implemented in this chapter for this task?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><em>Hands-On Image Processing with Python</em> (<a href="https://www.packtpub.com/big-data-and-business-intelligence/hands-image-processing-python">https://www.packtpub.com/big-data-and-business-intelligence/hands-image-processing-python</a>), by Sandipan Dey: A great book to learn more about image processing itself, and how Python can be used to manipulate visual data</li>
<li><em>OpenCV 3.x with Python By Example – Second Edition</em> (<a href="https://www.packtpub.com/application-development/opencv-3x-python-example-second-edition">https://www.packtpub.com/application-development/opencv-3x-python-example-second-edition</a>), by Gabriel Garrido and Prateek Joshi: Another recent book introducing the famous computer vision library <em>OpenCV</em>, which has been around for years (it implements some of the traditional methods we introduced in this chapter, such as edge detectors, SIFT, and SVM)</li>
</ul>


            </article>

            
        </section>
    </body></html>