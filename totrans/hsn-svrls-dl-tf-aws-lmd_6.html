<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating a Deep Learning Pipeline</h1>
                </header>
            
            <article>
                
<p>In the last chapter, we studied the creation of the API gateway service using the AWS Console, as well as the serverless framework. In this chapter, we wi<span>ll learn about creating SQS connections using the AWS console, as well as the serverless framework.</span></p>
<p>In this chapter we will cover the following topics:</p>
<ul>
<li>Message queue</li>
<li>Introducing AWS simple query service</li>
<li>Creating AWS SQS using AWS console and serverless framework</li>
<li>Sample projects—deep learning pipeline</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical Requirements</h1>
                </header>
            
            <article>
                
<p>The technical<span> </span>requirements<span> </span>in this chapter are as follows:</p>
<ul>
<li>AWS subscription</li>
<li>Python 3.6</li>
<li>AWS CLI</li>
<li>Serverless framework</li>
<li>You can find all the codes at<span> </span><a href="https://github.com/PacktPublishing/Hands-On-Serverless-Deep-Learning-with-TensorFlow-and-AWS-Lambda">https://github.com/PacktPublishing/Hands-On-Serverless-Deep-Learning-with-TensorFlow-and-AWS-Lambda</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Message queue</h1>
                </header>
            
            <article>
                
<p class="aLF-aPX-K0-aPE">The message queue is an important additional method of interaction within different services. While the RESTful API has a timeout limit, the message queue doesn't have this kind of drawback. Therefore, it helps to handle long-running processes or delayed messages. Also, it allows a more uniform load on the backend. It does not have a critical feature for working with AWS Lambda, since Lambda can easily scale, but it can be very useful when dealing with clusters. Finally, the message queue allows retry logic, meaning that failed tasks can be sent back multiple times. Now let's look more into AWS SQS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to AWS SQS</h1>
                </header>
            
            <article>
                
<p class="aLF-aPX-K0-aPE">Basically, this is an AWS service that allows the sending, receipt, and storage of messages. It can be connected to any processing backend. It has a pay-as-you-go system, which makes it very convenient as a starting point.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AWS API gateway features</h1>
                </header>
            
            <article>
                
<p class="aLF-aPX-K0-aPE">The different features of AWS API are as follows:</p>
<ul>
<li class="aLF-aPX-K0-aPE">It is extremely scalable, and you don't have to manage any other scaling in the queue.</li>
<li class="aLF-aPX-K0-aPE">The service handles access from readers to the queue, so it's something that you don't have to implement.</li>
<li class="aLF-aPX-K0-aPE">SQS has a customizable retry mechanism that increases the probability of avoiding errors, which improves the overall speed.</li>
<li class="aLF-aPX-K0-aPE">SQS provides very simple APIs, which you can use in almost any programming language.</li>
<li class="aLF-aPX-K0-aPE">Finally, it provides encryption, which could be useful for improving the security of your service.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">
AWS SQS pricing</h1>
                </header>
            
            <article>
                
<p>One of the main advantages of SQS is the pay-per-user-go system, which is very simple. Pricing is 50 cents per 1 million requests and the first one million requests are free every month. This makes it perfect for early projects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an AWS SQS connection using an AWS Console</h1>
                </header>
            
            <article>
                
<p class="aLF-aPX-K0-aPE">In this section, we will initially create an AWS Lambda, and then create the simple query service, before connecting SQS to AWS Lambda.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an AWS Lambda instance</h1>
                </header>
            
            <article>
                
<p>The following are the steps for creating the AWS Lambda instance:</p>
<ol>
<li class="aLF-aPX-K0-aPE">First, add the name under <span class="packt_screen">Name</span>, choose <span class="packt_screen">Runtime</span> as <span class="packt_screen">Python 3.6</span>, set <span class="packt_screen">Role</span> as <span class="packt_screen">Choose an  existing role</span>, then from <span class="packt_screen">Existing role</span> choose <kbd>lambda1</kbd>, and click on <span class="packt_screen">Create function</span>, as shown here:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b385768b-6389-4a9a-b300-15f253d821fb.png" style="width:44.50em;height:27.42em;"/></p>
<ol start="2">
<li class="aLF-aPX-K0-aPE">The Lambda function is created as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8089ef55-5533-4e14-8202-9c5019c94c65.png" style="width:44.50em;height:27.92em;"/></p>
<p class="CDPAlignCenter CDPAlign"/>
<ol start="3">
<li>Next, switch to SQS and create a SQS queue by selecting <span class="packt_screen">Create New Queue</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/21706e6c-9e8f-4625-9f1d-0959623d93c0.png" style="width:43.92em;height:11.00em;"/></p>
<ol start="4">
<li>After creating a queue named <span class="packt_screen">testLambda</span>, we get the SQS ARN as highlighted in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ec3309d6-7bfb-4622-91c7-1275fda63a64.png" style="width:46.42em;height:18.17em;"/></p>
<p class="CDPAlignCenter CDPAlign"/>
<p>            5. From the <span class="packt_screen">Designer</span> tab on the left, choose <span class="packt_screen">SQS</span> as the trigger:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bc60d8d0-5246-477b-b9eb-ff3fe1531127.png" style="width:45.42em;height:15.75em;"/></p>
<ol start="6">
<li>We will send some messages to the queue by selecting <span class="packt_screen">Send a Message</span> from the <span class="packt_screen">Queue Actions</span> drop-down list:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ed4cad1c-a03e-4867-960f-b11cc4bf5a2a.png" style="width:43.75em;height:27.25em;"/></p>
<ol start="7">
<li class="CDPAlignLeft CDPAlign">As you can see, we have only one message available, meaning they all were consumed by Lambda as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/df0aaea3-c35d-4cab-9ebc-5c4a60f81224.png" style="width:44.75em;height:16.75em;"/></p>
<p>           8. By clicking <span class="packt_screen">Monitoring</span>, we get a detailed overview as shown:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0113f961-b532-4d60-8549-d41511dae11e.png"/></p>
<p class="CDPAlignCenter CDPAlign"/>
<ol start="9">
<li class="CDPAlignLeft CDPAlign">We also get to see the log details by clicking on <span class="packt_screen">View logs in CloudWatch</span><span> </span>as shown in the preceding screeenshot. Each start and end means invocation for each message.</li>
</ol>
<p><span> The next section concerns the creation of an AWS SQS connection to AWS Lambda using the serverless framework.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an AWS SQS connection using the serverless framework</h1>
                </header>
            
            <article>
                
<p class="aLF-aPX-K0-aPE">To create the SQS connection, we have the main Python file and the serverless configuration file. The configuration file will be a little complex. We will need to define SQS in the resources section, edit as event source for Lambda, and then enable Lambda to read from SQS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Python file</h1>
                </header>
            
            <article>
                
<p class="aLF-aPX-K0-aPE">The main difference for the Python file will be that, instead of returning a string, we will write to another SQS query, as shown:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bc7425d7-37a2-48f1-b35b-782328043304.png" style="width:24.75em;height:13.33em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code</h1>
                </header>
            
            <article>
                
<p><span>Before starting with the code, we will first need to deploy the serverless framework, and then we need to check that it runs using the command-line interface. We will run the code using the <kbd>index.py</kbd> file and the <kbd>serverless.yml</kbd> configuration file.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">serverless.yml</h1>
                </header>
            
            <article>
                
<p><span>In the <kbd>serverless.yml</kbd> file, we can see all the sections that we discussed in the previous chapters, especially the part where we define the role for accessing the query from where we will read messages, and to which our Lambda will write. The following code shows the explanation:</span></p>
<pre>Effect: "Allow"<br/>Action:<br/>    "sqs:ReceiveMessage"<br/>    "sqs:DeleteMessage"<br/>    "sqs:GetQueueAttributes"<br/>Resource:<br/>    arn:aws:sqs:#{AWS::Region}:#{AWS::AccountId}:ReadSQS</pre>
<p><span>We also have to define that one of the queries will act as an event source, as shown:</span></p>
<pre>events:<br/>    sqs:<br/>      arn:<br/>        Fn::GetAtt:<br/>          ReadSQS<br/>          Arn</pre>
<p><span>Finally, we define the queries, which we can perform in the resource section as shown in the code:</span></p>
<pre>resources:<br/>  Resources: <br/>    WriteSQS: <br/>      Type: AWS::SQS::Queue<br/>      Properties:<br/>        QueueName: "WriteSQS"<br/>    ReadSQS: <br/>     Type: AWS::SQS::Queue<br/>     Properties:<br/>        QueueName: "ReadSQS"</pre>
<p><span>Also, we will need to use the plugin <kbd>serverless-pseudo-parameters</kbd>, which we will install:</span></p>
<pre>plugins:<br/>  - serverless-pseudo-parameters</pre>
<p><span>We will need to remove the package with the preceding plugin from the <kbd>deployment</kbd> package as shown:</span></p>
<pre>package:<br/>  exclude:<br/>    - node_modules/**</pre>
<p><span>Next is to use this plugin to access the ID of the region that we use and our account ID as shown:</span></p>
<pre>Resource:<br/>  - arn:aws:sqs:#{AWS::Region}:#{AWS::AccountId}:ReadSQS<br/>Effect: "Allow"<br/>Action:<br/>  - "sqs:SendMessage"<br/>  - "sqs:GetQueueUrl"<br/>Resource:<br/>  - arn:aws:sqs:#{AWS::Region}:#{AWS::AccountId}:WriteSQS</pre>
<p class="mce-root"/>
<div class="packt_tip"><span>You can access the account ID and the ID of a region without this plugin and just manually find it as well.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">index.py</h1>
                </header>
            
            <article>
                
<p><span>The <kbd>index.py</kbd> file is very simple. We just read incoming messages and then write them as SQS. The following shows the code for <kbd>index.py</kbd>:</span></p>
<pre>import boto3<br/><br/>def handler(event,context):<br/>    for message in event['Records']:<br/>        client = boto3.client('sqs')<br/>        sqsAddress = client.get_queue_url(QueueName='WriteSQS')<br/>        response = client.send_message(QueueUrl=sqsAddress['QueueUrl'],<br/>                                        MessageBody=message['body'])<br/>    return</pre>
<p><span>We will see the preceding <kbd>index.py</kbd> and <kbd>serverless.yml</kbd> files in the command line:</span></p>
<p><span>First of all, we need to install plugin, <kbd>serverless-pseudo-parameters</kbd>:</span></p>
<pre><strong>npm install serverless-pseudo-parameters</strong></pre>
<p>The output is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9dd7aebe-03eb-4ce7-a058-f94aedccba8a.png"/></p>
<p class="CDPAlignCenter CDPAlign"/>
<p><span>Next, we will deploy Lambda using the following command:</span></p>
<pre>serverless deploy</pre>
<p><span>As you can see, the plugin replaced the region with the actual base region and account as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/142a3105-5000-478e-b270-2200cdb679cd.png"/></p>
<p class="CDPAlignCenter CDPAlign"/>
<p><span>To send a message through the queue, first we need to find the queue URL using the following command:</span></p>
<pre><strong>aws sqs get-queue-url --queue-name ReadSQS</strong></pre>
<p><span>With the queue URL, we can send messages. We see the command executed successfully here:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b4762bea-b362-4ada-8bad-fd11a49424fd.png"/></p>
<p><span>Now we can read the same message from the SQS queue. Basically, here we can check  whether Lambda has received the message that we have sent, which is</span> <kbd>Hello world1</kbd>, <span>and send it to write SQL. We see that Lambda works successfully and we can see the resulting message, <kbd>Hello world1</kbd></span>, <span>in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8ff07274-2898-49de-a34a-7b2814427375.png" style="width:47.58em;height:23.75em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example project – deep learning pipeline</h1>
                </header>
            
            <article>
                
<p class="aLF-aPX-K0-aPE">In the project files, we have the main Python file, the serverless configuration file, libraries files, and an inception module. The configuration file will be the same as the one we used in the previous chapter. We will look at the Python file. The main difference for our Python file will be that, instead of returning the string, we will send a message to another SQS query. Also, we will make Lambda accept the link to the image in the message, and then apply module to structure it. The deployment will be similar to the one in the previous section.</p>
<div class="aLF-aPX-K0-aPE packt_tip">We will skip the deployment of the model, since we have covered it before.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code</h1>
                </header>
            
            <article>
                
<p class="aLF-aPX-K0-aPE">First, we will need to deploy the serverless framework, and then we can check that it runs using the command-line interface. We have the <kbd>index.py</kbd> file and the <kbd>serverless.yml</kbd> <span>configuration file. </span>We also have libraries for TensorFlow and pre-installed plugins for the serverless framework.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration file - serverless.yml</h1>
                </header>
            
            <article>
                
<p class="aLF-aPX-K0-aPE">We can see that the current configuration file is taken from the preceding sections.</p>
<p class="aLF-aPX-K0-aPE">We have a bucket where we keep our model, as shown in the following code snippet:</p>
<pre>Effect: "Allow"<br/>Action:<br/>  - "s3:ListBucket"<br/>Resource:<br/>  - arn:aws:s3:::serverlessdeeplearning<br/>Effect: "Allow"<br/>Action:<br/>  - "s3:GetObject"<br/>Resource:<br/>  - arn:aws:s3:::serverlessdeeplearning/*</pre>
<p class="aLF-aPX-K0-aPE">There is an event source for Lambda and resources, as shown in the following code snippet:</p>
<pre>- sqs:<br/>    arn:<br/>      Fn::GetAtt:<br/>        - DLReadSQS<br/>        - Arn</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">index.py</h1>
                </header>
            
            <article>
                
<p class="aLF-aPX-K0-aPE">In the <kbd>index.py</kbd> file, the script looks the same way as it did in the previous section. An additional part has been added, which is reading the URL from the message and writing the result to another queue. The following is the code snippet for <kbd>index.py</kbd>:</p>
<pre>import boto3<br/>import numpy as np<br/>import tensorflow as tf<br/>import os.path<br/>import re<br/>from urllib.request import urlretrieve<br/>import json<br/>SESSION = None<br/>strBucket = 'serverlessdeeplearning'<br/>def handler(event, context):<br/>    global strBucket<br/>    global SESSION<br/>    if not os.path.exists('/tmp/imagenet/'):<br/>       os.makedirs('/tmp/imagenet/')<br/>       ...</pre>
<p><span>The following screenshot shows the part where we retrieve the image and run our model on it, and hence, we write the result of the model to another queue, as shown:</span></p>
<pre>if ('Records' in event):<br/>    for message in event['Records']:<br/>        urlretrieve(message['body'].strip('\''), strFile)<br/>        vecResult = run_inference_on_image(strFile)<br/>        client = boto3.client('sqs')<br/>        sqsAddress = client.get_queue_url(QueueName='DLWriteSQS')<br/>        response = client.send_message(QueueUrl=sqsAddress['QueueUrl'],<br/>                                       MessageBody=vecResult[0])<br/> else:<br/>        downloadFromS3(strBucket,'imagenet/inputimage.png',strFile)<br/>        strResult = run_inference_on_image(strFile)</pre>
<p><span>Now let's deploy the service as shown:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/27e1f796-47b8-4291-a5d8-4ddc64f8cc6f.png"/></p>
<p><span>We will send the message with a URL to the first queue. This can be done with the command-line interface:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e6c11837-4ede-4d69-9d6e-1c912ec9d3ec.png"/></p>
<p class="CDPAlignCenter CDPAlign"/>
<p><span>We can read the sent message from another queue as shown here:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/05cee0bc-e1e1-4439-bd50-381b227977bd.png"/></p>
<p class="CDPAlignCenter CDPAlign"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="aLF-aPX-K0-aPE">In this chapter, we were introduced to AWS SQS, which included the features as well as a look at its pricing. We also created AWS SQS connection using both the AWS console and the serverless framework.</p>
<p>We learned about the deployment of the <kbd>serverless.yml</kbd>  configuration file and the <kbd>index.py</kbd> file. This chapter concluded with an example project, which was a deep learning pipeline.</p>
<p>In the next chapter, we will learn about creating crossing workflow by connecting an AWS Lambda instance and AWS functions where we will learn how to make deep learning workflow.</p>


            </article>

            
        </section>
    </body></html>