["```\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport tensorflow as tf\nimport numpy as np\nimport time\nfrom datetime import timedelta\nimport os\n\n# Importing a helper module for the functions of the Inception model.\nimport inception\n```", "```\nimport cifar10\n#importing number of classes of CIFAR-10\nfrom cifar10 import num_classes\n```", "```\ncifar10.data_path = \"data/CIFAR-10/\"\n\nThe CIFAR-10 dataset is about 170 MB, the next line checks if the dataset is already downloaded if not it downloads the dataset and store in the previous data_path:\n\ncifar10.maybe_download_and_extract</span>()\n\nOutput:\n\n- Download progress: 100.0%\nDownload finished. Extracting files.\nDone.\n```", "```\n#Loading the class names of CIFAR-10 dataset\nclass_names = cifar10.load_class_names()\nclass_names\n```", "```\nLoading data: data/CIFAR-10/cifar-10-batches-py/batches.meta\n['airplane',\n 'automobile',\n 'bird',\n 'cat',\n 'deer',\n 'dog',\n 'frog',\n 'horse', \n 'ship',\n 'truck']\nLoad the training-set. \n```", "```\ntraining_images, training_cls_integers, trainig_one_hot_labels = cifar10.load_training_data()\n```", "```\nLoading data: data/CIFAR-10/cifar-10-batches-py/data_batch_1\nLoading data: data/CIFAR-10/cifar-10-batches-py/data_batch_2\nLoading data: data/CIFAR-10/cifar-10-batches-py/data_batch_3\nLoading data: data/CIFAR-10/cifar-10-batches-py/data_batch_4\nLoading data: data/CIFAR-10/cifar-10-batches-py/data_batch_5\nLoad the test-set.\n```", "```\n#Loading the test images, their class integer, and their corresponding one-hot encoding\ntesting_images, testing_cls_integers, testing_one_hot_labels = cifar10.load_test_data()\n\nOutput:\n\nLoading data: data/CIFAR-10/cifar-10-batches-py/test_batch\n```", "```\nprint(\"-Number of images in the training set:\\t\\t{}\".format(len(training_images)))\nprint(\"-Number of images in the testing set:\\t\\t{}\".format(len(testing_images)))\n```", "```\n-Number of images in the training set:          50000\n-Number of images in the testing set:           10000\n```", "```\ndef plot_imgs(imgs, true_class, predicted_class=None):\n\n    assert len(imgs) == len(true_class)\n\n    # Creating a placeholders for 9 subplots\n    fig, axes = plt.subplots(3, 3)\n\n    # Adjustting spacing.\n    if predicted_class is None:\n        hspace = 0.3\n    else:\n        hspace = 0.6\n    fig.subplots_adjust(hspace=hspace, wspace=0.3)\n\n    for i, ax in enumerate(axes.flat):\n        # There may be less than 9 images, ensure it doesn't crash.\n        if i < len(imgs):\n            # Plot image.\n            ax.imshow(imgs[i],\n                      interpolation='nearest')\n\n            # Get the actual name of the true class from the class_names array\n            true_class_name = class_names[true_class[i]]\n\n            # Showing labels for the predicted and true classes\n            if predicted_class is None:\n                xlabel = \"True: {0}\".format(true_class_name)\n            else:\n                # Name of the predicted class.\n                predicted_class_name = class_names[predicted_class[i]]\n\n                xlabel = \"True: {0}\\nPred: {1}\".format(true_class_name, predicted_class_name)\n\n            ax.set_xlabel(xlabel)\n\n        # Remove ticks from the plot.\n        ax.set_xticks([])\n        ax.set_yticks([])\n\n    plt.show()\n```", "```\n# get the first 9 images in the test set\nimgs = testing_images[0:9]\n\n# Get the integer representation of the true class.\ntrue_class = testing_cls_integers[0:9]\n\n# Plotting the images\nplot_imgs(imgs=imgs, true_class=true_class)\n```", "```\ninception.data_dir = 'inception/'\n```", "```\ninception.maybe_download()\n\nDownloading Inception v3 Model ...\n- Download progress: 100%\n```", "```\n# Loading the inception model so that we can inialized it with the pre-trained weights and customize for our model\ninception_model = inception.Inception()\n```", "```\nfrom inception import transfer_values_cache\n```", "```\nfile_path_train = os.path.join(cifar10.data_path, 'inception_cifar10_train.pkl')\nfile_path_test = os.path.join(cifar10.data_path, 'inception_cifar10_test.pkl')\nprint(\"Processing Inception transfer-values for the training images of Cifar-10 ...\")\n# First we need to scale the imgs to fit the Inception model requirements as it requires all pixels to be from 0 to 255,\n# while our training examples of the CIFAR-10 pixels are between 0.0 and 1.0\nimgs_scaled = training_images * 255.0\n\n# Checking if the transfer-values for our training images are already calculated and loading them, if not calculate and save them.\ntransfer_values_training = transfer_values_cache(cache_path=file_path_train,\n                                              images=imgs_scaled,\n                                              model=inception_model)\nprint(\"Processing Inception transfer-values for the testing images of Cifar-10 ...\")\n# First we need to scale the imgs to fit the Inception model requirements as it requires all pixels to be from 0 to 255,\n# while our training examples of the CIFAR-10 pixels are between 0.0 and 1.0\nimgs_scaled = testing_images * 255.0\n# Checking if the transfer-values for our training images are already calculated and loading them, if not calcaulate and save them.\ntransfer_values_testing = transfer_values_cache(cache_path=file_path_test,\n                                     images=imgs_scaled,\n                                     model=inception_model)\n\n```", "```\ntransfer_values_training.shape\n```", "```\n(50000, 2048)\n```", "```\ntransfer_values_testing.shape\n```", "```\n(10000, 2048)\n```", "```\ndef plot_transferValues(ind):\n    print(\"Original input image:\")\n\n    # Plot the image at index ind of the test set.\n    plt.imshow(testing_images[ind], interpolation='nearest')\n    plt.show()\n\n    print(\"Transfer values using Inception model:\")\n\n    # Visualize the transfer values as an image.\n    transferValues_img = transfer_values_testing[ind]\n    transferValues_img = transferValues_img.reshape((32, 64))\n\n    # Plotting the transfer values image.\n    plt.imshow(transferValues_img, interpolation='nearest', cmap='Reds')\n    plt.show()\nplot_transferValues(i=16)\n\nInput image:\n```", "```\nplot_transferValues(i=17)\n```", "```\nfrom sklearn.decomposition import PCA\n```", "```\npca_obj = PCA(n_components=2)\n```", "```\nsubset_transferValues = transfer_values_training[0:3000]\n```", "```\ncls_integers = testing_cls_integers[0:3000]\n```", "```\nsubset_transferValues.shape\n```", "```\n(3000, 2048)\n```", "```\nreduced_transferValues = pca_obj.fit_transform(subset_transferValues)\n```", "```\nreduced_transferValues.shape\n```", "```\n(3000, 2)\n```", "```\n#Importing the color map for plotting each class with different color.\nimport matplotlib.cm as color_map\n\ndef plot_reduced_transferValues(transferValues, cls_integers):\n\n    # Create a color-map with a different color for each class.\n    c_map = color_map.rainbow(np.linspace(0.0, 1.0, num_classes))\n\n    # Getting the color for each sample.\n    colors = c_map[cls_integers]\n\n    # Getting the x and y values.\n    x_val = transferValues[:, 0]\n    y_val = transferValues[:, 1]\n\n    # Plot the transfer values in a scatter plot\n    plt.scatter(x_val, y_val, color=colors)\n    plt.show()\n\n```", "```\nplot_reduced_transferValues(reduced_transferValues, cls_integers)\n```", "```\nfrom sklearn.manifold import TSNE\n\n```", "```\npca_obj = PCA(n_components=50)\ntransferValues_50d = pca_obj.fit_transform(subset_transferValues)\n```", "```\ntsne_obj = TSNE(n_components=2)\n```", "```\nreduced_transferValues = tsne_obj.fit_transform(transferValues_50d) \n```", "```\nreduced_transferValues.shape\n```", "```\n(3000, 2)\n```", "```\nplot_reduced_transferValues(reduced_transferValues, cls_integers)\n```", "```\ntransferValues_arrLength = inception_model.transfer_len\ninput_values = tf.placeholder(tf.float32, shape=[None, transferValues_arrLength], name='input_values')\ny_actual = tf.placeholder(tf.float32, shape=[None, num_classes], name='y_actual')\n```", "```\ny_actual_cls = tf.argmax(y_actual, axis=1)\n```", "```\ndef new_weights(shape):\n    return tf.Variable(tf.truncated_normal(shape, stddev=0.05))\n\ndef new_biases(length):\n    return tf.Variable(tf.constant(0.05, shape=[length]))\n\ndef new_fc_layer(input,          # The previous layer.\n                 num_inputs,     # Num. inputs from prev. layer.\n                 num_outputs,    # Num. outputs.\n                 use_relu=True): # Use Rectified Linear Unit (ReLU)?\n\n    # Create new weights and biases.\n    weights = new_weights(shape=[num_inputs, num_outputs])\n    biases = new_biases(length=num_outputs)\n\n    # Calculate the layer as the matrix multiplication of\n    # the input and weights, and then add the bias-values.\n    layer = tf.matmul(input, weights) + biases\n\n    # Use ReLU?\n    if use_relu:\n        layer = tf.nn.relu(layer)\n\n    return layer\n\n# First fully-connected layer.\nlayer_fc1 = new_fc_layer(input=input_values,\n                             num_inputs=2048,\n                             num_outputs=1024,\n                             use_relu=True)\n\n# Second fully-connected layer.\nlayer_fc2 = new_fc_layer(input=layer_fc1,\n                             num_inputs=1024,\n                             num_outputs=num_classes,\n                             use_relu=False)\n\n# Predicted class-label.\ny_predicted = tf.nn.softmax(layer_fc2)\n\n# Cross-entropy for the classification of each image.\ncross_entropy = \\\n    tf.nn.softmax_cross_entropy_with_logits(logits=layer_fc2,\n                                                labels=y_actual)\n\n# Loss aka. cost-measure.\n# This is the scalar value that must be minimized.\nloss = tf.reduce_mean(cross_entropy)\n\n```", "```\nstep = tf.Variable(initial_value=0,\n                          name='step', trainable=False)\noptimizer = tf.train.AdamOptimizer(learning_rate=1e-4).minimize(loss, step)\ny_predicted_cls = tf.argmax(y_predicted, axis=1)\n#compare the predicted and true classes\ncorrect_prediction = tf.equal(y_predicted_cls, y_actual_cls)\n#cast the boolean values to fload\nmodel_accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))\n```", "```\nsession = tf.Session()\nsession.run(tf.global_variables_initializer())\n\n```", "```\n#defining the size of the train batch\ntrain_batch_size = 64\n\n#defining a function for randomly selecting a batch of images from the dataset\ndef select_random_batch():\n    # Number of images (transfer-values) in the training-set.\n    num_imgs = len(transfer_values_training)\n\n    # Create a random index.\n    ind = np.random.choice(num_imgs,\n                           size=training_batch_size,\n                           replace=False)\n\n    # Use the random index to select random x and y-values.\n    # We use the transfer-values instead of images as x-values.\n    x_batch = transfer_values_training[ind]\n    y_batch = trainig_one_hot_labels[ind]\n\n    return x_batch, y_batch\n```", "```\ndef optimize(num_iterations):\n\n    for i in range(num_iterations):\n        # Selectin a random batch of images for training\n        # where the transfer values of the images will be stored in input_batch\n        # and the actual labels of those batch of images will be stored in y_actual_batch\n        input_batch, y_actual_batch = select_random_batch()\n\n        # storing the batch in a dict with the proper names\n        # such as the input placeholder variables that we define above.\n        feed_dict = {input_values: input_batch,\n                           y_actual: y_actual_batch}\n\n        # Now we call the optimizer of this batch of images\n        # TensorFlow will automatically feed the values of the dict we created above\n        # to the model input placeholder variables that we defined above.\n        i_global, _ = session.run([step, optimizer],\n                                  feed_dict=feed_dict)\n\n        # print the accuracy every 100 steps.\n        if (i_global % 100 == 0) or (i == num_iterations - 1):\n            # Calculate the accuracy on the training-batch.\n            batch_accuracy = session.run(model_accuracy,\n                                    feed_dict=feed_dict)\n\n            msg = \"Step: {0:>6}, Training Accuracy: {1:>6.1%}\"\n            print(msg.format(i_global, batch_accuracy))\n```", "```\ndef plot_errors(cls_predicted, cls_correct):\n\n    # cls_predicted is an array of the predicted class-number for\n    # all images in the test-set.\n\n    # cls_correct is an array with boolean values to indicate\n    # whether is the model predicted the correct class or not.\n\n    # Negate the boolean array.\n    incorrect = (cls_correct == False)\n\n    # Get the images from the test-set that have been\n    # incorrectly classified. \n    incorrectly_classified_images = testing_images[incorrect]\n\n    # Get the predicted classes for those images.\n    cls_predicted = cls_predicted[incorrect]\n\n    # Get the true classes for those images.\n    true_class = testing_cls_integers[incorrect]\n\n    n = min(9, len(incorrectly_classified_images))\n\n    # Plot the first n images.\n    plot_imgs(imgs=incorrectly_classified_images[0:n],\n                true_class=true_class[0:n],\n                predicted_class=cls_predicted[0:n])\n```", "```\nfrom sklearn.metrics import confusion_matrix\n\ndef plot_confusionMatrix(cls_predicted):\n\n    # cls_predicted array of all the predicted \n    # classes numbers in the test.\n\n    # Call the confucion matrix of sklearn\n    cm = confusion_matrix(y_true=testing_cls_integers,\n                          y_pred=cls_predicted)\n\n    # Printing the confusion matrix\n    for i in range(num_classes):\n        # Append the class-name to each line.\n        class_name = \"({}) {}\".format(i, class_names[i])\n        print(cm[i, :], class_name)\n\n    # labeling each column of the confusion matrix with the class number\n    cls_numbers = [\" ({0})\".format(i) for i in range(num_classes)]\n    print(\"\".join(cls_numbers))\n```", "```\n# Split the data-set in batches of this size to limit RAM usage.\nbatch_size = 128\n\ndef predict_class(transferValues, labels, cls_true):\n\n    # Number of images.\n    num_imgs = len(transferValues)\n\n    # Allocate an array for the predicted classes which\n    # will be calculated in batches and filled into this array.\n    cls_predicted = np.zeros(shape=num_imgs, dtype=np.int)\n\n    # Now calculate the predicted classes for the batches.\n    # We will just iterate through all the batches.\n    # There might be a more clever and Pythonic way of doing this.\n\n    # The starting index for the next batch is denoted i.\n    i = 0\n\n    while i < num_imgs:\n        # The ending index for the next batch is denoted j.\n        j = min(i + batch_size, num_imgs)\n\n        # Create a feed-dict with the images and labels\n        # between index i and j.\n        feed_dict = {input_values: transferValues[i:j],\n                     y_actual: labels[i:j]}\n\n        # Calculate the predicted class using TensorFlow.\n        cls_predicted[i:j] = session.run(y_predicted_cls, feed_dict=feed_dict)\n\n        # Set the start-index for the next batch to the\n        # end-index of the current batch.\n        i = j\n\n    # Create a boolean array whether each image is correctly classified.\n    correct = [a == p for a, p in zip(cls_true, cls_predicted)]\n\n    return correct, cls_predicted\n\n#Calling the above function making the predictions for the test\n\ndef predict_cls_test():\n    return predict_class(transferValues = transfer_values_test,\n                       labels = labels_test,\n                       cls_true = cls_test)\n\ndef classification_accuracy(correct):\n    # When averaging a boolean array, False means 0 and True means 1.\n    # So we are calculating: number of True / len(correct) which is\n    # the same as the classification accuracy.\n\n    # Return the classification accuracy\n    # and the number of correct classifications.\n    return np.mean(correct), np.sum(correct)\n\ndef test_accuracy(show_example_errors=False,\n                        show_confusion_matrix=False):\n\n    # For all the images in the test-set,\n    # calculate the predicted classes and whether they are correct.\n    correct, cls_pred = predict_class_test()\n\n    # Classification accuracypredict_class_test and the number of correct classifications.\n    accuracy, num_correct = classification_accuracy(correct)\n\n    # Number of images being classified.\n    num_images = len(correct)\n\n    # Print the accuracy.\n    msg = \"Test set accuracy: {0:.1%} ({1} / {2})\"\n    print(msg.format(accuracy, num_correct, num_images))\n\n    # Plot some examples of mis-classifications, if desired.\n    if show_example_errors:\n        print(\"Example errors:\")\n        plot_errors(cls_predicted=cls_pred, cls_correct=correct)\n\n    # Plot the confusion matrix, if desired.\n    if show_confusion_matrix:\n        print(\"Confusion Matrix:\")\n        plot_confusionMatrix(cls_predicted=cls_pred)\n```", "```\ntest_accuracy(show_example_errors=True,\n                    show_confusion_matrix=True)\n\nAccuracy on Test-Set: 9.4% (939 / 10000)\n```", "```\noptimize(num_iterations=10000)\ntest_accuracy(show_example_errors=True,\n                           show_confusion_matrix=True)\nAccuracy on Test-Set: 90.7% (9069 / 10000)\nExample errors:\n```", "```\nConfusion Matrix:\n[926   6  13   2   3   0   1   1  29  19] (0) airplane\n[  9 921   2   5   0   1   1   1   2  58] (1) automobile\n[ 18   1 883  31  32   4  22   5   1   3] (2) bird\n[  7   2  19 855  23  57  24   9   2   2] (3) cat\n[  5   0  21  25 896   4  24  22   2   1] (4) deer\n[  2   0  12  97  18 843  10  15   1   2] (5) dog\n[  2   1  16  17  17   4 940   1   2   0] (6) frog\n[  8   0  10  19  28  14   1 914   2   4] (7) horse\n[ 42   6   1   4   1   0   2   0 932  12] (8) ship\n[  6  19   2   2   1   0   1   1   9 959] (9) truck\n (0) (1) (2) (3) (4) (5) (6) (7) (8) (9)\n```", "```\nmodel.close()\nsession.close()\n```"]