- en: 4\. Productization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will handle new data and create a model that is able to
    learn continuously from the patterns it is shown and help make better predictions.
    We will use a web application as an example to show how to deploy deep learning
    models not only because of the simplicity and prevalence of web apps, but also
    the different possibilities they provide, such as getting predictions on mobile
    using a web browser and making REST APIs for users.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on how to *productize* a deep learning model. We use the
    word productize to define the creation of a software product from a deep learning
    model that can be used by other people and applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are interested in models that use new data as and when it becomes available,
    continuously learn patterns from new data, and consequently, make better predictions.
    In this chapter, we will study two strategies to deal with new data: one that
    retrains an existing model, and another that creates a completely new model. Then,
    we implement the latter strategy in our Bitcoin price prediction model so that
    it can continuously predict new Bitcoin prices.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we will be able to deploy a working web application
    (with a functioning HTTP API) and modify it to our heart's content.
  prefs: []
  type: TYPE_NORMAL
- en: Handling New Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Models can be trained once using a set of data and can then be used to make
    predictions. Such static models can be very useful, but it is often the case that
    we want our model to continuously learn from new data—and to continuously get
    better as it does so.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss two strategies of handling new data and see
    how to implement them in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Separating Data and Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building a deep learning application, the two most important areas are
    data and model. From an architectural point of view, it is recommended that these
    two areas be kept separate. We believe that is a good suggestion because each
    of these areas includes functions inherently separate from each other. Data is
    often required to be collected, cleaned, organized, and normalized, whereas models
    need to be trained, evaluated, and able to make predictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following that suggestion, we will be using two different code bases to help
    us build our web application: the Yahoo Finance API and `Model()`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Yahoo Finance API: The API can be installed by using `pip` with the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After installation, we will be able to access all the historical data related
    to the finance domain.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Model()`: This class implements all the code we have written so far into a
    single class. It provides facilities for interacting with our previously trained
    models and allows us to make predictions using de-normalized data, which is much
    easier to understand. The `Model()` class is our model component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two code bases are used extensively throughout our example application
    and define the data and model components.
  prefs: []
  type: TYPE_NORMAL
- en: The Data Component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Yahoo Finance API helps to retrieve and parse the historical data of stocks.
    It contains one relevant method, `history()`, which is detailed in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This `history()` method collects data from the Yahoo Finance website, parses
    it, and returns a pandas DataFrame that is ready to be used by the `Model()` class.
  prefs: []
  type: TYPE_NORMAL
- en: The Yahoo Finance API uses the parameter ticker to determine what cryptocurrency
    to collect. The Yahoo Finance API has many other cryptocurrencies available, including
    popular ones such as Ethereum and Bitcoin Cash. Using the `ticker` parameter,
    you can change the cryptocurrency and train a different model apart from the Bitcoin
    model created in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The Model Component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Model()` class is where we implement the application''s model component.
    The `Model()` class contains five methods that implement all the different modeling
    topics from this book. They are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build()`: This method builds an LSTM model using TensorFlow. This method works
    as a simple wrapper for a manually created model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`train()`: This method trains the model using data that the class was instantiated
    with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`evaluate()`: This method evaluates the model using a set of loss functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`save()`: This method saves the model locally as a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`predict()`: This method makes and returns predictions based on an input sequence
    of observations ordered by week.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use these methods throughout this chapter to work, train, evaluate,
    and issue predictions with our model. The `Model()` class is an example of how
    to wrap essential TensorFlow functions into a web application. The preceding methods
    can be implemented almost exactly as in previous chapters, but with enhanced interfaces.
    For example, the `train()` method implemented in the following code trains a model
    available in `self.model` using data from `self.X` and `self.Y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The general idea is that each of the processes from the Keras workflow (build
    or design, train, evaluate, and predict) can easily be turned into distinct parts
    of a program. In our case, we have made them into methods that can be invoked
    from the `Model()` class. This organizes our program and provides a series of
    constraints (such as on the model architecture or certain API parameters), which
    help us deploy our model in a stable environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will explore common strategies for dealing with
    new data.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with New Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The core idea of machine learning models—neural networks included—is that they
    can learn patterns from data. Imagine that a model was trained with a certain
    dataset and it is now issuing predictions. Now, imagine that new data is available.
    There are different strategies you can employ so that a model can take advantage
    of the newly available data to learn new patterns and improve its predictions.
    In this section, we will discuss two strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Retraining an old model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Training a new model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retraining an Old Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this strategy, we retrain an existing model with new data. Using this strategy,
    you can continuously adjust the model parameters to adapt to new phenomena. However,
    data used in later training periods might be significantly different from earlier
    data. Such differences might cause significant changes to the model parameters,
    such as making it learn new patterns and forget old patterns. This phenomenon
    is generally referred to as **catastrophic forgetting**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Catastrophic forgetting is a common phenomenon affecting neural networks. Deep
    learning researchers have been trying to tackle this problem for many years. DeepMind,
    a Google-owned deep learning research group from the United Kingdom, has made
    notable advancements in finding a solution. The article, *Overcoming* *Catastrophic
    Forgetting in Neural Networks*, *James Kirkpatrick*, *et. al*. is a good reference
    for such work, and is available at [https://arxiv.org/pdf/1612.00796.pdf](https://arxiv.org/pdf/1612.00796.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface used for training (`model.fit()`) for the first time can be used
    for training with new data as well. The following snippet loads the data and helps
    to train a model specifying the epochs and batch size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In TensorFlow, when models are trained, the model's state is saved as weights
    on the disk. When you use the `model.save()` method, that state is also saved.
    And when you invoke the `model.fit()` method, the model is retrained with the
    new dataset, using the previous state as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: 'In typical Keras models, this technique can be used without further issues.
    However, when working with LSTM models, this technique has one key limitation:
    the shape of both train and validation data must be the same. For example, in
    *Chapter 3*, *Real-World Deep Learning with TensorFlow and Keras: Evaluating the
    Bitcoin Model*, our LSTM model (`bitcoin_lstm_v0`) uses 186 weeks to predict one
    week into the future. If we attempt to retrain the model with 187 weeks to predict
    the coming week, the model raises an exception with information regarding the
    incorrect shape of data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way of dealing with this is to arrange data in the format expected by the
    model. For example, to make predictions based on a year''s data (52 weeks), we
    would need to configure a model to predict a future week using 40 weeks. In this
    case, we first train the model with the first 40 weeks of 2019, then continue
    to retrain it over the following weeks until we reach week 51\. We use the `Model()`
    class to implement a retraining technique in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This technique tends to be fast to train and tends to work well with series
    that are large. The next technique is easier to implement and works well in smaller
    series.
  prefs: []
  type: TYPE_NORMAL
- en: Training a New Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another strategy is to create and train a new model every time new data is available.
    This approach tends to reduce catastrophic forgetting, but training time increases
    as data increases. Its implementation is quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Bitcoin model as an example, let''s now assume that we have old data
    for 49 weeks of 2019, and that after a week, new data is available. We represent
    this with the `old_data` and `new_data` variables in the following snippet, in
    which we implement a strategy for training a new model when new data is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This approach is very simple to implement and tends to work well for small datasets.
    This will be the preferred solution for our Bitcoin price-predictions application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.01: Retraining a Model Dynamically'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you have to retrain a model to make it dynamic. Whenever
    new data is loaded, it should be able to make predictions accordingly. Here are
    the steps to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing `cryptonic`. Cryptonic is a simple software application
    developed for this book that implements all the steps up to this section using
    Python classes and modules. Consider Cryptonic as a template to be used to create
    applications. Cryptonic, provided as a Python module for this exercise, can be
    found at the following GitHub link: [https://packt.live/325WdZQ](https://packt.live/325WdZQ).'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will start a Jupyter Notebook instance, and then we will load the
    `cryptonic` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using your Terminal, navigate to the `Chapter04/Exercise4.01` directory and
    execute the following code to start a Jupyter Notebook instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The server will automatically open in your browser, then open the Jupyter Notebook
    named `Exercise4.01_Re_training_a_model_dynamically.ipynb`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we will import classes from the `cryptonic` package: `Model()` and the
    Yahoo Finance API. These classes facilitate the process of manipulating our model.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Jupyter Notebook instance, navigate to the header `Fetching Real-Time
    Data`. We will now be fetching updated historical data from Yahoo Finance by calling
    the `history()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `historic_data` variable is now populated with a pandas DataFrame that contains
    historic data of Bitcoin rates up to the time of running this code. This is great
    and makes it easier to retrain our model when more data is available.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can view the first three rows of data stored in `historic_data` using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then view this data stored in `historic_data`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.1: Output displaying the head of the data'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15911_04_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.1: Output displaying the head of the data'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The data contains practically the same variables from the Bitcoin dataset we
    used. However, much of the data comes from an earlier period, 2017 to 2019.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using the pandas API, filter the data for only the dates available in 2019,
    and store them in `model_data`. You should be able to do this by using the date
    variable as the filtering index. Make sure the data is filtered before you continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run `model_data` in next cell and the output model can be seen as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.2: The model_data variable showing historical data'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15911_04_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.2: The model_data variable showing historical data'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Model()` class compiles all the code we have written so far in all of our
    activities. We will use that class to build, train, and evaluate our model in
    this activity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will now use the filtered data to train the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to see the trained model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The trained model is shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.3: The output showing our trained model'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15911_04_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.3: The output showing our trained model'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The preceding steps showcase the complete workflow when using the `Model()`
    class to train a model.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the complete code, use the `Chapter04/Exercise4.01` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we'll focus on retraining our model every time more data is available.
    This readjusts the weights of the network to new data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to do this, we have configured our model to predict a week using 40
    weeks. We now want to use the remaining 11 full weeks to create overlapping periods
    of 40 weeks. These include one of those 11 weeks at a time, and retrain the model
    for every one of those periods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Navigate to the `Re-Train Old Model` header in the Jupyter Notebook. Now, complete
    the `range` function and the `model_data` filtering parameters using an index
    to split the data into overlapping groups of seven days. Then, retrain our model
    and collect the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `A`, `B`, `C`, and `D` variables are placeholders. Use integers to create
    overlapping groups of seven days in which the overlap is of one day.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Replacing these placeholders with weeks, we run the loop as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s the output showing the results of this loop:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After you have retrained your model, go ahead and invoke the `M.predict(denormalized=True)`
    function and examine the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we'll focus on creating and training a new model every time new data is
    available. In order to do this, we now assume that we have old data for 49 weeks
    of 2019, and after a week, we now have new data. We represent this with the `old_data`
    and `new_data` variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the `New Data New Model` header and split the data between the
    `old_data` and `new_data` variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, train the model with `old_data` first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have all the pieces that we need in order to train our model dynamically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2AQb3bE](https://packt.live/2AQb3bE).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/322KuLl](https://packt.live/322KuLl).
    You must execute the entire Notebook in order to get the desired result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the next section, we will deploy our model as a web application, making its
    predictions available in the browser via an HTTP API.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Model as a Web Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will deploy our model as a web application. We will use
    the Cryptonic web application to deploy our model, exploring its architecture
    so that we can make modifications in the future. The intention is to have you
    use this application as a starter for more complex applications—a starter that
    is fully working and can be expanded as you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from familiarity with Python, this topic assumes familiarity with creating
    web applications. Specifically, we assume that you have some knowledge of web
    servers, routing, the HTTP protocol, and caching. You will be able to locally
    deploy the demonstrated Cryptonic application without extensive knowledge of these
    web servers, the HTTP protocol, and caching, but learning these topics will make
    any future development much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Docker is used to deploy our web applications, so basic knowledge of
    that technology is also useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue, make sure that you have the following applications installed
    and available on your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker (Community Edition) 17.12.0-ce or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose (`docker-compose`) 1.18.0 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both these components can be downloaded and installed on all major systems from
    [http://docker.com/](http://docker.com/). These are essential for completing this
    activity. Make sure these are available in your system before moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: Application Architecture and Technologies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to deploy our web applications, we will use the tools and technologies
    described in *Figure 4.4*. Flask is key because it helps us create an HTTP interface
    for our model, allowing us to access an HTTP endpoint (such as `/predict`) and
    receive data back in a universal format. The other components are used because
    they are popular choices when developing web applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Tools and technologies used for deploying a deep learning web
    application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15911_04_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.4: Tools and technologies used for deploying a deep learning web application'
  prefs: []
  type: TYPE_NORMAL
- en: 'These components fit together as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: System architecture for the web application built in this project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15911_04_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.5: System architecture for the web application built in this project'
  prefs: []
  type: TYPE_NORMAL
- en: A user visits the web application using their browser. That traffic is then
    routed by Nginx to the Docker container containing the Flask application (by default,
    running on port `5000`). The Flask application has instantiated our Bitcoin model
    at startup. If a model has been given, it uses that model without training; if
    not, it creates a new model and trains it from scratch using data from Yahoo Finance.
  prefs: []
  type: TYPE_NORMAL
- en: After having a model ready, the application verifies if the request has been
    cached on Redis; if yes, it returns the cached data. If no cache exists, then
    it will go ahead and issue predictions, which are rendered in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.02: Deploying and Using Cryptonic'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cryptonic is developed as a dockerized application. In Docker terms, this means
    that the application can be built as a Docker image and then deployed as a Docker
    container in either a development or a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we will see how to use Docker and Cryptonic to deploy the
    application. Before you begin, download Docker for Desktop from [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)
    Make sure that this application is running in the background before beginning
    the exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this exercise can be found at [https://packt.live/2AM5mLP](https://packt.live/2AM5mLP).
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker uses files called `Dockerfiles` to describe the rules for how to build
    an image and what happens when that image is deployed as a container. Cryptonic''s
    Dockerfile is available in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A Dockerfile can be used to build a Docker image with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command will make the `cryptonic:latest` image available to be deployed
    as a container. The building process can be repeated on a production server, or
    the image can be directly deployed and then run as a container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After an image has been built and is available, you can run the Cryptonic application
    by using the `docker run` command, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `--publish` flag binds port `5000` on localhost to port `5000` on the Docker
    container, and `--detach` runs the container as a daemon in the background.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In case you have trained a different model and would like to use that instead
    of training a new model, you can alter the `MODEL_NAME` environment variable on
    the `docker-compose.yml`. That variable should contain the filename of the model
    you have trained and want served (for example, `bitcoin_lstm_v1_trained.h5`);
    it should also be a Keras model. If you do that, make sure to also mount a local
    directory into the `/models` folder. The directory that you decide to mount must
    contain your model file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Cryptonic application also includes several environment variables that
    you may find useful when deploying your own model:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`MODEL_NAME`: Allows us to provide a trained model to be used by the application.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`BITCOIN_START_DATE`: Determines which day to use as the starting day for the
    Bitcoin series. Bitcoin prices have a lot more variance in recent years than earlier
    ones. This parameter filters the data to only years of interest. The default is
    `January 1, 2017`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`PERIOD_SIZE`: Sets the period size in terms of days. The default is `7`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`EPOCHS`: Configures the number of epochs that the model trains on every run.
    The default is `300`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These variables can be configured in the `docker-compose.yml` file. A part
    of this file is shown in the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The easiest way to deploy Cryptonic is to use the `docker-compose.yml` file
    in the repository ([https://packt.live/2AM5mLP](https://packt.live/2AM5mLP)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This file contains all the specifications necessary for the application to
    run, including instructions on how to connect with the Redis cache and what environment
    variables to use. After navigating to the location of the `docker-compose.yml`
    file, Cryptonic can then be started with the `docker-compose up` command, as shown
    in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `-d` flag executes the application in the background.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After deployment, Cryptonic can be accessed on port `5000` via a web browser.
    The application has an HTTP API that makes predictions when invoked. The API has
    the endpoint `/predict`, which returns a JSON object containing the de-normalized
    Bitcoin price prediction for a week into the future. Here''s a snippet showing
    an example JSON output from the `/predict` endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2ZZlZMm](https://packt.live/2ZZlZMm).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This section does not currently have an online interactive example, and will
    need to be run locally.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The application can now be deployed on a remote server and you can then use
    it to continuously predict Bitcoin prices. You'll be deploying an application
    in the activity that follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 4.01: Deploying a Deep Learning Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, based on the concepts explained up to now, try deploying the
    model as a local web application. You will need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `cryptonic` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the Docker images for the required components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the necessary parameters in `docker-compose.yml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the application using Docker on the localhost.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15911_04_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.6: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 150\.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This lesson concludes our journey into creating a deep learning model and deploying
    it as a web application. Our very last steps included deploying a model that predicts
    Bitcoin prices built using Keras and the TensorFlow engine. We finished our work
    by packaging the application as a Docker container and deploying it so that others
    can consume the predictions of our model, as well as other applications, via its
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from that work, you have also learned that there is much that can be
    improved. Our Bitcoin model is only an example of what a model can do (particularly
    LSTMs). The challenge now is twofold: how can you make that model perform better
    as time passes? And what features can you add to your web application to make
    your model more accessible? With the concepts you''ve learned in this book, you
    will be able to develop models and keep enhancing them to make accurate predictions.'
  prefs: []
  type: TYPE_NORMAL
