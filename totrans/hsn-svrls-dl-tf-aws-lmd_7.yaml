- en: Creating a Deep Learning Workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the AWS Step Functions service and also
    create AWS step functions by connecting to AWS Lambda using the AWS Console. You
    will also learn to create an AWS step function connection using the serverless
    framework and finally you will look into an example project for a deep learning
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the AWS Step Functions service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an AWS Step Functions connection to AWS Lambda using the AWS Console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an AWS Step Functions connection using the serverless framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep learning workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS subscription
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find all the code at [https://github.com/PacktPublishing/Hands-On-Serverless-Deep-Learning-with-TensorFlow-and-AWS-Lambda](https://github.com/PacktPublishing/Hands-On-Serverless-Deep-Learning-with-TensorFlow-and-AWS-Lambda)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the AWS Step Functions service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover  the AWS Step Functions service, including its
    features and also the pricing for using this service.
  prefs: []
  type: TYPE_NORMAL
- en: Processing workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The processing workflow is an additional method for interaction between the
    different services. If you want to build a multi-step process in deep learning,
    it could mean loading the data, then pre-processing data and running the model
    on it. While you can put queries between each of these backend nodes, it would
    be very hard to monitor the processing for a single task. This is where the workflow
    can be extremely convenient. Basically, the workflow service takes care of the
    invocation of each node when needed and handles the intermediate state of the
    processing job. It allows you to have a high-level view of what is happening with
    each task, and track task failures and timeouts. Finally, it allows you to have
    very flexible component usage as part of the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Step Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS Step Function is an AWS service that allows you to manage the workflow as
    a state machine. It can be connected to any processing backend and has a native
    integration with AWS Lambda. It has a pay-as-you-go system, which makes it very
    convenient.
  prefs: []
  type: TYPE_NORMAL
- en: AWS step function features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now look at the specific features of step functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Step functions are extremely scalable and you don't have to manage neither the
    scanning nor the workflow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step functions have a great visual UI, which enables easy monitoring of the
    processing jobs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State management allows you to add complex logic, such as choosing the next
    node based on the results of previous nodes, and it also allows for running several
    nodes in parallel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some functions have convenient logic for retrying tasks, which enables you to
    ensure processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in error handling allows you to handle cases. For example, when you encounter
    some exception and you need a way to add logic for error handling, such as marking
    a task as failed in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling allows you to run delayed processing tasks, which is very convenient
    for when you have to wait for another process to complete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Step Functions pricing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main advantages of step functions is the pay-as-you go system. It
    is very simple 25 cents per 10,000 requests, of which the  first 4,000 requests
    are free per month. This makes it perfect for early projects.
  prefs: []
  type: TYPE_NORMAL
- en: Step functions versus SQS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we dive deep into how the step functions are different from SQS in terms
    of features and possible use cases, we can say that SQS is most suitable for short,
    simple, low-priority tasks that can come in very large volumes (millions of tasks
    per day). Step functions, on the other hand, are most suitable for cases where
    we have complex multi-step processes, which can take a lot of time and where we
    would like to guarantee delivery of every task (thousands of tasks per day). In
    the next section, you will learn how to create an AWS Step Functions connection
    to AWS Lamda using the AWS Console.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AWS Step Functions connection to AWS Lambda using the AWS Console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create setp functions using the AWS Console. To create
    a step function, there are two main steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the AWS Lambda instance
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the step function that will use the Lambda instance
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the AWS Lambda instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will create an AWS Lambda instance using the AWS Console:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to Lambda to create the Lambda instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now enter the Name as `testLambdaStepFunction`, Runtime as Python 3.6, Role
    as Choose an existing role**,** and the existing role as `lamdaAdminRole`**.** Then
    click on Create function**,** which is at the bottom-right part of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00e5c249-acd6-4662-bee7-31721498178e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Lambda instance has been successfully created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/de5327bf-d4ad-43d1-b9c6-a7419822ac4a.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the step function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the step function, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Step Functions service and click on Create state machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9ba76c2a-c3c4-49ed-add0-adbaeecd6ecf.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Define state machine tab, enter the name as `testLambda:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b1850fe2-2c5a-41b1-9644-7a1dc5d66338.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we need to define `Type` as `Task` and the `Resource`. For the resource,
    you will need to use the ARN address of your Lambda, which you will find in the
    top-right corner of the tab. You can copy and paste this in the state machine
    definition section, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9a5a4d88-95b3-4a7a-a2ff-0f01fbc9eefa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will now create an IAM role, which is done automatically. Enter the name
    as `StepFunctionTestRole` and click on Create function**.** This will take up
    a minute before your state machine has permissions to execute properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b9269fed-f3f4-4d8f-97ff-5ccaa9177f9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, once we have created the step function, we can test and send a simple
    message. To do this, click on Start execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6eeb1272-b7ac-49bf-834b-17cc5274b0b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see the graph of execution here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9207d192-9679-4c39-a4af-4075e247888a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For each execution, you can see the input and output of the whole step function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/61cf30c5-e891-44cf-8836-a2a60be86e29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see the input and output of each node (this can be seen in the Step
    details tab). If there is an error, we will be able to see it in the Exception
    tab. Also, if you scroll down, you can also see the timeline of execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/18d7bb8b-5034-45ae-9976-2456b01b2aee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also check logs by using the link present in the Resource tab under
    the Step details tab by clicking on it. This will lead you to the following page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/91a97835-4c06-42cb-940b-2862cfec6508.png)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, we can see that step function is a very convenient service for managing
    Lambda execution.
  prefs: []
  type: TYPE_NORMAL
- en: Creating AWS step functions for an AWS Lambda instance using the serverless
    framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll create step functions using the serverless framework. First,
    let''s take a look at our project files: one Python file and the serverless configuration
    file. In the configuration file, we will be adding a few plugins and describing
    step functions, which is a complex thing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s explore the step functions in the serverless configuration file
    by beginning with the live code:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploy the serverless framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the CLI, check the deployment status of the serverless framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, check the step function result using the AWS Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's check the list of files that we have by executing the `ls` command. As
    you can see, we have the `index.py` file and the `serverless.yml` configuration
    file service document. We also have installed plugins for the serverless framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the configuration file and its two main parts here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will be adding several functions, which will be used in different
    states of the step function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add some plugins, which are required to work with step functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s take a look at the `index.py` file, where you can see all the parts
    discussed so far:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Serverless deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s deploy our service by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command deploys your service, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fd7abbc-8d56-49fe-a645-bbf47f4bb674.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As part of the deployment, it will give us the URL of the API Gateway, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15414d25-539f-4323-9630-cd4b6c5f0af1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s test the URL in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check with the results in your browser. In the following screenshot,
    you can see our step function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34adc7b7-87bb-4a80-a839-07fcd728150f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following screenshot, we can see that the latest execution went successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10f5436d-2d88-401d-973e-078edbe7d840.png)'
  prefs: []
  type: TYPE_IMG
- en: You can check the input and output of each node. If there are any errors, you
    can check them in the Exception section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both branches returned hello world and the step node combines the result and
    returns it as the result of the step function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd522dd4-b292-4a6a-b092-d2dd3757f580.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, let's check with the timeline of the execution. You can also see that
    the branches have started almost at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at an example of the deep learning workflow
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Example project – deep learning workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's take a look at our following project files. We have the main Python
    file, the service integration file, and a few libraries and inception models. In
    the configuration file, we will be adding a few plugins and describing step functions,
    which is a complex thing.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference with our Python file will be that we will have three functions
    . One will map a list of URL links into separate things. Another will run a model
    on the link. The final one will combine the results. The structure of the deployment
    will be similar to the one in the previous section. We will skip the deployment
    of the model to S3, since we covered it in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we will need to deploy the serverless framework and then we can check
    the trance using the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the configuration file. You can see all the main parts and roles
    that we need to define to access the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the functions, which we will use in different states of the step function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`map` will enable the mapping of the incoming event into different Lambdas,
    range will enable the processing of each link separately in parallel, and `reduce`
    will help in combining them in one response.  We have the state machine definition,
    which is very similar to that previously discussed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have plugins, which are required to work the functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The main difference in our index file from the previous section is that we
    added the MapReduce logic. This will enable the processing of each URL separately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For this case, we'll have three URLs,for the dog, panda, and red panda images
    taken from the free images website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have our model ready, let''s deploy the service using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You will have the URL for the API to test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's test this URL. We will need to use the `curl` command, which will be a
    little different from its usages previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First of all, we will use `POST` requests instead of `GET` requests, and we
    will provide a list of links as both of the request. As you can see, it returned
    successfully. This execution indicates that it successfully sent the command to
    the step function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/46ee1384-e17a-44cf-bf3d-6da9e89362a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s look at the graph in the browser. We can see that it has already
    finished the execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7432b778-a596-4b95-90c2-de0d4257f6b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that each branch received a separate URL, and we can see that the
    final note combined results from different branches as single, and that it successfully
    recognized the images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/74d04458-0193-4cda-9049-e2770a6e231d.png)'
  prefs: []
  type: TYPE_IMG
- en: Also, we can check the timeline of the execution and see that almost all the
    branches started at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the parallelization really enabled us to process a list of links
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied the AWS Step Functions service, including its features
    and pricing. We also learned how to connect AWS Step Functions to AWS Lambda using
    the AWS Console. We also saw how to create a step function using the serverless
    framework and even created a deep learning workflow.
  prefs: []
  type: TYPE_NORMAL
