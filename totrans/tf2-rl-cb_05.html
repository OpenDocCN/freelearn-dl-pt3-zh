<html><head></head><body>
		<div id="_idContainer078">
			<h1 id="_idParaDest-126"><em class="italic"><a id="_idTextAnchor153"/>Chapter 5</em>: Reinforcement Learning in the Real World – Building Stock/Share Trading Agents</h1>
			<p>Software-based <strong class="bold">deep reinforcement learning</strong> (<strong class="bold">deep RL</strong>) agents have tremendous potential when it comes to executing trading strategies tirelessly and flawlessly without limitations based on memory capacity, speed, efficiency, and emotional disturbances that a human trader is prone to facing. Profitable trading in the stock market involves carefully executing buy/sell trades with stock symbols/tickers while taking into account several market factors such as trading conditions and macro and micro market conditions, in addition to social, political, and company-specific changes. Deep RL agents have a lot of potential when it comes to solving challenging problems in the real world and a lot of opportunities exist. </p>
			<p>However, only a few successful stories of using deep RL agents in the real world beyond games exist due to the various challenges associated with real-world deployments of RL agents. This chapter contains recipes that will help you successfully develop RL agents for yet another interesting and rewarding real-world problem: stock market trading. The recipes provided contain information on how to implement custom OpenAI Gym-compatible learning environments for stock market trading with both discrete and continuous value action spaces. In addition, you will learn how to build and train RL agents for stock trading learning environments.</p>
			<p>Specifically, the following recipes will be covered in this chapter:</p>
			<ul>
				<li>Building a stock market trading RL platform using real stock exchange data</li>
				<li>Building a stock market trading RL platform using price charts</li>
				<li>Building an advanced stock trading RL platform to train agents to mimic professional traders</li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor154"/>Technical requirements</h1>
			<p>The code in this book has been extensively tested on Ubuntu 18.04 and Ubuntu 20.04 and should work with later versions of Ubuntu if Python 3.6+ is available. With Python 3.6+ installed, along with the necessary Python packages, as listed at the start of each of the recipes, the code should run fine on Windows and Mac OS X too. You should create and use a Python virtual environment named <strong class="source-inline">tf2rl-cookbook</strong> to install the packages and run the code in this book. Installing Miniconda or Anaconda for Python virtual environment management is recommended.</p>
			<p>The complete code for each recipe in each chapter is available here: <a href="https://github.com/PacktPublishing/Tensorflow-2-Reinforcement-Learning-Cookbook">https://github.com/PacktPublishing/Tensorflow-2-Reinforcement-Learning-Cookbook</a>.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor155"/>Building a stock market trading RL platform using real stock exchange data</h1>
			<p>The<a id="_idIndexMarker507"/> stock<a id="_idIndexMarker508"/> market provides anyone with a highly lucrative opportunity to participate and make profits. While it is easily accessible, not all humans can make consistently profitable trades due to the dynamic nature of the market and the emotional aspects that can impair people's actions. RL agents take emotion out of the equation and can be trained to make profits consistently. This recipe will teach you how to implement a stock market trading environment that will teach your RL agents how to trade stocks using real stock market data. When you have trained them enough, you can deploy them so that they automatically make trades (and profits) for you!</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor156"/>Getting ready</h2>
			<p>To complete this recipe, make sure you have the latest version. You will need to activate the <strong class="source-inline">tf2rl-cookbook</strong> Python/conda virtual environment. Make sure you update the environment so that it matches the latest conda environment specification file (<strong class="source-inline">tfrl-cookbook.yml</strong>), which can be found in this cookbook's code repository. If the following <strong class="source-inline">import</strong> statements run without any issues, you are ready to get started:</p>
			<p class="source-code">import os</p>
			<p class="source-code">import random</p>
			<p class="source-code">from typing import Dict</p>
			<p class="source-code">import gym</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">from gym import spaces</p>
			<p class="source-code">from trading_utils import TradeVisualizer</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor157"/>How to do it…</h2>
			<p>Follow<a id="_idIndexMarker509"/> this step-by-step<a id="_idIndexMarker510"/> process to implement <strong class="source-inline">StockTradingEnv</strong>: </p>
			<ol>
				<li>Let's initialize the configurable parameters of the environment:<p class="source-code">env_config = {</p><p class="source-code">    "ticker": "TSLA",</p><p class="source-code">    "opening_account_balance": 1000,</p><p class="source-code">    # Number of steps (days) of data provided to the </p><p class="source-code">    # agent in one observation</p><p class="source-code">    "observation_horizon_sequence_length": 30,</p><p class="source-code">    "order_size": 1,  # Number of shares to buy per </p><p class="source-code">    # buy/sell order</p><p class="source-code">}</p></li>
				<li>Let's <a id="_idIndexMarker511"/>initialize the <strong class="source-inline">StockTradingEnv</strong> class and load the stock market data for the configured<a id="_idIndexMarker512"/> stock ticker symbol:<p class="source-code">class StockTradingEnv(gym.Env):</p><p class="source-code">    def __init__(self, env_config: Dict = env_config):</p><p class="source-code">        """Stock trading environment for RL agents</p><p class="source-code">        Args:</p><p class="source-code">            ticker (str, optional): Ticker symbol for the</p><p class="source-code">            stock. Defaults to "MSFT".</p><p class="source-code">            env_config (Dict): Env configuration values</p><p class="source-code">        """</p><p class="source-code">        super(StockTradingEnv, self).__init__()</p><p class="source-code">        self.ticker = env_config.get("ticker", "MSFT")</p><p class="source-code">        data_dir = os.path.join(os.path.dirname(os.path.\</p><p class="source-code">                             realpath(__file__)), "data")</p><p class="source-code">        self.ticker_file_stream = os.path.join(f"{</p><p class="source-code">                        data_dir}", f"{self.ticker}.csv")</p></li>
				<li>Let's make sure that the stock market data source exists and then load the data stream:<p class="source-code">        assert os.path.isfile(</p><p class="source-code">            self.ticker_file_stream</p><p class="source-code">        ), f"Historical stock data file stream not found </p><p class="source-code">         at: data/{self.ticker}.csv"</p><p class="source-code">        # Stock market data stream. An offline file </p><p class="source-code">        # stream is used. Alternatively, a web</p><p class="source-code">        # API can be used to pull live data.</p><p class="source-code">        # Data-Frame: Date Open High Low Close Adj-Close </p><p class="source-code">        # Volume</p><p class="source-code">        self.ohlcv_df = \</p><p class="source-code">            pd.read_csv(self.ticker_file_stream)</p></li>
				<li>We are<a id="_idIndexMarker513"/> now ready to define the observation and action space/environment in order to complete our<a id="_idIndexMarker514"/> initialization function definition:<p class="source-code">        self.opening_account_balance = \</p><p class="source-code">            env_config["opening_account_balance"]</p><p class="source-code">        # Action: 0-&gt; Hold; 1-&gt; Buy; 2 -&gt;Sell;</p><p class="source-code">        self.action_space = spaces.Discrete(3)</p><p class="source-code">        self.observation_features = [</p><p class="source-code">            "Open",</p><p class="source-code">            "High",</p><p class="source-code">            "Low",</p><p class="source-code">            "Close",</p><p class="source-code">            "Adj Close",</p><p class="source-code">            "Volume",</p><p class="source-code">        ]</p><p class="source-code">        self.horizon = env_config.get(</p><p class="source-code">                   "observation_horizon_sequence_length")</p><p class="source-code">        self.observation_space = spaces.Box(</p><p class="source-code">            low=0,</p><p class="source-code">            high=1,</p><p class="source-code">            shape=(len(self.observation_features),</p><p class="source-code">                   self.horizon + 1),</p><p class="source-code">            dtype=np.float,</p><p class="source-code">        )</p><p class="source-code">        self.order_size = env_config.get("order_size")</p></li>
				<li>Next, we<a id="_idIndexMarker515"/> will implement<a id="_idIndexMarker516"/> a method so that we can gather observations:<p class="source-code">    def get_observation(self):</p><p class="source-code">        # Get stock price info data table from input </p><p class="source-code">        # (file/live) stream</p><p class="source-code">        observation = (</p><p class="source-code">            self.ohlcv_df.loc[</p><p class="source-code">                self.current_step : self.current_step + \</p><p class="source-code">                     self.horizon,</p><p class="source-code">                self.observation_features,</p><p class="source-code">            ]</p><p class="source-code">            .to_numpy()</p><p class="source-code">            .T</p><p class="source-code">        )</p><p class="source-code">        return observation</p></li>
				<li>Next, to<a id="_idIndexMarker517"/> execute a<a id="_idIndexMarker518"/> trade order, we need the required logic to be in place. Let's add this now:<p class="source-code">    def execute_trade_action(self, action):</p><p class="source-code">        if action == 0:  # Hold position</p><p class="source-code">            return</p><p class="source-code">        order_type = "buy" if action == 1 else "sell"</p><p class="source-code">        # Stochastically determine the current stock </p><p class="source-code">        # price based on Market Open &amp; Close</p><p class="source-code">        current_price = random.uniform(</p><p class="source-code">            self.ohlcv_df.loc[self.current_step, "Open"],</p><p class="source-code">            self.ohlcv_df.loc[self.current_step, </p><p class="source-code">                              "Close"],</p><p class="source-code">        )</p></li>
				<li>With the initialization done, we can add the logic for buying stock:<p class="source-code">        if order_type == "buy":</p><p class="source-code">            allowable_shares = \</p><p class="source-code">                int(self.cash_balance / current_price)</p><p class="source-code">            if allowable_shares &lt; self.order_size:</p><p class="source-code">                # Not enough cash to execute a buy order</p><p class="source-code">                # return</p><p class="source-code">            # Simulate a BUY order and execute it at</p><p class="source-code">            # current_price</p><p class="source-code">            num_shares_bought = self.order_size</p><p class="source-code">            current_cost = self.cost_basis * \</p><p class="source-code">                           self.num_shares_held</p><p class="source-code">            additional_cost = num_shares_bought * \</p><p class="source-code">                              current_price</p><p class="source-code">            self.cash_balance -= additional_cost</p><p class="source-code">            self.cost_basis = (current_cost + \</p><p class="source-code">                               additional_cost) / (</p><p class="source-code">                self.num_shares_held + num_shares_bought</p><p class="source-code">            )</p><p class="source-code">            self.num_shares_held += num_shares_bought</p><p class="source-code">            self.trades.append(</p><p class="source-code">                {</p><p class="source-code">                    "type": "buy",</p><p class="source-code">                    "step": self.current_step,</p><p class="source-code">                    "shares": num_shares_bought,</p><p class="source-code">                    "proceeds": additional_cost,</p><p class="source-code">                }</p><p class="source-code">            )</p></li>
				<li>Likewise, we <a id="_idIndexMarker519"/>can now <a id="_idIndexMarker520"/>add the logic for selling stock:<p class="source-code">        elif order_type == "sell":</p><p class="source-code">            # Simulate a SELL order and execute it at </p><p class="source-code">            # current_price</p><p class="source-code">            if self.num_shares_held &lt; self.order_size:</p><p class="source-code">                # Not enough shares to execute a sell </p><p class="source-code">                # order</p><p class="source-code">                return</p><p class="source-code">            num_shares_sold = self.order_size</p><p class="source-code">            self.cash_balance += num_shares_sold * \</p><p class="source-code">                                 current_price</p><p class="source-code">            self.num_shares_held -= num_shares_sold</p><p class="source-code">            sale_proceeds = num_shares_sold * current_price</p><p class="source-code">            self.trades.append(</p><p class="source-code">                {</p><p class="source-code">                    "type": "sell",</p><p class="source-code">                    "step": self.current_step,</p><p class="source-code">                    "shares": num_shares_sold,</p><p class="source-code">                    "proceeds": sale_proceeds,</p><p class="source-code">                }</p><p class="source-code">            )</p></li>
				<li>Finally, let's<a id="_idIndexMarker521"/> update the account<a id="_idIndexMarker522"/> balance:<p class="source-code">        # Update account value</p><p class="source-code">        self.account_value = self.cash_balance + \</p><p class="source-code">                             self.num_shares_held * \</p><p class="source-code">                             current_price</p></li>
				<li>We are <a id="_idIndexMarker523"/>now ready to fire and <a id="_idIndexMarker524"/>check out the new environment:<p class="source-code">if __name__ == "__main__":</p><p class="source-code">    env = StockTradingEnv()</p><p class="source-code">    obs = env.reset()</p><p class="source-code">    for _ in range(600):</p><p class="source-code">        action = env.action_space.sample()</p><p class="source-code">        next_obs, reward, done, _ = env.step(action)</p><p class="source-code">        env.render()</p></li>
			</ol>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor158"/>How it works…</h2>
			<p>The observations are stock price information (OHLCV) over a horizon, as specified in <strong class="source-inline">env_config</strong>. The action space is discrete to allow us to perform buy/sell/hold trades. This is a starter environment for RL agents to learn to trade stocks in the stock market. Happy training!</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor159"/>Building a stock market trading RL platform using price charts</h1>
			<p>Human<a id="_idIndexMarker525"/> traders look at several<a id="_idIndexMarker526"/> indicators on their price monitor in order to vet and identify a potential trade. Can we allow the agents to also visually look at the price candlestick charts to trade stocks instead of providing just a tabular/CSV representation? Yes, we can! This recipe will teach you how to build a visually rich trading environment for your RL agents.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor160"/>Getting ready</h2>
			<p>To complete <a id="_idIndexMarker527"/>this recipe, make sure you <a id="_idIndexMarker528"/>have the latest version. You will need to activate the <strong class="source-inline">tf2rl-cookbook</strong> Python/conda virtual environment. Make sure that you update the environment so that it matches the latest conda environment specification file (<strong class="source-inline">tfrl-cookbook.yml</strong>), which can be found in this cookbook's code repository. If the following <strong class="source-inline">import</strong> statements run without any issues, you are ready to get started:</p>
			<p class="source-code">import os</p>
			<p class="source-code">import random</p>
			<p class="source-code">from typing import Dict</p>
			<p class="source-code">import cv2</p>
			<p class="source-code">import gym</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">from gym import spaces</p>
			<p class="source-code">from trading_utils import TradeVisualizer</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor161"/>How to do it…</h2>
			<p>Let's start by configuring the environment. Then, we will guide you through the process of completing the implementation. By the end of this recipe, you will have built a complete stock trading RL environment that allows an agent to process visual stock charts and make trading decisions. </p>
			<p>Let's get started:</p>
			<ol>
				<li value="1">Configure the learning environment, as follows:<p class="source-code">env_config = {</p><p class="source-code">    "ticker": "TSLA",</p><p class="source-code">    "opening_account_balance": 100000,</p><p class="source-code">    # Number of steps (days) of data provided to the </p><p class="source-code">    # agent in one observation</p><p class="source-code">    "observation_horizon_sequence_length": 30,</p><p class="source-code">    "order_size": 1,  # Number of shares to buy per </p><p class="source-code">     # buy/sell order</p><p class="source-code">}</p></li>
				<li>Let's <a id="_idIndexMarker529"/>implement the<a id="_idIndexMarker530"/> initialization step for <strong class="source-inline">StockTradingVisualEnv</strong>:<p class="source-code">class StockTradingVisualEnv(gym.Env):</p><p class="source-code">    def __init__(self, env_config: Dict = env_config):</p><p class="source-code">        """Stock trading environment for RL agents</p><p class="source-code">        </p><p class="source-code">        Args:</p><p class="source-code">            ticker (str, optional): Ticker symbol for the </p><p class="source-code">            stock. Defaults to "MSFT".</p><p class="source-code">            env_config (Dict): Env configuration values</p><p class="source-code">        """</p><p class="source-code">        super(StockTradingVisualEnv, self).__init__()</p><p class="source-code">        self.ticker = env_config.get("ticker", "MSFT")</p><p class="source-code">        data_dir = os.path.join(os.path.dirname(os.path.\</p><p class="source-code">                             realpath(__file__)), "data")</p><p class="source-code">        self.ticker_file_stream = os.path.join(</p><p class="source-code">                     f"{data_dir}", f"{self.ticker}.csv")</p><p class="source-code">        assert os.path.isfile(</p><p class="source-code">            self.ticker_file_stream</p><p class="source-code">        ), f"Historical stock data file stream not found\</p><p class="source-code">             at: data/{self.ticker}.csv"</p><p class="source-code">        # Stock market data stream. An offline file </p><p class="source-code">        # stream is used. Alternatively, a web</p><p class="source-code">        # API can be used to pull live data.</p><p class="source-code">        # Data-Frame: Date Open High Low Close Adj-Close </p><p class="source-code">        # Volume</p><p class="source-code">        self.ohlcv_df = \</p><p class="source-code">            pd.read_csv(self.ticker_file_stream)</p></li>
				<li>Let's<a id="_idIndexMarker531"/> complete the<a id="_idIndexMarker532"/> implementation of the <strong class="source-inline">__init__</strong> method:<p class="source-code">        self.opening_account_balance = \</p><p class="source-code">            env_config["opening_account_balance"]</p><p class="source-code">        </p><p class="source-code">        self.action_space = spaces.Discrete(3)</p><p class="source-code">        self.observation_features = [</p><p class="source-code">            "Open",</p><p class="source-code">            "High",</p><p class="source-code">            "Low",</p><p class="source-code">            "Close",</p><p class="source-code">            "Adj Close",</p><p class="source-code">            "Volume",</p><p class="source-code">        ]</p><p class="source-code">        self.obs_width, self.obs_height = 128, 128</p><p class="source-code">        self.horizon = env_config.get(</p><p class="source-code">            "observation_horizon_sequence_length")</p><p class="source-code">        self.observation_space = spaces.Box(</p><p class="source-code">            low=0, high=255, shape=(128, 128, 3),</p><p class="source-code">            dtype=np.uint8,</p><p class="source-code">        )</p><p class="source-code">        self.order_size = env_config.get("order_size")</p><p class="source-code">        self.viz = None  # Visualizer</p></li>
				<li>The next<a id="_idIndexMarker533"/> step to is the <a id="_idIndexMarker534"/>define the <strong class="source-inline">step</strong> method for the environment:<p class="source-code">    def step(self, action):</p><p class="source-code">        # Execute one step within the trading environment</p><p class="source-code">        self.execute_trade_action(action)</p><p class="source-code">        self.current_step += 1</p><p class="source-code">        reward = self.account_value - \</p><p class="source-code">            self.opening_account_balance  # Profit (loss)</p><p class="source-code">        done = self.account_value &lt;= 0 or \</p><p class="source-code">                  self.current_step &gt;= len(</p><p class="source-code">            self.ohlcv_df.loc[:, "Open"].values</p><p class="source-code">        )</p><p class="source-code">        obs = self.get_observation()</p><p class="source-code">        return obs, reward, done, {}</p></li>
				<li>Let's implement<a id="_idIndexMarker535"/> the two<a id="_idIndexMarker536"/> missing methods we used in the preceding step. To implement the <strong class="source-inline">get_observation</strong> method, we will need the <strong class="source-inline">TradeVisualizer</strong> method to be initialized. Due to this, let's implement the <strong class="source-inline">reset</strong> method first:<p class="source-code">    def reset(self):</p><p class="source-code">        # Reset the state of the environment to an </p><p class="source-code">        # initial state</p><p class="source-code">        self.cash_balance = self.opening_account_balance</p><p class="source-code">        self.account_value = self.opening_account_balance</p><p class="source-code">        self.num_shares_held = 0</p><p class="source-code">        self.cost_basis = 0</p><p class="source-code">        self.current_step = 0</p><p class="source-code">        self.trades = []</p><p class="source-code">        if self.viz is None:</p><p class="source-code">            self.viz = TradeVisualizer(</p><p class="source-code">                self.ticker,</p><p class="source-code">                self.ticker_file_stream,</p><p class="source-code">                "TFRL-Cookbook Ch4-StockTradingVisualEnv",</p><p class="source-code">            )</p><p class="source-code">        return self.get_observation()</p></li>
				<li>Now, let's continue<a id="_idIndexMarker537"/> with our <a id="_idIndexMarker538"/>implementation of the <strong class="source-inline">get_observation</strong> method:<p class="source-code">    def get_observation(self):</p><p class="source-code">        """Return a view of the Ticker price chart as </p><p class="source-code">           image observation</p><p class="source-code">        Returns:</p><p class="source-code">            img_observation (np.ndarray): Image of ticker </p><p class="source-code">            candle stick plot with volume bars as </p><p class="source-code">            observation</p><p class="source-code">        """</p><p class="source-code">        img_observation = \</p><p class="source-code">            self.viz.render_image_observation(</p><p class="source-code">                self.current_step, self.horizon</p><p class="source-code">            )</p><p class="source-code">        img_observation = cv2.resize(</p><p class="source-code">            img_observation, dsize=(128, 128), </p><p class="source-code">            interpolation=cv2.INTER_CUBIC</p><p class="source-code">        )</p><p class="source-code">        return img_observation</p></li>
				<li>It's time to implement the logic that will execute the trade actions taken by the agent. We'll split our implementation of the trade execution logic into the next three steps:<p class="source-code">   def execute_trade_action(self, action):</p><p class="source-code">        if action == 0:  # Hold position</p><p class="source-code">            return</p><p class="source-code">        order_type = "buy" if action == 1 else "sell"</p><p class="source-code">        # Stochastically determine the current stock </p><p class="source-code">        # price based on Market Open &amp; Close</p><p class="source-code">        current_price = random.uniform(</p><p class="source-code">            self.ohlcv_df.loc[self.current_step, "Open"],</p><p class="source-code">            self.ohlcv_df.loc[self.current_step, \</p><p class="source-code">                              "Close"],</p><p class="source-code">        ) </p></li>
				<li>Let's implement <a id="_idIndexMarker539"/>the logic to<a id="_idIndexMarker540"/> execute <strong class="source-inline">"buy"</strong> orders:<p class="source-code">if order_type == "buy":</p><p class="source-code">            allowable_shares = \</p><p class="source-code">                int(self.cash_balance / current_price)</p><p class="source-code">            if allowable_shares &lt; self.order_size:</p><p class="source-code">                return</p><p class="source-code">            num_shares_bought = self.order_size</p><p class="source-code">            current_cost = self.cost_basis * \</p><p class="source-code">                            self.num_shares_held</p><p class="source-code">            additional_cost = num_shares_bought * \</p><p class="source-code">                               current_price</p><p class="source-code">            self.cash_balance -= additional_cost</p><p class="source-code">            self.cost_basis = (current_cost + \</p><p class="source-code">                               additional_cost)/ \</p><p class="source-code">                              (self.num_shares_held +\</p><p class="source-code">                                num_shares_bought)</p><p class="source-code">            self.num_shares_held += num_shares_bought</p><p class="source-code">            self.trades.append(</p><p class="source-code">                {   "type": "buy",</p><p class="source-code">                    "step": self.current_step,</p><p class="source-code">                    "shares": num_shares_bought,</p><p class="source-code">                    "proceeds": additional_cost,</p><p class="source-code">                }</p><p class="source-code">        )</p></li>
				<li>Now, let's <a id="_idIndexMarker541"/>take care of <a id="_idIndexMarker542"/>handling <strong class="source-inline">"sell"</strong> orders:<p class="source-code">elif order_type == "sell":</p><p class="source-code">            # Simulate a SELL order and execute it at </p><p class="source-code">            # current_price</p><p class="source-code">            if self.num_shares_held &lt; self.order_size:</p><p class="source-code">                # Not enough shares to execute a sell </p><p class="source-code">                # order</p><p class="source-code">                return</p><p class="source-code">            num_shares_sold = self.order_size</p><p class="source-code">            self.cash_balance += num_shares_sold * \</p><p class="source-code">                                 current_price</p><p class="source-code">            self.num_shares_held -= num_shares_sold</p><p class="source-code">            sale_proceeds = num_shares_sold * \</p><p class="source-code">                            current_price</p><p class="source-code">            self.trades.append(</p><p class="source-code">                {</p><p class="source-code">                    "type": "sell",</p><p class="source-code">                    "step": self.current_step,</p><p class="source-code">                    "shares": num_shares_sold,</p><p class="source-code">                    "proceeds": sale_proceeds,</p><p class="source-code">                }</p><p class="source-code">            )</p><p class="source-code">        if self.num_shares_held == 0:</p><p class="source-code">            self.cost_basis = 0</p><p class="source-code">        # Update account value</p><p class="source-code">        self.account_value = self.cash_balance + \</p><p class="source-code">                             self.num_shares_held * \</p><p class="source-code">                             current_price</p></li>
				<li>With that, our<a id="_idIndexMarker543"/> implementation is complete! We are now ready to test the environment using a randomly <a id="_idIndexMarker544"/>acting agent:<p class="source-code">if __name__ == "__main__":</p><p class="source-code">    env = StockTradingVisualEnv()</p><p class="source-code">    obs = env.reset()</p><p class="source-code">    for _ in range(600):</p><p class="source-code">        action = env.action_space.sample()</p><p class="source-code">        next_obs, reward, done, _ = env.step(action)</p><p class="source-code">        env.render()</p></li>
			</ol>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor162"/>How it works…</h2>
			<p>The observations in <strong class="source-inline">StockTradingVisualEnv</strong> are stock price information (OHLCV) over a horizon, as specified in <strong class="source-inline">env_config</strong>. The action space is discrete so that we can buy/sell/hold trades. More specifically, the action has the following meaning: 0-&gt; Hold; 1-&gt; Buy; 2 -&gt;Sell.</p>
			<p>The following<a id="_idIndexMarker545"/> image illustrates the <a id="_idIndexMarker546"/>environment in action:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B15074_05_01.jpg" alt="Figure 5.1 – A sample screenshot of StockTradingVisualEnv in action "/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – A sample screenshot of StockTradingVisualEnv in action</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor163"/>Building an advanced stock trading RL platform to train agents to mimic professional traders</h1>
			<p>This recipe will<a id="_idIndexMarker547"/> help you implement a complete stock trading environment with high-dimensional image observation spaces and continuous action spaces for training your RL and deep RL agents. This will allow you to build intelligent trading bots using RL so that you can closely approximate how a professional stock trader would trade stocks. Like a professional trader, the RL agent you'll train will watch the stock market data in the form of candlesticks and price line charts and make trading decisions. A well-trained RL agent could potentially make thousands of profitable trades without needing a break or commission, unlike a human professional trader, thereby increasing your profits! </p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor164"/>Getting ready</h2>
			<p>To complete this <a id="_idIndexMarker548"/>recipe, make sure you have the latest version. You will need to activate the <strong class="source-inline">tf2rl-cookbook</strong> Python/conda virtual environment. Make sure that you update the environment so that it matches the latest conda environment specification file (<strong class="source-inline">tfrl-cookbook.yml</strong>), which can be found in this cookbook's code repository. If the following <strong class="source-inline">import</strong> statements run without any issues, you are ready to get started:</p>
			<p class="source-code">import os</p>
			<p class="source-code">import random</p>
			<p class="source-code">from typing import Dict</p>
			<p class="source-code">import cv2</p>
			<p class="source-code">import gym</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">from gym import spaces</p>
			<p class="source-code">from trading_utils import TradeVisualizer</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor165"/>How to do it…</h2>
			<p>By now, you must be familiar with the basic flow of the implementation from having worked through the previous recipes in this chapter. Follow these steps to put together a complete stock trading environment from scratch for training your advanced RL agents:</p>
			<ol>
				<li value="1">Let's <a id="_idIndexMarker549"/>begin our implementation of <strong class="source-inline">StockTradingVisualContinuousEnv</strong>:<p class="source-code">    def __init__(self, env_config: Dict = env_config):</p><p class="source-code">        """Stock trading environment for RL agents with </p><p class="source-code">           continuous action space</p><p class="source-code">        Args:</p><p class="source-code">            ticker (str, optional): Ticker symbol for the </p><p class="source-code">            stock. Defaults to "MSFT".</p><p class="source-code">            env_config (Dict): Env configuration values</p><p class="source-code">        """</p><p class="source-code">        super(StockTradingVisualContinuousEnv, </p><p class="source-code">              self).__init__()</p><p class="source-code">        self.ticker = env_config.get("ticker", "MSFT")</p><p class="source-code">        data_dir = os.path.join(os.path.dirname(os.path.\</p><p class="source-code">                             realpath(__file__)), "data")</p><p class="source-code">        self.ticker_file_stream = os.path.join(</p><p class="source-code">                     f"{data_dir}", f"{self.ticker}.csv")</p><p class="source-code">        assert os.path.isfile(</p><p class="source-code">            self.ticker_file_stream</p><p class="source-code">        ), f"Historical stock data file stream not found</p><p class="source-code">             at: data/{self.ticker}.csv"</p><p class="source-code">        </p><p class="source-code">        self.ohlcv_df = \</p><p class="source-code">            pd.read_csv(self.ticker_file_stream)</p></li>
				<li>Let's define the state space, action space, and other essential variables to complete<a id="_idIndexMarker550"/> the <strong class="source-inline">__init__</strong> function's implementation:<p class="source-code">        self.opening_account_balance = \</p><p class="source-code">            env_config["opening_account_balance"]</p><p class="source-code">        # Action: 1-dim value indicating a fraction </p><p class="source-code">        # amount of shares to Buy (0 to 1) or</p><p class="source-code">        # sell (-1 to 0). The fraction is taken on the </p><p class="source-code">        # allowable number of</p><p class="source-code">        # shares that can be bought or sold based on the </p><p class="source-code">        # account balance (no margin).</p><p class="source-code">        self.action_space = spaces.Box(</p><p class="source-code">            low=np.array([-1]), high=np.array([1]), </p><p class="source-code">                dtype=np.float</p><p class="source-code">        )</p><p class="source-code">        self.observation_features = [</p><p class="source-code">            "Open",</p><p class="source-code">            "High",</p><p class="source-code">            "Low",</p><p class="source-code">            "Close",</p><p class="source-code">            "Adj Close",</p><p class="source-code">            "Volume",</p><p class="source-code">        ]</p><p class="source-code">        self.obs_width, self.obs_height = 128, 128</p><p class="source-code">        self.horizon = env_config.get(</p><p class="source-code">            "observation_horizon_sequence_length")</p><p class="source-code">        self.observation_space = spaces.Box(</p><p class="source-code">            low=0, high=255, shape=(128, 128, 3), </p><p class="source-code">            dtype=np.uint8,</p><p class="source-code">        )</p><p class="source-code">        self.viz = None  # Visualizer</p></li>
				<li>Next, let's<a id="_idIndexMarker551"/> implement the <strong class="source-inline">get_observation</strong> method:<p class="source-code">    def get_observation(self):</p><p class="source-code">        """Return a view of the Ticker price chart as </p><p class="source-code">           image observation</p><p class="source-code">        Returns:</p><p class="source-code">            img_observation (np.ndarray): Image of ticker </p><p class="source-code">            candle stick plot with volume bars as </p><p class="source-code">            observation</p><p class="source-code">        """</p><p class="source-code">        img_observation = \</p><p class="source-code">            self.viz.render_image_observation(</p><p class="source-code">            self.current_step, self.horizon</p><p class="source-code">        )</p><p class="source-code">        img_observation = cv2.resize(</p><p class="source-code">            img_observation, dsize=(128, 128), </p><p class="source-code">            interpolation=cv2.INTER_CUBIC</p><p class="source-code">        )</p><p class="source-code">        return img_observation</p></li>
				<li>Let's <a id="_idIndexMarker552"/>initialize the trade execution logic:<p class="source-code">    def execute_trade_action(self, action):</p><p class="source-code">        if action == 0:  # Indicates "Hold" action</p><p class="source-code">            # Hold position; No trade to be executed</p><p class="source-code">            return</p><p class="source-code">        order_type = "buy" if action &gt; 0 else "sell"</p><p class="source-code">        order_fraction_of_allowable_shares = abs(action)</p><p class="source-code">        # Stochastically determine the current stock </p><p class="source-code">        # price based on Market Open &amp; Close</p><p class="source-code">        current_price = random.uniform(</p><p class="source-code">            self.ohlcv_df.loc[self.current_step, "Open"],</p><p class="source-code">            self.ohlcv_df.loc[self.current_step, </p><p class="source-code">                              "Close"],</p><p class="source-code">        )</p></li>
				<li>We are now ready to define the behavior of a <strong class="source-inline">"buy"</strong> action:<p class="source-code">        if order_type == "buy":</p><p class="source-code">            allowable_shares = \</p><p class="source-code">                int(self.cash_balance / current_price)</p><p class="source-code">            # Simulate a BUY order and execute it at </p><p class="source-code">            # current_price</p><p class="source-code">            num_shares_bought = int(</p><p class="source-code">                allowable_shares * \</p><p class="source-code">                    order_fraction_of_allowable_shares</p><p class="source-code">            )</p><p class="source-code">            current_cost = self.cost_basis * \</p><p class="source-code">                           self.num_shares_held</p><p class="source-code">            additional_cost = num_shares_bought * \</p><p class="source-code">                              current_price</p><p class="source-code">            self.cash_balance -= additional_cost</p><p class="source-code">            self.cost_basis = (current_cost + \</p><p class="source-code">                               additional_cost) / (</p><p class="source-code">                self.num_shares_held + num_shares_bought</p><p class="source-code">            )</p><p class="source-code">            self.num_shares_held += num_shares_bought</p><p class="source-code">            if num_shares_bought &gt; 0:</p><p class="source-code">                self.trades.append(</p><p class="source-code">                    {</p><p class="source-code">                        "type": "buy",</p><p class="source-code">                        "step": self.current_step,</p><p class="source-code">                        "shares": num_shares_bought,</p><p class="source-code">                        "proceeds": additional_cost,</p><p class="source-code">                    }</p><p class="source-code">                )</p></li>
				<li>Similarly, we<a id="_idIndexMarker553"/> can define the behavior of the <strong class="source-inline">"sell"</strong> action and update the account balance to finalize the method's implementation:<p class="source-code">        elif order_type == "sell":</p><p class="source-code">            # Simulate a SELL order and execute it at</p><p class="source-code">            # current_price</p><p class="source-code">            num_shares_sold = int(</p><p class="source-code">                self.num_shares_held * \</p><p class="source-code">               order_fraction_of_allowable_shares</p><p class="source-code">            )</p><p class="source-code">            self.cash_balance += num_shares_sold * \</p><p class="source-code">                                 current_price</p><p class="source-code">            self.num_shares_held -= num_shares_sold</p><p class="source-code">            sale_proceeds = num_shares_sold * \</p><p class="source-code">                            current_price</p><p class="source-code">            if num_shares_sold &gt; 0:</p><p class="source-code">                self.trades.append(</p><p class="source-code">                    {</p><p class="source-code">                        "type": "sell",</p><p class="source-code">                        "step": self.current_step,</p><p class="source-code">                        "shares": num_shares_sold,</p><p class="source-code">                        "proceeds": sale_proceeds,</p><p class="source-code">                    }</p><p class="source-code">                )</p><p class="source-code">        if self.num_shares_held == 0:</p><p class="source-code">            self.cost_basis = 0</p><p class="source-code">        # Update account value</p><p class="source-code">        self.account_value = self.cash_balance + \</p><p class="source-code">                             self.num_shares_held * \</p><p class="source-code">                             current_price</p></li>
				<li>We are now<a id="_idIndexMarker554"/> ready to implement the <strong class="source-inline">step</strong> method, which allows the agent to step through the environment:<p class="source-code">    def step(self, action):</p><p class="source-code">        # Execute one step within the environment</p><p class="source-code">        self.execute_trade_action(action)</p><p class="source-code">        self.current_step += 1</p><p class="source-code">        reward = self.account_value - \</p><p class="source-code">            self.opening_account_balance  # Profit (loss)</p><p class="source-code">        done = self.account_value &lt;= 0 or \</p><p class="source-code">            self.current_step &gt;= len(</p><p class="source-code">            self.ohlcv_df.loc[:, "Open"].values</p><p class="source-code">        )</p><p class="source-code">        obs = self.get_observation()</p><p class="source-code">        return obs, reward, done, {}</p></li>
				<li>Next, let's <a id="_idIndexMarker555"/>implement the <strong class="source-inline">reset()</strong> method, which will be executed at the start of every episode:<p class="source-code">    def reset(self):</p><p class="source-code">        # Reset the state of the environment to an </p><p class="source-code">        # initial state</p><p class="source-code">        self.cash_balance = self.opening_account_balance</p><p class="source-code">        self.account_value = self.opening_account_balance</p><p class="source-code">        self.num_shares_held = 0</p><p class="source-code">        self.cost_basis = 0</p><p class="source-code">        self.current_step = 0</p><p class="source-code">        self.trades = []</p><p class="source-code">        if self.viz is None:</p><p class="source-code">            self.viz = TradeVisualizer(</p><p class="source-code">                self.ticker,</p><p class="source-code">                self.ticker_file_stream,</p><p class="source-code">                "TFRL-Cookbook \</p><p class="source-code">                 Ch4-StockTradingVisualContinuousEnv",</p><p class="source-code">            )</p><p class="source-code">        return self.get_observation()</p></li>
				<li>Let's finalize our implementation of the environment by implementing the <strong class="source-inline">render</strong> and <strong class="source-inline">close</strong> methods:<p class="source-code">    def render(self, **kwargs):</p><p class="source-code">        # Render the environment to the screen</p><p class="source-code">        if self.current_step &gt; self.horizon:</p><p class="source-code">            self.viz.render(</p><p class="source-code">                self.current_step,</p><p class="source-code">                self.account_value,</p><p class="source-code">                self.trades,</p><p class="source-code">                window_size=self.horizon,</p><p class="source-code">            )</p><p class="source-code">    def close(self):</p><p class="source-code">        if self.viz is not None:</p><p class="source-code">            self.viz.close()</p><p class="source-code">            self.viz = None</p></li>
				<li>Now, it's time for you to get one of the agents you built as part of the previous chapter to train<a id="_idIndexMarker556"/> and test this real data-backed stock market trading environment. For now, let's test the environment with a simple, random agent:<p class="source-code">if __name__ == "__main__":</p><p class="source-code">    env = StockTradingVisualContinuousEnv()</p><p class="source-code">    obs = env.reset()</p><p class="source-code">    for _ in range(600):</p><p class="source-code">        action = env.action_space.sample()</p><p class="source-code">        next_obs, reward, done, _ = env.step(action)</p><p class="source-code">        env.render()</p></li>
			</ol>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor166"/>How it works…</h2>
			<p>To simulate a stock market, a real stock market data stream must be used. An offline file-based stream is utilized as an alternative to a web-based API, which would require internet connectivity and potentially a user account to fetch market data. The file stream contains the market data in a standard format: Date, Open, High, Low, Close, Adj-Close, and Volume.</p>
			<p>The agent observes the<a id="_idIndexMarker557"/> stock market data in the form of candlestick price charts, as shown in the following image for your reference:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B15074_05_02.jpg" alt="Figure 5.2 – Visual observation of StockTradingVisualContinuousEnvironment "/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Visual observation of StockTradingVisualContinuousEnvironment</p>
			<p>The agent's action and learning progress can be seen in the following image, which was generated by<a id="_idIndexMarker558"/> the <strong class="source-inline">render()</strong> method:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B15074_05_03.jpg" alt="Figure 5.3 – Visualization of the live account balance and the trade actions taken by the agent in the current time window "/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Visualization of the live account balance and the trade actions taken by the agent in the current time window</p>
			<p>That concludes this recipe and this chapter. Happy training!</p>
		</div>
</body></html>