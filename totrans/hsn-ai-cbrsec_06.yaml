- en: Malware Threat Detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The high diffusion of malware and ransomware codes, together with the rapid
    polymorphic mutation in the different variants (polymorphic and metamorphic malware)
    of the same threats, has made traditional detection solutions based on signatures
    and hashing of image files obsolete, on which most common antivirus software is
    based.
  prefs: []
  type: TYPE_NORMAL
- en: It is therefore increasingly necessary to resort to **machine learning** (**ML**)
    solutions that allow a rapid screening (**triage**) of threats, focusing attention
    on not wasting scarce resources such as a malware analyst's skills and efforts.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the malware analysis methodology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to tell different malware families apart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decision tree malware detectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting metamorphic malware with **Hidden Markov Models** (**HMMs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced malware detection with deep learning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malware analysis at a glance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most interesting aspects for those approaching malware analysis,
    is learning to distinguish, for example, legitimate binary files from those that
    are potentially dangerous for the integrity of the machines and the data they
    contain. We refer generically to **binary** files rather than to **executable**
    files (that is, files with extensions such as `.exe` or `.dll`), since malware
    can even hide in apparently innocuous files such as image files (files with extensions
    such as `.jpg` or `.png`).
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, even text documents (such as `.docx` or `.pdf`) can turn out
    to be **healthy carriers** or vehicles of software infections, despite their **non-executable**
    file format. Moreover, the first stage of the spread of a malware (in both the
    cases of a home PC and a company LAN) often happens by compromising the integrity
    of the files residing within the machines being attacked.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is of fundamental importance to be able to effectively identify
    the presence of malicious software, in order to prevent, or at least limit, its
    dissemination within an organization.
  prefs: []
  type: TYPE_NORMAL
- en: The following are the analysis strategies (and related tools) that are commonly
    used to conduct a preliminary survey of files and software disseminated *in the
    wild* (via counterfeit links, spam emails, phishing, and others), in order to
    identify those that are potentially dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this goal, we will have to examine the traditional methods of static
    and dynamic malware analysis more closely.
  prefs: []
  type: TYPE_NORMAL
- en: Artificial intelligence for malware detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the almost exponential increase in the number of threats associated with
    the daily spread of new malware, it is practically impossible to think of dealing
    with these threats effectively using only the analysis conducted by **human**
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is necessary to introduce algorithms that allow us to at least
    automate the preparatory phase of malware analysis (known as triage, deriving
    from the same practice adopted by doctors during the First World War, and consists
    of selecting for treatment the wounded that are most likely to survive). That
    is to say, conducting a preliminary screening of the malware to be analyzed by
    the malware analyst allows them to respond in a timely and effective manner to
    real cyber threats.
  prefs: []
  type: TYPE_NORMAL
- en: These algorithms actually take the form of the adoption of AI tools, given the
    dynamism that—by definition—characterizes cybersecurity. In fact, it is necessary
    that the machines can respond effectively, adapting themselves to the contextual
    changes related to the spread of unprecedented threats.
  prefs: []
  type: TYPE_NORMAL
- en: This not only implies that the analyst manipulates the tools and methods of
    malware analysis (which is obvious), but that they can also interpret the behavior
    of the algorithms, being aware of the choices that the machine has adopted.
  prefs: []
  type: TYPE_NORMAL
- en: The malware analyst is, therefore, called to understand the logic followed by
    ML, intervening (directly or indirectly) in the **fine-tuning** (refined adjustment)
    of the relevant learning procedures, based on the results obtained from the automated
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Malware goes by many names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many types of malware, and every day new forms of threat arise that
    creatively reutilize previous forms of attack, or adopt radically new compromising
    strategies that exploit specific characteristics of the target organization (in
    the case of **Advanced Persistent Threats** (**APTs**), these are tailored forms
    of attack that perfectly adapt themselves to the target victim). This is only
    limited to the imagination of the attacker.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is possible to compile a classification of the most common types
    of malware, in order to understand which are the most effective measures of prevention,
    and contrast their effectiveness for dealing with each malware species:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trojans**: Executables that appear as legitimate and harmless, but once they
    are launched, they execute malicious instructions in the background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Botnets**: Malware that has the goal of compromising as many possible hosts
    of a network, in order to put their computational capacity at the service of the
    attacker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Downloaders**: Malware that downloads malicious libraries or portions of
    code from the network and executes them on victim hosts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rootkits**: Malware that compromises the hosts at the operating system level
    and, therefore, often come in the form of device drivers, making the various countermeasures
    (such as antiviruses installed on the endpoints) ineffective'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ransomwares**: Malware that proceeds to encrypt files stored inside the host
    machines, asking for a ransom from the victim (often to be paid in Bitcoin) to
    obtain the decryption key which is used for recovering the original files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**APTs**: APTs are forms of tailored attacks that exploit specific vulnerabilities
    on the victimized hosts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zero days (0 days)**: Malware that exploits vulnerabilities not yet disclosed
    to the community of researchers and analysts, whose characteristics and impacts
    in terms of security are not yet known, and therefore go undetected by antivirus
    software'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, these different types of threats can be amplified by the fact that
    they can mix together in the same malicious file (for example, a seemingly harmless
    Trojan becomes a real threat, as it behaves like a downloader once executed, connecting
    to the network and downloading malicious software, such as rootkits, which compromises
    the local network and turns it into a botnet).
  prefs: []
  type: TYPE_NORMAL
- en: Malware analysis tools of the trade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many of the tools commonly used for conducting malware analysis can be categorized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Disassemblers (such as Disasm and IDA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debuggers (such as OllyDbg, WinDbg, and IDA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System monitors (such as Process Monitor and Process Explorer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network monitors (such as TCP View, Wireshark, and tcpdump)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unpacking tools and Packer Identifiers (such as PEiD)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary and code analysis tools (such as PEView, PE Explorer, LordPE, and ImpREC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malware detection strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obviously, every type of threat requires a specific detection strategy. In this
    section, we will see the analysis methods traditionally used in malware detection
    that are conducted manually by malware analysts. They provide a more detailed
    understanding of the phases of the analysis that can be improved and made more
    efficient by the introduction of AI algorithms, thus freeing the human analyst
    from the most repetitive or overwhelming tasks and allowing them to concentrate
    on the most peculiar or unusual aspects of the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: It should be emphasized that the development of malware software is the result
    of a creative activity carried out by the attacker, and as such is not easily
    ascribable to preestablished schemes or prefixed modalities. In the same way,
    the malware analyst must resort to all their imaginative resources, as well as
    developing unconventional procedures, in order to be able to stay in front of
    the attacker in a sort of *cat and mouse game*.
  prefs: []
  type: TYPE_NORMAL
- en: Malware analysis should therefore be regarded more as an art than a science,
    and as such, it demands the analyst's ability to always imagine new ways of detection
    to identify future threats on time. Consequently, the malware analyst is called
    to continually update not only their technical skills, but also their investigation
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: The fact remains that it is possible to start the detection activity by resorting
    to common practices of analysis, especially to detect the presence of known threats.
  prefs: []
  type: TYPE_NORMAL
- en: 'To this end, among the most common malware detection activities, we can include
    the following malware detection activities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hashes file calculation**: To identify known threats already present in the
    knowledge base'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System monitoring**: To identify anomalous behavior of both the hardware
    and the operating system (such as an unusual increase in CPU cycles, a particularly
    heavy disk writing activity, changes to the registry keys, and the creation of
    new and unsolicited processes in the system)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network monitoring**: To identify anomalous connections established by host
    machines to remote destinations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These detection activities can be easily automated by using specific algorithms,
    as we will see shortly after having examined malware analysis methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: Static malware analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in malware analysis begins with the evaluation of the presence
    of suspect artifacts in binary files, without actually running (executing) the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of techniques used in this phase goes under the name of **static
    malware analysis**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Static malware analysis consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the objectives considered of interest for the analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the flow of executable instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying known patterns and associating them to possible malware (also known
    as **malware detection**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To this end, analysis tools and procedures are used in order to perform the
    following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying calls to system APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoding and manipulating string data for obtaining sensitive information (for
    example, domain names and IP addresses)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting the presence and invocation by downloading other malware codes (for
    example, **Command and Control** (**C2**), backdoors, and reverse shells)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static analysis methodology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The methodology used by static malware analysis consists of the examination
    of the machine instructions (assembly instructions) present in the disassembled
    binary image of the malware (malware disassembly), in order to identify its harmful
    potentialities and evaluate the external characteristics of the binary code, before
    proceeding with its execution.
  prefs: []
  type: TYPE_NORMAL
- en: Difficulties of static malware analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among the most insidious aspects of static malware analysis are the difficulties
    in determining the correctness of the malware disassembly. Given the increasingly
    widespread presence of anti-analysis techniques, it is not always possible to
    assume that the disassembled binary image produced by the disassembler is reliable.
    Therefore, the analyst must conduct a preliminary analysis, in order to detect,
    for example, the presence of packers that encrypt portions of executable code.
  prefs: []
  type: TYPE_NORMAL
- en: Such preliminary analysis procedures are often overlooked by analysts because
    they are expensive in terms of time required; nevertheless, they are indispensable
    for circumscribing relevant goals to be carried out.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, if the presence of portions of executable code is not correctly
    detected (perhaps because they are hidden within data that is considered **harmless**,
    such as resources representing images), this deficiency can undermine the subsequent
    phases of dynamic analysis, making it impossible to identify the exact type of
    malware being investigated.
  prefs: []
  type: TYPE_NORMAL
- en: How to perform static analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have verified that the disassembled malware is reliable, it is possible
    to proceed in different ways: each analyst, in fact, follows their own preferred
    strategy, which is based on the experience and objectives they intend to pursue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In principle, the adoptable strategies are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the binary instructions in a systematic way, without executing them.
    It is an effective technique for limited portions of code that become complicated
    in cases of large malware, as the analyst must a keep trace of the status of the
    data for each instruction analyzed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scan the instructions to look for sequences that are considered to be of interest,
    setting breakpoints and partially executing the program up to the breakpoint,
    and then examining the status of the program at that point. This approach is often
    used to determine the presence of system calls deemed dangerous, based on the
    sequence in which these calls are invoked (for example, the sequence consisting
    of connecting to the network, creating a file, and modifying the system registry
    is one of the most common sequences of invocations of system APIs used by malware
    downloaders).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the same way, it is possible to detect the absence of certain API calls.
    A code that does not present invocations to the system calls (for example, network-related
    calls), which is necessary for issuing network connections, cannot obviously represent
    a backdoor (but it could act, for example, as a keylogger, because it calls the
    sequence of system APIs to detect the keys pressed on the keyboard and write to
    disk).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search for sensitive information (such as domain names and IP addresses) in
    a string format inside the disassembled image. Also, in this case, it is possible
    to set debugger breakpoints in correspondence with the network calls and detect
    any domain names or remote IP addresses that get contacted by the malware when
    connecting to the internet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware requirements for static analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike dynamic analysis, static analysis usually requires fewer specific resources
    in terms of hardware, since, in principle, the analyst does not execute the malicious
    code under analysis.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see, in the case of dynamic malware analysis, non-trivial hardware
    requirements may be required, and in some cases it is not enough to use virtual
    machines. This is due to the presence of countermeasures (anti-analysis tricks)
    implemented by the malware, which prevent the execution of the code if the presence
    of a virtual machine is detected.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic malware analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen, the specific features of static malware analysis consist of
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that a given binary file is actually malicious.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify as much information as possible about the binary file, without launching
    the execution and conducting the analysis on the basis of the characteristics
    that can be retracted, such as characteristics from the file format or from the
    resources stored in it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catalog the suspicious binary file by calculating its hash, which constitutes
    its signature (this signature can also be shared within the malware analysts community,
    in order to update the overall knowledge base of malware threats).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without a doubt, static malware analysis, although rapid to conduct, presents
    a series of methodological limitations, especially when it comes to analyzing
    sophisticated types of malware (such as APT and polymorphic malware). One of the
    remedies to these methodological limits consists of combining it with dynamic
    malware analysis, in an attempt to understand the nature and type of malware being
    analyzed in more depth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distinctive character of the dynamic malware analysis is the fact that,
    unlike the static malware analysis, the binary file gets executed (often in isolated
    and protected environments, known as **malware analysis labs**, which make use
    of sandboxes and virtual machines to prevent the wide spread of malware in the
    corporate network).
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, this strategy entails analyzing the **dynamic** behavior, that is,
    verifying, for example, that the malicious executable does not download malicious
    libraries or portions of code (payloads) from the internet, or proceeds to modify
    its own executable instructions at each execution, thus making the signature-based
    detection procedures (used by the antiviruses) ineffective.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-analysis tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The countermeasures usually adopted by malware developers, which prevent malware
    analysis or make it more difficult, rely on encryption of the payloads, the use
    of packers, of downloaders, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'These tricks are normally detectable with dynamic malware analysis; however,
    even dynamic malware analysis suffers from limitations related to the use of virtual
    machines—for example—whose presence can be easily detected by malware by exploiting
    some execution tricks, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execution of instructions that expect a default behavior: The malware can calculate
    the time that elapses in the execution of certain operations, and if these were
    performed more slowly than expected, it can deduce consequently that the execution
    takes place on a virtual machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hardware-based virtual machine detection: Through the execution of some specific
    instructions at the hardware level (for example, the instructions that access
    CPU-protected registers, such as `sldt`*,* `sgdt`*,* and`sidt`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing certain registry keys such as `HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Disk\Enum`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the malware detects the presence of a virtual machine, it stops working
    in the expected way, evading attempts for it to be detected by analysts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting malware samples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the course of our analysis, we will refer mainly to the malware codes developed
    for the Microsoft Windows platform, as we have a considerable amount of examples
    available, given the popularity of this platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, a question often asked is: where can we get malware samples from?'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several sources available online from which to download malware examples,
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MALWARE-TRAFFIC-ANALYSIS.NET*: [https://www.malware-traffic-analysis.net/](https://www.malware-traffic-analysis.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*VIRUSTOTAL*: [https://www.virustotal.com](https://www.virustotal.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*VirusShare*: [https://virusshare.com](https://virusshare.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*theZoo*: [https://github.com/ytisf/theZoo](https://github.com/ytisf/theZoo)
    (defined by the authors as *a repository of live malware for your own joy and
    pleasure*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also possible to create your own sample datasets, by acquiring malware
    samples in the wild through the configuration of a honeypot (or even simply collecting
    the spam messages received in your own email accounts).
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our malware dataset, it will be necessary to proceed to the preliminary
    analysis of their characteristics, taking advantage of the scripts that automate
    the activities of malware analysis.
  prefs: []
  type: TYPE_NORMAL
- en: As we anticipated, in our analysis, we will focus on malware codes developed
    for the Microsoft Windows platform. To proceed further in our analysis, we need
    to understand the executable file format adopted by this platform, which is known
    as the **Portable Executable** (**PE**) file format.
  prefs: []
  type: TYPE_NORMAL
- en: Every executable file of the Microsoft platform, whether it is a file with the `.exe`,
    `.dll`, or `.sys` extension (in the case of device drives), in order to be loaded
    into runtime memory and then executed by the Windows OS, must comply with the
    necessary specification contained in the PE file format.
  prefs: []
  type: TYPE_NORMAL
- en: We will examine this file format shortly, illustrating how to extract the features
    stored in the PE file format from the executable files, in order to create a dataset
    of **artifacts** that will be used to train our AI algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the PE file format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our analysis of the PE file format, we will make use of **PEView** (available
    online at [http://wjradburn.com/software/PEview.zip](http://wjradburn.com/software/PEview.zip)),
    which is a very simple but effective tool for visualizing **PE structures**. As
    we said, PE is the standard file format of binary images that get executed on
    a Windows OS.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, when the **Windows OS loader** loads executables (not limited to `.exe`,
    but also including `.dll` and `.sys`) in runtime memory, it executes the loading
    directives found in the **PE sections** for the binary image to be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: As such, PE file format artifacts remain one of the **main targets** for malware
    developers and virus writers.
  prefs: []
  type: TYPE_NORMAL
- en: The PE file format as a potential vector of infection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we will see, PE executables have multiple sections included in the binary
    file image, and this characteristic can be exploited to hide malicious software.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, each of the PE sections can be thought of as a folder, hosting various
    binary objects (ranging from graphics files to encrypted libraries), that gets
    executed and/or decrypted at runtime, potentially infecting other executables
    on the same machine or remote machines on the network.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a PE section may contain a `.sys` (malicious driver) file that
    is aimed at compromising the kernel, along with a startup file containing configuration
    parameters, or remote links the binary can connect to, in order to download other
    activation artifacts, C2 backdoors, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the PE file format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PE specification is derived from the Unix **Common Object File Format** (**COFF**)
    and it is basically a **data structure** that covers the information necessary
    for the Windows **OS loader** to manage the executable image, that is, when its
    structures get mapped into runtime memory before getting executed by the OS.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, a PE file consists of a **PE file header** and a **section table**
    (section headers), followed by the **sections' data**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **PE file header** is encapsulated in the Windows **NT header** structure
    (defined in the `winnt.h` header file, along with other C structures) and is composed
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: MS DOS header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PE signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The image file header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **file headers** are followed by **section headers**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/791469ac-0935-42cf-bbdf-8b74aa71845b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image credits: https://commons.wikimedia.org/wiki/File:RevEngPEFile.JPG'
  prefs: []
  type: TYPE_NORMAL
- en: The **section header** provides information about its associated section, including
    location, length, and characteristics. A section is the basic unit of code or
    data within a PE file.
  prefs: []
  type: TYPE_NORMAL
- en: Different functional areas, such as code and data areas, are logically separated
    into sections.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, an image file can contain a number of sections, such as `.tls`
    and `.reloc`, which have special purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The section header provides information about its associated section. The most
    common sections in executables are text, data, RSRC, RData, and RELOC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most Windows executables contain resources: a general term that refers to objects
    such as cursors, icons, bitmaps, menus, and fonts. A PE file can contain a resource
    directory for all of the resources that the program code in that file uses.'
  prefs: []
  type: TYPE_NORMAL
- en: Malware rarely uses graphical resources, so the total number of their resources
    is relatively fewer than that of benign software.
  prefs: []
  type: TYPE_NORMAL
- en: Many fields of PE file have no mandatory constraint. There are a number of redundant
    fields and spaces in PE files that could create opportunities for malware hiding.
  prefs: []
  type: TYPE_NORMAL
- en: In the following screenshot, we execute PEView and load its `.exe` image into
    memory; the Tools section shows the various sections of its PE format.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also outlined the special `e_magic` field of the DOS header, which
    usually contains the MZ character sequence (corresponding to the byte sequence
    `"0x4D 0x5A"`), and the special `Signature` field of the PE header (defined as the `IMAGE_NT_HEADERS`
    structure), which contains the **PE** character sequence, and states that that
    the binary file is a native Windows executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f23d73c-333e-4b11-ba01-1a0d52b93cd0.png)'
  prefs: []
  type: TYPE_IMG
- en: The DOS header and DOS stub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DOS header is only used for backward compatibility, and precedes the DOS
    stub that displays an error message stating that the program might not run in
    DOS mode.
  prefs: []
  type: TYPE_NORMAL
- en: As per the official PE documentation (available at [https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#ms-dos-stub-image-only](https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#ms-dos-stub-image-only)),
    the MS-DOS stub enables Windows to properly execute the image file, even though
    it has an MS-DOS stub.
  prefs: []
  type: TYPE_NORMAL
- en: It is placed at the front of the `EXE` image and prints out the message, `This
    program cannot be run in DOS mode`, when the image is run in MS-DOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DOS header includes some fields for backward compatibility, and is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The PE header structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the DOS header and DOS stub, we find the PE header.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PE header contains information about different sections used to store code
    and data, along with the requested imports from other libraries (DLLs) or the
    exports provided, in case the module is actually a library. Take a look at the
    following structure of the PE header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FileHeader` structure field describes the format of the file (that is,
    contents, symbols, and more), and its type is defined in the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OptionalHeader` field contains information about the executable module,
    including the required OS version, memory requirements, and the `itsentry` point
    (that is, the relative memory address where the actual execution starts from):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The special `AddressOfEntryPoint` field included in `OptionalHeader` states
    the executable entry point, which is usually set at the relative memory address
    of `0x1000`, as we can see outlined in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d337fac7-7e73-4713-9f78-d871b7a008d6.png)'
  prefs: []
  type: TYPE_IMG
- en: The data directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DataDirectory` structure field contains `IMAGE_NUMBEROF_DIRECTORY_ENTRIES`
    entries that define the logical components of the module. The relative entries
    are numbered and defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0348d00d-a9ec-4d0f-a320-2cba59b8e3ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Import and export tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The import table lists all of the symbols that need to be resolved and imported
    at load time from other DLLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3821aa0d-c2c5-4234-8752-0f224f4175eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Most types of benign software have a large number of entries in the import
    address table, because they have complex functions and import different Windows
    API functions from the import address table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6edc288-6116-4010-ae2c-a480ee3e42f8.png)'
  prefs: []
  type: TYPE_IMG
- en: Windows also allows programs to load and unload DLLs explicitly using `LoadLibrary`
    and `FreeLibrary`, as well as to find the addresses of symbols using `GetProcAddress`
    (exposed by `kernel32.dll`).
  prefs: []
  type: TYPE_NORMAL
- en: Most types of malware use the latter approach, so that the number of symbols
    in their imports table is relatively fewer than that of benign software.
  prefs: []
  type: TYPE_NORMAL
- en: The exports table contains information about symbols that other PE files can
    access through dynamic linking. Exported symbols are generally found in DLL files
    and most types of malware do not have exported symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Most types of malware load and unload DLLs explicitly using `LoadLibrary` and
    `FreeLibrary` in order to hide their malicious purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one notable exception: malware usually imports `wsock32.dll`,
    while benign software rarely imports this DLL, and that explains how malware carries
    out propagation and damage through network connections.'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting malware artifacts in a dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After having analyzed the PE file format, we are now ready to extract the characteristics
    of the binary files (whether legitimate or suspect), and store them in a dataset
    of artifacts with which to train our algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, we will develop Python scripts to automate the extraction
    of PE file format fields for each single file we analyze.
  prefs: []
  type: TYPE_NORMAL
- en: The Python library that we will use in our scripts is the famous `pefile` library,
    which was developed by Ero Carrera and is available at [https://github.com/erocarrera/pefile](https://github.com/erocarrera/pefile).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the archive containing the library has been downloaded and unpacked locally,
    we can proceed with the installation by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If, instead, we have created an environment in Anaconda following the instructions
    of the previous chapters, we can install the `pefile` library with the following
    command (assuming that the environment is called `py35`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we will be able to recall the functions of the library, even inside
    our Jupyter Notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'After having fed our malware dataset, as previously discussed, we can proceed
    to extract the artifacts from each single file, reading the corresponding `pefile`
    format fields using the `pefile` Python library, as shown in the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we uploaded the local `suspect.exe` file, which is part of our malware
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are able to extract the individual fields of the PE file format
    belonging to the `suspect.exe` file, by simply dereferencing the `suspect_pe`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the following script, we will extract the main fields of the PE file
    format, recalling them directly to the previously defined object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can then proceed to extract the artifacts from every single file contained
    within our dataset, exporting the fields into a `.csv` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final version of our extraction script will therefore be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can also extract the artifacts related to legitimate files inside our `.csv` file,
    by storing them together with malware samples, in order to be able to carry out
    the training by comparing the two types of files.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, we will have to add an additional column to the `.csv` file specifying
    whether the file is legitimate or not, valuing the field with the value `1` (legitimate)
    or with the value `0` (suspect), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Telling different malware families apart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen the advantages and limitations associated with traditional malware
    analysis methodologies, and we have understood why—in light of the high prevalence
    of malware threats—it is necessary to introduce algorithmic automation methods
    for malware detection.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, it is increasingly important that the similarities in malware
    behavior are correctly identified, which means that malware samples must be associated
    to classes or families of the same type, even if the individual malware signatures
    are not comparable to each other, due to, for example, the presence of polymorphic
    codes that alter the hash checksums accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The analysis of similarities can be carried out in an automated form, by using
    **clustering algorithms**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding clustering algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The intuition underlying clustering algorithms consists of identifying and exploiting
    the similarities that characterize certain types of phenomena.
  prefs: []
  type: TYPE_NORMAL
- en: In technical terms, it is a matter of distinguishing and recognizing, within
    a dataset, the features whose values ​​change with high frequency, from those
    features whose values are shown to remain systematically stable ​​instead. Only
    these latter features are taken into consideration for the detection of phenomena
    characterized by similarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can follow these two types of approaches in identifying similarities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Supervised**: The similarities are identified on the basis of previously
    categorized samples (for example, the **k-Nearest Neighbors** (**k-NNs**) algorithms).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unsupervised**: Similarities are identified independently by the algorithm
    itself (for example, the **K-Means** algorithm).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The estimate of the similarity between the features is carried out by associating
    them with a definition of **distance**.
  prefs: []
  type: TYPE_NORMAL
- en: If we consider the individual features as points in an *n*-dimensional space
    (in association with the number of analyzed features), we can choose a suitable
    mathematical criterion to estimate the distance existing between single points
    (which individually identify an algebraic vector).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the measures that can be selected to identify the distances between
    numerical vectors are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Euclidean distance**: This feature identifies the shortest path (the straight
    line) that unites two points in the Cartesian space, and is calculated with the
    following mathematical formula:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/33692b1d-932e-44a8-ba04-068ed929d14d.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Manhattan distance**: This feature is obtained from the sum of the absolute
    values of the differences calculated on the elements of the vectors. Unlike the
    Euclidean distance, the Manhattan distance identifies the longest route that joins
    the two points; in formulas, it is equivalent to the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e49a8733-2abb-4858-8057-140cac0c8be3.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Chebyshev distance**: This is obtained by calculating the maximum value of
    the absolute differences between the elements of the vectors; in formulas, it
    is equivalent to the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e2b14b0f-2b5d-451d-af51-cbfa417e1fab.png)'
  prefs: []
  type: TYPE_IMG
- en: The use of the Chebyshev distance is particularly useful if the number of dimensions
    to be taken into account is particularly high, although most of them are irrelevant
    for analysis purposes.
  prefs: []
  type: TYPE_NORMAL
- en: From distances to clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The clustering process therefore consists of classifying together elements that
    show certain similarities between them.
  prefs: []
  type: TYPE_NORMAL
- en: Having defined the concept of similarity using some mathematical definitions
    of distance, the clustering process is thus reduced in the exploration of the
    various dimensions of a given data space in every direction, starting from a given
    point, and then aggregating together the samples that fall into a certain distance.
  prefs: []
  type: TYPE_NORMAL
- en: Clustering algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Different types of clustering algorithms are conceivable, from the simplest
    and most intuitive, to the most complex and abstract ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most commonly used algorithms are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**K-Means**: One of the most widespread among the unsupervised clustering algorithms.
    K-Means can enlist among its strengths the simplicity of implementation and the
    capability of unveiling hidden patterns within the data. This can be achieved
    by proceeding to the independent identification of possible labels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**K-NNs**: This is an example of a lazy learning model. The K-NN algorithm
    only starts working in the evaluation phase, while in the training phase it simply
    limits itself to memorizing the observational data. Due to these characteristics,
    the use of k-NN is inefficient in the presence of large datasets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Density-Based Spatial Clustering of Applications with Noise** (**DBSCAN**):
    Unlike K-Means, which is a distance-based algorithm, DBSCAN is an example of a
    density-based algorithm. As such, the algorithm tries to classify data by identifying
    high-density regions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating clustering with the Silhouette coefficient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the recurring problems with clustering algorithms is the evaluation of
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: While in the case of supervised algorithms, by already knowing the classification
    labels, we are able to evaluate the results obtained by the algorithm simply by
    counting out the number of samples incorrectly classified and comparing them with
    those correctly classified. In the case of unsupervised algorithms, the evaluation
    of results is less intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: Not having the classification labels available beforehand, we will have to evaluate
    the results by analyzing the behavior of the algorithm itself, only considering
    the clustering process as successful if the samples classified in the same cluster
    are all actually similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the distance-based clustering algorithms, we can use as a metric of evaluation
    called the **Silhouette coefficient**, which takes the following mathematical
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c457bc07-df77-4dab-80d8-53126453c120.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, *m* represents the average distance existing between each single sample
    and all the other samples of the **nearest** cluster, while *n *represents the
    average distance existing between each single sample and all the other samples
    of the **same** cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The Silhouette coefficient is calculated for each single sample (as such, the
    calculation process becomes particularly slow when dealing with large datasets),
    and the estimate of the distance is determined by the particular metric we chose
    (such as the Euclidean distance or the Manhattan distance).
  prefs: []
  type: TYPE_NORMAL
- en: 'The main features of the Silhouette coefficient are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The value of *Sc* can vary between `-1` and `+1`, depending on the goodness
    of the clustering process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of *Sc* will tend toward `+1` in the case of optimal clustering, while
    it will tend toward `-1` in the opposite case of non optimal clustering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value of *Sc* is close to `0`, we will be in the presence of clusters
    that overlap each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: K-Means in depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now deal with the K-Means clustering algorithm in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: As previously stated, K-Means is an unsupervised algorithm, that is, it does
    not presuppose the prior knowledge of the labels associated with the data.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm takes its name from the fact that its final purpose is to divide
    the data into k different subgroups. Being a clustering algorithm, it proceeds
    to the subdivision of the data into different subgroups on the basis of a chosen
    measure to represent the distance of the single samples (usually, this measure
    is the Euclidean distance) from the center of the respective cluster (also known
    as **centroid**).
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the K-Means algorithm proceeds to group the data into distinct
    clusters, **minimizing a cost function** represented by the Euclidean distance
    calculated between the data (considered as points in space) and the respective
    centroids.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of its elaboration, the algorithm returns the individual samples
    grouped in correspondence of each cluster, whose centroids constitute the set
    of distinctive features identified by the algorithm as representative of the different
    categories that can be identified within the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: K-Means steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The K-Means algorithm is characterized by the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization**: This is the phase in which the centroids are identified on
    the basis of the number of clusters defined by the analyst (usually, we are not
    able to know the number of **real** clusters in advance, so it is often necessary
    to proceed by trial and error when defining the number of clusters).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data assignment to the clusters**: Based on the definition of the centroids
    carried out in the initialization phase, the data is assigned to the closest cluster,
    on the basis of the minimum Euclidean distance calculated between the data and
    their respective centroids.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Centroids update**: Being an iterative process, the K-Means algorithm proceeds
    again to the estimation of the centroids by estimating the average of the data
    included in the single clusters. Then the algorithm proceeds to the reassignment
    of the average, until the Euclidean distance between the data and the respective
    centroids is not minimized, or the number of iterations defined by the analyst
    as an input parameter has not been exceeded.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To use the implementation of the K-Means algorithm that comes with the `scikit-learn`
    library, we must appropriately choose a series of input parameters in order to
    define the phases of the algorithm iterative process, as identified previously.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, it will be necessary to identify the number of clusters (representative
    of the parameter `k`) and the mode of initialization of the centroids.
  prefs: []
  type: TYPE_NORMAL
- en: 'The choice of the number of clusters by the analyst has consequences on the
    result obtained by the algorithm: if the number of clusters set as an initialization
    parameter is excessive, the purpose of clustering is disregarded (algorithm behavior
    at the limit will tend to identify a different cluster for each single data).'
  prefs: []
  type: TYPE_NORMAL
- en: To this end, it may be useful to conduct a preliminary phase of **exploratory
    data analysis** (**EDA**)—performed with the aid of data plotting—by visually
    identifying the number of possible distinct subgroups into which the data can
    be distributed.
  prefs: []
  type: TYPE_NORMAL
- en: K-Means pros and cons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among the advantages of the K-Means algorithm we can remember, in addition to
    its simplicity of use, its high scalability makes it preferable in the presence
    of large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantages instead are essentially due to the inappropriate choice of
    the `k` parameter, representative of the number of clusters, which, as we have
    seen, requires particular attention on behalf of the analyst, who will be called
    to carefully evaluate this choice on the basis of an EDA, or proceeding by trial
    and error.
  prefs: []
  type: TYPE_NORMAL
- en: Another disadvantage associated with the using the K-Means algorithm is determined
    by the fact that it provides poorly representative results in the presence of
    datasets characterized by high dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the phenomenon known as the **curse of dimensionality** takes place,
    in which this is in **sparse** form in the n-dimensional space.
  prefs: []
  type: TYPE_NORMAL
- en: This entails that the cost function of distance minimization (used as a selective
    criterion for the clusters) is not very representative (in fact, the data may
    lie equidistant from each other in the n-dimensional space).
  prefs: []
  type: TYPE_NORMAL
- en: Clustering malware with K-Means
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following example, we will see the K-Means clustering algorithm applied
    to our previously created dataset of artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that our dataset of artifacts contains the fields extracted from the
    PE file format of the individual samples, consisting of the `.exe` files previously
    stored, including both the legitimate and the suspect files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of clusters that we will assign to the `k` parameter in the algorithm
    initialization phase will therefore be `2`, while the features that we will select
    as distinctive criteria of the possible malware correspond to the `MajorLinkerVersion`,
    `MajorImageVersion`, `MajorOperatingSystemVersion`, and `DllCharacteristics` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the fields of interest from our dataset are selected, we can proceed to
    instantiate the `KMeans` class of `scikit-learn`, passing the `k` value as an
    input parameters representing the number of clusters, equal to `2` (`n_clusters
    = 2`), and defining the maximum **number of iterations**that the algorithm can
    execute, equal to `300` (`max_iter = 300`) in our case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then invoke the `fit()` method on the `k_means` object, thus proceeding
    to start the iterative algorithm process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We just have to evaluate the results obtained by the algorithm. To this end,
    we will use the Silhouette coefficient we introduced previously, calculated by
    using the Euclidean distance as a metric, together with the **confusion matrix**
    of the results. This will show us a table with the respective clustering results,
    divided between correct and incorrect forecasts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of the process are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can see how the clustering algorithm was able to successfully identify the
    labels corresponding to the clusters to be associated with the individual samples,
    and from the confusion matrix, it is possible to detect how `83419` samples (out
    of a total of 96,526) belonging to the suspect category have been correctly identified
    (having being classified under label `0`), while only `13107` (13.58% of the total)
    were mistakenly considered as **legitimate**.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, only `7995` samples (out of a total of 40,918) were classified
    as suspect (equal to 19.54% of the total), despite being truly legitimate instead, compared
    to `32923` samples correctly classified as legitimate.
  prefs: []
  type: TYPE_NORMAL
- en: The `Silhouette coefficient` is equal to `0.975`, which is very close to 1,
    reflecting the goodness of the results obtained by the clustering algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Decision tree malware detectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to clustering algorithms, it is possible to use classification algorithms
    for the detection of malware threats. Of particular importance is the classification
    of the malware carried out by using *decision trees*.
  prefs: []
  type: TYPE_NORMAL
- en: We have already met decision trees in [Chapter 3](aaf59353-00b3-4625-8732-63aad02cc8e5.xhtml), *Ham
    or Spam? Detecting Email Cybersecurity Threats with AI*, when we discussed the
    problem of **spam detection**. Now, we will deal with the classification problems
    solved by decision trees in the context of detecting malware threats.
  prefs: []
  type: TYPE_NORMAL
- en: The distinctive feature of decision trees is that these algorithms achieve the
    goal of classifying data in certain classes by modeling the learning process based
    on a sequence of if-then-else decisions.
  prefs: []
  type: TYPE_NORMAL
- en: For this characteristic, decision trees represent a type of non-linear classifier,
    whose decision boundaries are not reducible to straight lines or hyperplanes in
    space.
  prefs: []
  type: TYPE_NORMAL
- en: Decision trees classification strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decision trees, therefore, shape their learning process based on a tree structure.
    Starting from a root node, subsequent decisions branch into various branches of
    different depths.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, the samples dataset is divided by the algorithm in an iterative
    way, based on the decisions that are taken at each node, thus giving rise to the
    various branches. Branches, on the other hand, represent nothing more than the
    various ways in which data can be classified, based on the possible choices made
    at the various decision nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This iterative process of subdividing the dataset is determined by a predefined
    measure of the quality of the subdivision conditions. The most commonly used metrics
    for measuring the quality of subdivision are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Gini impurity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variance reduction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information gain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Despite their high explanatory capacity, decision trees do, however, suffer
    from some important limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: As the number of features considered increases, the complexity of the structure
    representing the associated decision tree grows accordingly, translating this
    complexity into the phenomenon known as **overfitting** (that is, the algorithm
    tends to model the **noise** in the data, rather than the **signal**, leading
    to less precise forecasts on the test data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decision trees are particularly sensitive to even small variations in sample
    data, making forecasts unstable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One way to overcome these limitations is to create tree ensembles, associating
    a **vote** to each tree. The mechanism for assigning samples to the respective
    classes is therefore reduced to counting the votes assigned by the various trees;
    an example of a tree ensemble is the **random forest** algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting malwares with decision trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already met decision trees before, when we addressed the topic of *phishing*
    detection. Obviously, we can also use decision trees to perform malware detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we will use the `AddressOfEntryPoint` and `DllCharacteristics`
    fields as potentially distinctive features for detecting the suspect `.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the results obtained, the accuracy of the forecasts made
    by selecting the `AddressOfEntryPoint` and `DllCharacteristics` fields proves
    particularly effective, being higher than 96%.
  prefs: []
  type: TYPE_NORMAL
- en: We can try to select different fields as characterizing features, and evaluate
    the results obtained by comparing them.
  prefs: []
  type: TYPE_NORMAL
- en: Decision trees on steroids – random forests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that decision trees suffer from some important limitations, which
    can lead to unstable results that are caused even by small variations in the training
    data. To improve forecasts, you can use **ensemble** algorithms, such as **random
    forest**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Random forest is nothing but a decision tree ensemble in which each tree is
    given a vote. The improvement in forecasts is consequently determined by the count
    of the votes attributed to them: the forecasts that obtain the highest number
    of votes are those that are selected to achieve the final result of the algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: The creator of the Random Forest algorithm, Leo Breiman, noted that the results
    obtained by an ensemble of trees improved if the trees were **statistically uncorrelated**
    and **independent** of each other. Next, we will see an example of the **Random
    Forest Malware Classifier**, implemented using the `scikit-learn` library.
  prefs: []
  type: TYPE_NORMAL
- en: Random Forest Malware Classifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is an example of the Random Forest Malware Classifier implemented
    with the `scikit-learn` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the results, the random forest classifier improves the performances
    obtained by the decision tree; to check this, just compare the accuracy of the
    respective algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Detecting metamorphic malware with HMMs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The examples of algorithms applied to malware detection that have been shown
    so far were intended to automate some of the routine activities performed by malware
    analysts.
  prefs: []
  type: TYPE_NORMAL
- en: However, the analysis methodology on which they are based is essentially static
    malware analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the concrete cases of malware threats, however, are not easily identifiable
    with this method of analysis, as the malware developers have learned how to work
    around the detection techniques based on signatures.
  prefs: []
  type: TYPE_NORMAL
- en: It will therefore be necessary to adopt a different methodology to identify
    the malicious behavior of more advanced malware, and to this end, we will have
    to move to an approach based on dynamic malware analysis, combining it with the
    appropriate algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: But to adequately address the problem, it is necessary to understand in detail
    the limits of traditional detection strategies based on signatures.
  prefs: []
  type: TYPE_NORMAL
- en: How malware circumvents detection?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most commonly used detection strategy is the one that uses signatures associated
    with executable files recognized as malicious.
  prefs: []
  type: TYPE_NORMAL
- en: This strategy offers undoubted advantages, and is widely implemented by antivirus
    software.
  prefs: []
  type: TYPE_NORMAL
- en: It is based on the search for specific patterns (consisting of sequences of
    bits considered representative of the malicious executable), conducting the search
    of these patterns on each of the files stored in the system, and carrying out
    the systematic scanning of the resources (including the runtime memory) of the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The search for patterns takes place on the basis of a database, which contains
    the signatures of malicious files. These must be updated promptly and constantly,
    in order to be able to search and compare files in the system, thus preventing
    threats from going undetected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages associated with the signature-based detection strategy are essentially
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency in identifying threats already known and present in the signatures
    database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low frequency of false positives, which together with false negatives, is the
    main weakness of malware detection software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead, the limits of this detection strategy are substantially represented
    by the basic assumption: that is to say that malicious software, once identified,
    does not change its binary representation, so it is therefore considered to be
    adequately photographed by the corresponding signature.'
  prefs: []
  type: TYPE_NORMAL
- en: In reality, these assumptions have quickly proved unrealistic. Over time, in
    fact, we have witnessed the creativity effort by malware developers to try to
    create software that was able to change its shape, thus targeting the detection
    mechanism based on signatures, while maintaining its own offensive potential.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first countermeasures adopted by the authors of malware was obfuscation. To
    this end, it is possible to perform the encryption of the executable portions
    of a malware, each time using different encryption keys to alter the signatures
    associated by the antivirus software to the payload of the malware, while the
    executable instructions remain unaltered and are decrypted before being sent to
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: A more sophisticated variant of obfuscation is the creation of polymorphic malware,
    in which not only the malware encryption key is constantly changed, but also the
    malware decryption instructions themselves are changed.
  prefs: []
  type: TYPE_NORMAL
- en: The subsequent evolution of polymorphic malware leads to metamorphic malware,
    in which even the executable instructions of the payload are modified at each
    execution, thus preventing the most advanced antiviruses from identifying the
    malicious payload by scanning the runtime memory, once the payload has been decrypted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to alter the payload executable instructions, metamorphic malware
    implements a **mutation engine** by adopting the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Inserting additional instructions (dead code) that do not alter the logic and
    operation of the malware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the order of the instructions, without altering the logic and overall
    functionality. This technique is particularly effective in generating many **variations
    on the theme**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacement of some instructions with other equivalent instructions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphic malware detection strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the constant *cat and mouse game* established between malware developers
    and antivirus software producers, the latter have tried to keep up the pace, adapting
    their detection strategies to the different forms of polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of polymorphic malware, one of the strategies adopted consists
    of code emulation: the execution of the malware inside a controlled environment
    (such as the sandbox), allowing the malware to carry out the decrypt phase of
    the payload, to which the traditional signature-based detection performed by the
    antivirus software follows.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of metamorphic malware, as well as zero days, the detection activity
    carried out by the most sophisticated antivirus software tries to analyze the
    behavior of the suspect file, making sense of the logic of the instructions that
    get executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this detection strategy suffers from some of the following important
    limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: It leads to a high rate of false positives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The analysis of the instructions being executed is carried out on the fly, which
    can lead to significant impacts in computational terms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative strategy in the detection of metamorphic malwares (as well as
    of zero days) is the one that uses ML algorithms based on HMMs.
  prefs: []
  type: TYPE_NORMAL
- en: To understand what these are, we will first have to introduce these types of
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: HMM fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand what an HMM is, we need to introduce Markov processes.
  prefs: []
  type: TYPE_NORMAL
- en: A Markov process (or Markov chain) is a stochastic model that changes its status
    based on a predefined set of probabilities.
  prefs: []
  type: TYPE_NORMAL
- en: One of the assumptions of the Markov process prescribes that the **probability
    distribution** of **future states** depends exclusively on the **current state**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, an HMM is a Markov process of which it is **not** possible to **directly
    observe** the state of the system: the only observable elements are the events
    and secondary effects associated with the state of the system; however, the probabilities
    of the events being determined by each state of the system are fixed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, the **observations** on each state of the system are made **indirectly**
    on the basis of the events determined by such hidden states, to which probability
    estimates can be associated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1351bb6c-8eb2-4bb1-8189-7740455a6c8c.png)'
  prefs: []
  type: TYPE_IMG
- en: '(Image credits: https://en.wikipedia.org/wiki/File:HiddenMarkovModel.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To intuitively understand how HMMs work, we present the following example:
    imagine an executable that is launched on a host machine. At a given time, the
    machine can continue to function properly, or stop working properly; this behavior
    represents the observable event.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume for simplicity that the reasons why the machine stops working
    regularly can be reduced to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The executable executed a **malicious** instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The executable executed a **legitimate** instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The information relating to the specific reason why the machine stops working
    properly is the entity unknown to us, which we can only infer based on observable
    events.
  prefs: []
  type: TYPE_NORMAL
- en: 'These observable events, in our example, are reduced to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The machine works regularly (working)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The machine stops working (not working)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, the hidden entities of our example are represented by the instructions
    executed by the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Malicious** instruction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Legitimate** instruction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, imagine assigning the probability estimates to the various events
    and states of the system. We summarize this in the following table, also known
    as the **emission matrix**, which summarizes the probabilities that a given observation
    is associated with a particular observable state (remember that the sum of the
    probabilities associated to each hidden entity, subdivided according to the possible
    events, must account to 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we must estimate the probabilities associated with the **next
    instruction** executed by the program, which can be summarized in the **transition
    matrix**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, if the program has previously executed a malicious (instead of a
    legitimate) instruction, the probability that the next instruction executed is
    malicious (rather than legitimate) is equal to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must assign the probability associated with the starting state
    of the HMM; in other words, the probability associated with the first hidden state
    corresponds to the probability that the first instruction executed by the program
    is **malicious** or **legitimate**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the task of our HMM is to identify hidden entities (in our example,
    if the instructions executed by the program are malicious or legitimate) based
    on the observation of the behavior of the machine.
  prefs: []
  type: TYPE_NORMAL
- en: HMM example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our example, the possible observations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `W` stands for Working and `N` for Not Working, while the hidden states are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, `M` corresponds to Malicious and `L` corresponds to Legitimate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequence of observations comes next, which is associated to the single
    instructions that get executed by the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This sequence of observations tells us that after the execution of the first
    three instructions of the program, the machine worked properly, while it stopped
    working only after executing the fourth instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the basis of this sequence of observable events, we must proceed with the
    training of the HMM. To this end, we will pass our probability matrices (as defined
    previously) to the algorithm, corresponding to the `start` matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `transition` matrix is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `emission` matrix is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code uses the Hidden Markov library, which is available at [https://github.com/rahul13ramesh/hidden_markov](https://github.com/rahul13ramesh/hidden_markov):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the results of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`Forward algorithm` gives us the probability of an observed sequence in the
    HMM, while `Viterbi algorithm` is used to find out the most likely sequence of
    hidden states that can generate the given set of observations.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the Hidden Markov library, please refer to the documentation
    available at [http://hidden-markov.readthedocs.io/en/latest/](http://hidden-markov.readthedocs.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: Advanced malware detection with deep learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last part of the chapter, we will introduce—for the sake of completeness—some
    solutions of malware detection that make use of experimental methodologies based
    on neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: We will have a more in-depth look at the topic of deep learning techniques later
    on in [Chapter 8](18f56dc2-fd40-4669-bef1-0b594d9e1572.xhtml), GANS – Attacks
    and Defenses (especially when we will talk about **Generative Adversarial Networks**
    (**GANs**)).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will introduce the topic to show an innovative and unconventional approach
    to the problem of the classification of different families of malware, which makes
    use of deep learning algorithms developed in a completely different field of research,
    such as that of image recognition using **Convolutional Neural Networks** (**CNNs**).
  prefs: []
  type: TYPE_NORMAL
- en: But before going into that, let's briefly introduce **Neural Networks** (**NNs**)
    and their main features in the field of malware detection.
  prefs: []
  type: TYPE_NORMAL
- en: NNs in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NNs constitute a category of algorithms that try to imitate the learning mechanisms
    typical of the human brain, artificially reproducing its substrate, which is constituted
    by neurons.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different types of neural networks, but here we focus on two types
    in particular: the CNN, and the **Feedforward Networks** (**FFN**), which are
    the basis of CNNs; we start by describing FFNs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The FFN is composed of at least three layers of neurons, divided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Input layer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output layer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hidden layer (one or more)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This layered organization of the FFN allows us to have a first layer for the
    management of input data, and a layer that returns the output results.
  prefs: []
  type: TYPE_NORMAL
- en: The individual neurons in the various layers connect directly to the adjacent
    layers, while there are no connections between the neurons belonging to the same
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: CNNs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A CNN is a particular type of FFN, characterized by the fact that the organization
    of the neuronal layers follows the same organization of the existing visual apparatus
    in the biological world, with the superposition of regions of neurons within the
    visual field.
  prefs: []
  type: TYPE_NORMAL
- en: As we have said, in CNNs, each neuron is connected to a contiguous region of
    input neurons, in order to map the corresponding regions of pixels of an image.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, it is possible to identify the spatial correlations through local
    connectivity schemes between neurons lying on adjacent layers, which allow, for
    example, the identification of objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the CNNs, the contiguous regions of neurons are in fact organized by emulating
    the three-dimensional quantities of width, height, and depth, which map the corresponding
    characteristics of c width and height of the images, while the depth is constituted
    by the RGB channels.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, CNNs are optimized for image recognition thanks to the convolutional
    layer (which, together with the pooling layer and the fully-connected layer, constitutes
    the three characteristic layers of such neural networks).
  prefs: []
  type: TYPE_NORMAL
- en: In particular, the convolutional layer allows us to extract the relevant features
    of the input images through the convolution operations, which create a new image
    starting from the original image, by highlighting the most relevant features,
    and by blurring the less relevant ones; in so doing, the convolutional layer can
    spot similar images in spite of their actual position or orientation.
  prefs: []
  type: TYPE_NORMAL
- en: From images to malware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the description that follows, we will show an alternative approach to malware
    detection that takes advantage of the typical skills of CNNs in image recognition.
    But in order to do this, it is first necessary to represent the executable code
    of the malware in the form of an image to be fed to the CNN.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach was described in the paper entitled *Towards Building an Intelligent
    Anti-Malware System: A Deep Learning Approach using Support Vector Machine (SVM)
    for Malware Classification* by Abien Fred M. Agarap, in which each executable
    malware is treated as a binary sequence of zeros and ones, which is then translated
    into a gray-scale image.'
  prefs: []
  type: TYPE_NORMAL
- en: In this way, it is possible to recognize the malware families based on the similarities
    in terms of layouts and textures existing in the images that represent them.
  prefs: []
  type: TYPE_NORMAL
- en: To perform the classification of the images, a k-NN clustering algorithm was
    used, in which the Euclidean distance was adopted as the metric used to represent
    the distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The experimental results obtained showed a classification rate of 99.29%, with
    extremely reduced computational loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e55d81ff-5eac-4f88-914c-712b3ffc21ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image credits: Towards Building an Intelligent Anti-Malware System: A Deep
    Learning Approach using Support Vector Machine (SVM) for Malware Classification
    by Abien Fred M. Agarap'
  prefs: []
  type: TYPE_NORMAL
- en: Why should we use images for malware detection?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The advantages of representing malware as images are follow ass:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to recognize specific sections of the malware code, such as those
    modified by malware developers in an attempt to create different variants of the
    original code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through the images, it is possible to identify the minor modifications intervened
    in the code, while preserving the overall structure of the malware image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These characteristics have the consequence that the different variants of the
    malware belonging to the same family are easily recognizable on the basis of the
    similarity of the respective images that represent them. This is because different
    types of images correspond to different families of malware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting malware from images with CNNs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the original paper described previously, a tool was developed that leverages
    CNNs to recognize and classify the images that represent malware codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool can be downloaded from the GitHub repository, by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Inside the archive, there is also a dataset of images of malware codes (`malimg.npz`).
    To convert your malware codes to grayscale images, you can also use the Python
    script developed by Chiheb Chebbi, which is available at [https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/blob/master/Chapter04/MalwareConvert.py](https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/blob/master/Chapter04/MalwareConvert.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'We show some examples of the tool''s usage as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the CNN-SVM model, set the `-model` parameter to `1`, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we addressed the different strategies of malware threats detection,
    making use of various AI algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how malwares can trick the analyst, using advanced techniques such as
    polymorphism, forcing the adoption of algorithmic-based detection tools.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we introduced the clustering and classification algorithms, up to
    the more advanced ones, which are based on HMMs and neural networks, in the form
    of CNNs, in order to deal with such advanced threats.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will deal with Network Anomalies Detection techniques
    that leverage Artificial Intelligence.
  prefs: []
  type: TYPE_NORMAL
