- en: Getting Started with TensorFlow.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have gently introduced ourselves to the wonderful world of deep learning
    and we have got a fair sense of what deep learning has to offer in terms of making
    today's web applications more intelligent. In [Chapter 1](f97d928f-3614-4d12-ad37-d5736008f542.xhtml),
    *Demystifying Artificial Intelligence and Fundamentals of Machine Learning*, we
    saw a detailed overview of the web applications before and after AI breakout.
    In [Chapter 3](a33bccdc-8664-4ae7-be82-b066e5b64850.xhtml), *Creating Your First
    Deep Learning Web Application*, we built ourselves a simple image classifier-based
    web application using a simple neural network.
  prefs: []
  type: TYPE_NORMAL
- en: Web applications are all around us and they have easily become inseparable parts
    of our day-to-day lives. When it comes to building web applications, the use of
    JavaScript is too hard to ignore. So, what if we built an intelligent web application
    using JavaScript and no other scripting language? In this chapter, we are going
    to see how we can use a JavaScript library, called **TensorFlow.js** (**TF.js**),
    to build a deep learning-enabled web application—we are going to do all of this
    in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The fundamentals of TF.js and its offerings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a deep learning model with TF.js and making inferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the pretrained models directly in the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a web application to recognize flower species
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages and limitations of TF.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can access the code used in this chapter at [https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter4](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter4).
  prefs: []
  type: TYPE_NORMAL
- en: 'To work on this chapter, you''ll need the following software:'
  prefs: []
  type: TYPE_NORMAL
- en: TF.js 0.15.1+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@tensorflow/tfjs-node` 0.3.0+ package from the NPM repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fundamentals of TF.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to briefly review some of the fundamental concepts
    of TF.js. We will start off by introducing TensorFlow and then we will proceed
    to study different components of TF.js.
  prefs: []
  type: TYPE_NORMAL
- en: What is TensorFlow?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can begin discussing TF.js, we must understand what TensorFlow is.
    TensorFlow is an open source library that is developed and maintained by Google.
    It is built on a data structure called tensors. Tensors are the generalized form
    of scalar and vector. TensorFlow provides a lot of efficient utilities for high-performance
    numerical computing across a wide range of scientific domains. TensorFlow also
    provides a very flexible suite of utilities for carrying out machine learning
    and deep learning development and research. You are encouraged to visit TensorFlow's
    official website at [https://www.tensorflow.org/](https://www.tensorflow.org/)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: What is TF.js?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TF.js is a JavaScript library that provides an ecosystem to build and deploy
    machine learning models. It offers the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing machine learning models with JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pretrained machine learning models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying machine learning models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TF.js provides you with all the elements required for a machine learning project.
    It has dedicated modules for data preprocessing, tensor handling, model building,
    model evaluation, and much more, but all in JavaScript. Before we move on to digging
    deeper into this, let's quickly understand the need for TF.js.
  prefs: []
  type: TYPE_NORMAL
- en: Why TF.js?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous chapter, it is quite easy and intuitive to simply
    train and host a model online, wrap it up in a REST API, and then use the API
    on any frontend to display our results. Why, then, would the need to use TF.js
    arise?
  prefs: []
  type: TYPE_NORMAL
- en: A simple answer to this question would be if there is an AI in the browser!
    Think of a game that requires the use of an AI agent that learns from the human
    player's method of playing to become tougher or easier as the game progresses.
    Now, this would be overkill if, at every split second, the game kept sending requests
    to the server to transfer data to and from the game and the server. What's more,
    it might easily result in a **Denial of Service** (**DoS**) attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, having an AI that can live and learn in the browser itself makes sense
    when the agent has to keep learning in real time. It could also be a hybrid in
    two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: If a pretrained model is loaded during the rendering of the agent and, from
    there, it begins learning and updating the model on the server at intervals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If multiple versions of the AI agent run on several systems at once and they
    learn from interaction on the system on which they run. Also, if their collective
    learning is assimilated on the server and the agents fetch updates from the server
    at intervals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, using TF.js greatly reduces strong dependence on the page that the human
    user will interact with to communicate with the server at every step.
  prefs: []
  type: TYPE_NORMAL
- en: We can now build a mini project that shows the power of TF.js. Don't worry about
    the TF.js ecosystem for now—we will cover all the elements of the project as we
    go along.
  prefs: []
  type: TYPE_NORMAL
- en: The basic concepts of TF.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the components of TF.js that we will be using in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: Tensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each of them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Tensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like TensorFlow, the central data processing unit in TF.js is tensors. Goodfellow
    et al. (in their book on deep learning) make the following observation:'
  prefs: []
  type: TYPE_NORMAL
- en: In the general case, an array of numbers arranged on a regular grid with a variable
    number of axes is known as a tensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply described, a tensor is a container of one- or multi-dimensional arrays.
    The following are some examples of tensors that you may already know:'
  prefs: []
  type: TYPE_NORMAL
- en: Scalar (a rank zero tensor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vector (a one-dimensional or rank-one tensor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrix (a two-dimensional or rank-two tensor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create a tensor with respect to a given shape in TF.js as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`a` is a tensor that was created and its contents can be printed using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`a` is a matrix (a rank-two tensor). TF.js also provides dedicated functions,
    such as `tf.scalar`, `tf.tensor1d`, `tf.tensor2d`, `tf.tensor3d`, and `tf.tensor4d` to
    create tensors of specific shapes without having to specify the `shape` argument
    explicitly. It also provides better readability. Tensors are immutable in TF.js.'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike tensors, variables are mutable in TF.js. Variables are particularly
    useful during the training of a neural network as they consist of lots of intermediate
    data stores and updates. The following is an example of how variables can be used
    in TF.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's now look at operators.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operators let you perform mathematical operations on data. TF.js provides various
    operations for manipulating tensors. As tensors are immutable in nature, operators
    don''t change the data contained in the tensors—they return new tensors as results
    instead. You can perform binary operations, such as addition, multiplication,
    and subtraction, on tensors. You can even chain multiple operations. The following
    example shows the use of two different operators in TF.js using chaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We first created two two-dimensional tensors and assigned them to `e` and `f`.
    We then added them and took their squares.
  prefs: []
  type: TYPE_NORMAL
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will cover models and layers.
  prefs: []
  type: TYPE_NORMAL
- en: Models and layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In deep learning literature, a model refers to the neural network itself, specifically,
    the neural network architecture. As discussed in [Chapter 2](9a68dbce-f50e-4c5a-80e2-2b7f40e082ca.xhtml),
    *Getting Started With Deep Learning Using Python*, a neural network consists of
    basic components, such as layers, neurons, and connections, in between layers.
    TF.js provides two functions with which to create these models—`tf.model` and
    `tf.sequential`. `tf.model` helps you to get more sophisticated architectures,
    such as skipping certain layers, whereas `tf.sequential` provides a way to create
    linear stacks of layers without skipping, branching, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'TF.js provides different types of dedicated layers for different types of tasks—`tf.layers.dense`,
    `tf.layers.dropout`, `tf.layers.conv1d`, `tf.layers.simpleRNN`, `tf.layers.gru`,
    and `tf.layers.lstm`. The following example demonstrates a simple neural network
    model with the help of `tf.sequential` and `tf.layers.dense`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example creates a simple neural network that has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Two layers (remember, we don't consider the input layer when counting the total
    number of layers). The network takes an input that has four features (the `inputShape` argument helps
    to specify that).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first layer contains four neurons (hence `units: 4`). The second layer
    (the output layer) has only one neuron.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `relu` activation function is used for the first layer, and the `sigmoid`
    activation function is used for the output layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are encouraged to go to [https://js.tensorflow.org/api/latest/index.html](https://js.tensorflow.org/api/latest/index.html)
    to learn more about the preceding components of TF.js.
  prefs: []
  type: TYPE_NORMAL
- en: A case study using TF.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will follow all the steps that are typically involved in a machine learning
    project (which we discussed in [Chapter 1](f97d928f-3614-4d12-ad37-d5736008f542.xhtml),
    *Demystifying Artificial Intelligence and Fundamentals of Machine Learning*).
    A good project starts with a well-defined problem statement. So, let's quickly
    take a look at that and decide the subsequent steps accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: A problem statement for our TF.js mini-project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem we will look at here is probably one of the most famous challenges
    you will come across when starting your journey in machine learning—classifying
    and predicting the type of an Iris flower by learning its features from the Iris
    flower dataset. Training, as well as the prediction, will be performed in the
    browser itself.
  prefs: []
  type: TYPE_NORMAL
- en: We have defined the problem statement for our project. What will follow is the
    data preparation step. The data is already available to us, so we don't need to
    collect it ourselves. But, before we prepare the data, it would be good to know
    a bit more about the data itself.
  prefs: []
  type: TYPE_NORMAL
- en: The Iris flower dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Introduced by Ronald Fisher, the statistician and biologist, in 1936, the Iris
    flower dataset contains 150 rows of data and about 3 different varieties of the
    Iris flower. The columns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Sepal length (cm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sepal width (cm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Petal length (cm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Petal width (cm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variety:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setosa
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Versicolour
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Virginica
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can get the raw dataset and learn more about it at [http://archive.ics.uci.edu/ml/datasets/Iris](http://archive.ics.uci.edu/ml/datasets/Iris).
  prefs: []
  type: TYPE_NORMAL
- en: Your first deep learning web application with TF.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to develop a web application with the help of
    TF.js. This application will include the steps for a standard, full stack, deep
    learning-enabled web project. We will begin by preparing the data, we will then
    study the project architecture briefly, and then, we will proceed toward building
    the required components as we go.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Iris flower dataset, in its original form, is a CSV file containing the
    data of 150 rows split into 5 columns in a comma-separated format, with each entry
    separated by a new line.
  prefs: []
  type: TYPE_NORMAL
- en: However, we will be using a JSON format of the data for easier operability with
    JavaScript. The dataset in JSON format can be downloaded from [https://gist.github.com/xprilion/33cc85952d317644c944274ee6071547](https://gist.github.com/xprilion/33cc85952d317644c944274ee6071547).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use simple functions in any language to convert a CSV file into a JSON
    file, with the column names changed as per the following conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sepal length: `sepal_length`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sepal width: `sepal_width`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Petal length: `petal_length`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Petal width: `petal_width`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variety: `species`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use these property names in JSON while developing the tensors for model
    building.
  prefs: []
  type: TYPE_NORMAL
- en: Project architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using Node.js in this project to create a server. This is done so
    that we get the benefits of faster computational performance of TF.js when used
    through the Node.js backend. We will create a very basic frontend that will be
    able to issue a command to perform the training of the neural network built using
    TF.js and another button to issue a command to predict the class of a hypothetical
    feature vector of an Iris flower based on input provided by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the components of the project, along with their
    interactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e47dac3-cf66-406f-8222-dbf2905cd686.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know about the architecture, let's start with the project.
  prefs: []
  type: TYPE_NORMAL
- en: Starting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start working on the project, you first need to install the latest versions
    of Node.js and **Node Package Manager** (**NPM**). While a standard way to do
    this would be to read the documentation provided on the Node.js website, we would
    suggest installing Node.js and NPM using **Node Version Manager** (**NVM**).
  prefs: []
  type: TYPE_NORMAL
- en: The setup instructions and files can be found at [https://githu](https://github.com/creationix/nvm)[b.com/creationix/nvm](https://github.com/creationix/nvm)[.](https://github.com/creationix/nvm)
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Node.js and NPM are installed, we''re ready to start working on the project
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `tfjs-iris`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up a Terminal and use the following command to initiate the package manager
    for this project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This should create a file, `package.json`, in your project directory. The output
    for the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d566a0e8-10d6-4418-9e82-a59447d8f27a.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the output is in JSON format. The `main` key defines the file that
    will be the entry point for the program if it is imported as a module. The value
    for `main` in this project is set, by default, to `index.js`. However, this file
    is not yet created. Let's work on the `index.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the `express` module of Node.js to create our server. You can
    read more about `express` at [https://expressjs.com.](https://expressjs.com/)
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `express`, we will need to add the module to our project. To do this,
    use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will add the `express` module dependency to the `package.json` file and
    install it in the `node_modules` directory inside the working directory of the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `index.js` in the root directory of the project repository
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This creates an `express` application object. We will now be adding TF.js to
    the project. The simplest way to do this is to install it via NPM. The complete
    setup instructions can be found at [https://js.tensorflow.org/setup/](https://js.tensorflow.org/setup/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to install the `TF.js` module in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now proceed to add the module to our `index.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also require the `body-parser` module from Express.js to handle the
    incoming query data from the client side, which will be sent via AJAX `POST` requests.
    To do so, we use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We now create a `body-parser` object and bind it to the application using the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, `package.json` should contain the following snippet that lists
    the dependencies of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64f57e1d-2a8d-481d-b2bc-27ed8c7d89fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that the preceding versions may change. We can now import the `iris.json` file, which
    we will be training our model on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With the initial setup done, we can now proceed to write the TF.js code to train
    on the available dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a TF.js model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by reading the data we have stored in the `iris` variable to a
    `tensor2d` object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `index.js` file, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We do not have any test data yet; this will be provided by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a one-hot encoding of the possible three varieties of flowers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to create the model for training. The following code might
    remind you of the code we used in the previous chapter when we were creating a
    model for the MNIST handwritten digits dataset. This is simply due to the fact
    that we are still using the concepts of TensorFlow, only in a different language!
  prefs: []
  type: TYPE_NORMAL
- en: 'We first declare a sequential TensorFlow model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s add a layer of neurons to the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `inputShape` parameter indicates the shape of the input that will be added
    to this layer. The `units` parameter sets the number of neurons to be used in
    this layer. The `activation` function we are using is the `sigmoid` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add the output layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will have 3 neurons in the output layer, and the input to be expected
    at this layer is 10, which matches the number of neurons in the previous layer.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the input layer, we just have one hidden layer and the output layer.
    This is acceptable in this application because the dataset is small and the prediction
    is simple. Note that we used the `softmax` activation function here, which produces
    class probabilities as outputs.
  prefs: []
  type: TYPE_NORMAL
- en: This is particularly useful in our case as the problem is a multi-class classification
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this done, we are now ready to compile our model. To do this, we use the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since we have a classification problem at hand where there are multiple possible
    labels, we use `categoricalCrossentropy` as the `loss` function. For optimization,
    the `adam` optimizer is used. You are encouraged to experiment with other hyperparameter
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can generate a summary of the model using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will train our TF.js model.
  prefs: []
  type: TYPE_NORMAL
- en: Training the TF.js model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now write an `async` function. The reason for doing this is so that
    the JavaScript on the client side that invokes our function doesn''t get stuck
    waiting for the result. A function that will take time to complete in our program
    is the `train_data()` function. This function performs the training of the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `train_data()` function can be run asynchronously. It also prints out the
    loss at every epoch of training to the console where we will run the server from.
    Let's now create an API that will invoke the `train_data()` function.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a *middleware* called `doTrain`, which will be run before the
    API for training and will return any data.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about middlewares at [https://expressjs.com/en/guide/using-middleware.html](https://expressjs.com/en/guide/using-middleware.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `doTrain()` middleware accepts, in its arguments, the request made to the
    Node.js server, the variable for making the response, and the name of the function
    that will be used to forward the execution of the program after executing the
    block of code defined in the middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `doTrain` middleware calls the `train_data()` function and awaits its result.
    The `train_data()` function returns a *Promise* so that the execution continues
    without freezing. The `next()` function runs right after the `train_data()` function
    is complete and it merely passes the execution of the program to the function
    that is *chained* next to the middleware, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We now bind the `'/train'` route to the `express` app and then chain the `doTrain`
    middleware to it. Now, for every call made to the `'/train'` API, the middleware
    runs first and then the execution passes to the main block of code for the API.
    This block of code simply returns any arbitrary value to denote the completion
    of training.
  prefs: []
  type: TYPE_NORMAL
- en: Predicting using the TF.js model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the training is done, we also need to create an API to invoke the prediction
    function and return the predicted result. We bind the API to the `''/predict''`
    route with a `POST` method to make a request to this API, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It is very simple to understand the code for the prediction API. Let''s discuss
    it in parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This line binds the `''/predict''` route to the `POST` request method and opens
    the block of code for the statements that will handle requests made to this route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines create a TF.js `tensor2d` object from the data, which is received
    from the client side. It then runs the `predict` method on the model and stores
    the result in the output variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This block of code merely finds the index that corresponds to the element in
    the `tensor2d` variable output that is highest. Remember that in a `softmax` activation
    output, the highest value corresponds to the predicted index.
  prefs: []
  type: TYPE_NORMAL
- en: 'After determining the maximum index from the output, we use a simple switch-case
    statement to decide what output is to be sent to the client from the API. The
    request data is also logged to the console visible on the server. Finally, we
    bind our Node.js application to listen to port `3000` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We will now create a simple client in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To handle the `''/''` route in our application, we add the following lines
    of code to `index.js`, which merely renders a static file, `index.html`, which
    is placed in the public folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the static `index.html` file by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a folder, `public`, and inside it, create `index.html.` Add the
    following code to the `index.html` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After setting a simple UI to the client developed to call the APIs we have
    created using TF.js, we are ready to define the functions to deploy them from
    the client side. Notice that both the `"/train"` and `"/predict"` APIs will be
    called by a `POST` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Let's now run the TF.js web app.
  prefs: []
  type: TYPE_NORMAL
- en: Running the TF.js web app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all the application coded, we are now ready to run our application. First,
    open a Terminal and make the `tfjs-iris` folder containing the `package.json`
    file as your working directory in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following line of code to start the Node.js server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The command produces an output that resembles the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36c2cc46-bbf1-471e-beb4-5bde0c30efe1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, along with this output, the server starts at port `3000` and we can view
    the same in the browser. Open a browser and type `http://localhost:3000/` in the
    address bar to bring up the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9ca1b9a-3a54-4848-be67-d133f21e5e88.png)'
  prefs: []
  type: TYPE_IMG
- en: First, you must click on the Train button to invoke the `'/train'` API, which
    begins the training, and the button changes to a disabled state. Once the Predict! button is
    enabled, the training is complete and the user can send dummy data to the server
    to make predictions. Say we choose the 50^(th) row of data from the dataset and
    send it to the server with an expected output of `Setosa`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a small section of the final version of our
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89c50dc0-72c8-4ccf-83db-1e588b47c268.png)'
  prefs: []
  type: TYPE_IMG
- en: We see that the correct output is generated for the input provided.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and limitations of TF.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now summarize some of the advantages TF.js brings over TensorFlow, besides
    the ones we have already talked about in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatic GPU support**: You don''t need to install CUDA or GPU drivers separately
    with TF.js to benefit from the GPUs present on the system. This is because the
    browser itself implements GPU support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration**: It is fairly simple to integrate TF.js into a web development
    project using Node.js and then import pretrained models to the project and run
    them in the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it also has several disadvantages that have to be kept in mind whenever
    developing for production. Some of these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**: TF.js is suitable for small datasets. On large-scale datasets, the
    computation speed suffers heavily and is nearly 10x slower.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of a tensor board**: This great tool, which enables TensorFlow models
    to be visualized, is missing in the JavaScript port of the framework since TF.js
    is only an API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incomplete support of APIs**: Not all of the TensorFlow APIs are available
    on TF.js, and so you might have to rethink the code logic or create your own functions
    to use certain features while developing with TF.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how easy it is to create models with TF.js. You
    not only get the whole JavaScript ecosystem to work with, but you also get all
    the pretrained TensorFlow models within TF.js. We developed a simple web application
    using the Iris dataset and, along the way, we learned about several components
    that TF.js has to offer. By now, we have already built two simple end-to-end deep
    learning-based web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Our progress is indeed apparent. In the upcoming chapters, we will be building
    our own deep learning APIs and using them to create intelligent web applications.
    But before that, let's make ourselves familiar with the whole concept of APIs
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
