- en: Securing Web Apps with Deep Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is of the utmost importance to any website—and all software, in general.
    These days, security threats are evolving with the rise of available computing
    power and developments in the field of technology. So, it is important that websites
    employ the best possible measures of security to keep their data and user information
    secure. Websites with online commercial activities are always at high risk and
    it is very common for them to face security attacks that have not been seen before.
    New attacks are particularly difficult for rule-based security systems to identify
    and stop; so, you can look at the options offered by deep learning-powered security
    systems, which can effectively replace rule-based systems and are also capable
    of correctly identifying and blocking new threats.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter discusses several tricks and techniques that you can use to secure
    websites using deep learning with Python. We will present reCAPTCHA and Cloudflare
    and discuss how they are used to enhance the security of websites. We will also
    show you how to implement security mechanisms to detect malicious users on websites
    using deep learning-based techniques and a Python backend. The following topics
    will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The story of reCAPTCHA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DIY – malicious user detection on Django
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using reCAPTCHA in web applications with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Website security with Cloudflare
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will begin this chapter's discussion with the story of reCAPTCHA—an ingenious
    tool, created by Google, that changed the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can access the code for this chapter at [https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll need the following software to run the code in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.6+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TensorFlow 1.14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keras compatible with TensorFlow 1.14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django 2.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The story of reCAPTCHA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Easy on Humans, Hard on Bots*—that is the tagline of reCAPTCHA, which states
    the simple idea that reCAPTCHA is a system that establishes whether a user on
    an application or website is a genuine human user or an automated script. reCAPTCHA is
    a specific implementation of the CAPTCHA technology—a method that uses visuals
    with distorted, squiggly letters and numbers and challenges the user to decipher
    the contents of the visual image and write it out in a plain format.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were a regular internet user in the early 2000s, you would have seen
    images resembling the following CAPTCHA on a number of websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bdf82cb8-25df-4316-ab30-7c488e38f119.png)'
  prefs: []
  type: TYPE_IMG
- en: '**CAPTCHA** is an acronym for **Completely Automated Public Turing Test To
    Tell Computers and Humans Apart**.'
  prefs: []
  type: TYPE_NORMAL
- en: Popularized by Yahoo, the CAPTCHA system was rapidly adopted for use on millions
    of websites. However, despite the boost to security this system provided to websites,
    it was time-consuming and was often being beaten by rogue programmers. Every so
    often, people would create new CAPTCHA systems with varied designs and combinations
    of elements in the visuals.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, developers were tackling a very different problem—one of digitizing
    printed books and other texts. A quick solution was to scan books; that is, using
    an **Optical Character Reader** (**OCR**) to convert books into preliminary digital
    text form. The conversions were fine for printed content that was made with standard
    fonts and whose scans were obtainable in good quality. However, the conversion
    accuracy suffered for malformed prints and manuscripts. People were increasingly
    uploading images to online platforms in the quest to extract text from those images
    and to use them for several purposes, such as determination of content in images,
    locations, or brands mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: The origin of CAPTCHA is disputed with claims of invention from multiple groups,
    but it was in 2003 that Luis von Ahn coined the term CAPTCHA, and he later became
    the founder of reCAPTCHA, which was acquired by Google.
  prefs: []
  type: TYPE_NORMAL
- en: A pioneer of crowdsourcing, Luis von Ahn used the reCAPTCHA program to display
    very small chunks of text cropped from scans of printed books. Only humans would
    be able to solve these challenges easily, and automated programs would fail. At
    the same time, these books were being slowly digitized by contributions from a
    large number of human users, through unknown crowdsourcing activity. reCAPTCHA
    still remained a nuisance for users but the issue of digitizing books was solved.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, reCAPTCHA evolved to use AI-based systems to identify real and fake
    users. At the time of writing this book, reCAPTCHA is being actively developed
    by Google and is currently on its third version, where it allows the invisible
    verification of users in the background of the web page and only displays a challenge
    when the user cannot be successfully verified. This saves a lot of time for genuine
    users and poses a challenge to machines.
  prefs: []
  type: TYPE_NORMAL
- en: We will now build a website to use deep learning-based models and reCAPTCHA
    to provide security elements to a website.
  prefs: []
  type: TYPE_NORMAL
- en: Malicious user detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A malicious user on a website is any user who attempts to perform tasks that
    they are not authorized to do. In today's world, the threats posed by malicious
    users are increasing exponentially, with huge databases of personal information
    from several global tech giants, government agencies, and other private firms
    being exposed to the public by hackers. It is important to have systems in place that
    can automatically mitigate these malicious attacks.
  prefs: []
  type: TYPE_NORMAL
- en: In order to recognize the malicious users in our sample web app, we have created
    a model that is able to learn the usual behavior of a user and raises the alarm
    if the user behavior at any instance changes significantly from their past usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anomaly detection is a popular branch of machine learning. It is a collection
    of algorithms that are used to detect data samples in a given dataset that do
    not fall along with the majority of the data sample properties. To detect a cat
    in a dog shelter would be anomaly detection. Anomaly detection is performed in
    several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By using minimum-maximum ranges of columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By finding out sudden spikes in the plots of the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By marking points lying on the extreme ends as outliers (anomalies) when data
    is plotted under a Gaussian curve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support vector machines, k-nearest neighbors, and Bayesian networks are some
    of the most popular algorithms used for anomaly detection.
  prefs: []
  type: TYPE_NORMAL
- en: How can we define usual behavior for users on a website?
  prefs: []
  type: TYPE_NORMAL
- en: Assume that you use a website where you normally log in using your laptop. Mostly,
    it takes you a maximum of two attempts to successfully log in to the website.
    If one day you suddenly start using a new laptop, the login would be suspicious
    and would probably be a malicious attempt to hack your account. It would be more
    so if the location of the new device was somewhere you have not been to recently
    or ever before. It would also be highly suspicious if you took 10 attempts to
    log in to your account. The state of not being in any suspicious state of usage
    is the usual behavior of the user on a website.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the anomaly may not be due to the irregular behavior of any specific
    user. Due to changes in the server, the regular traffic of the users and so their
    behavior might change. We have to be careful to not mark all users as malicious
    in such circumstances. Also, the irregular behavior of a user may be caused due
    to reasons other than hacking attempts on their account. If a genuine user suddenly
    starts accessing parts of the website that they should not have access to, it
    is an anomaly and needs to be prevented.
  prefs: []
  type: TYPE_NORMAL
- en: In our sample website, we will integrate a system like this. To do so, we will
    be putting a check on the login page of the website where we will try to determine
    whether a user's login is normal or anomalous. We will be taking into consideration
    the page that the user logs in from, as a website may have multiple login pages,
    and try to determine whether it is a usual page for the user to login from. If
    the user attempts to log in from a page that they generally do not log in from,
    we will mark it as an anomaly. This is just one simple criterion for checking
    anomalous users, with a scope of several hundreds of other parameters.
  prefs: []
  type: TYPE_NORMAL
- en: An LSTM-based model for authenticating users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will break down this section into two major sub-sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Building the security check model
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hosting the model as an API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's begin with the first section.
  prefs: []
  type: TYPE_NORMAL
- en: Building a model for an authentication validity check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To authenticate the user based on their login activity, we will need an API
    that checks the requests. We can build this model using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by developing the authentication model that determines whether
    a user is not acting in a regular manner. We begin by importing the necessary
    modules in a Jupyter notebook running Python 3.6+, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now import the data into the project. We will be using the dataset at [https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/model/data/data-full.csv](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/model/data/data-full.csv).
    We load the dataset into the project, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see some general statistics about the data, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db398383-b1d7-407a-9f2a-ed4f4223c548.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will observe that the data contains text, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d84d0b7-32b3-4ac3-a3d1-d1ba262ee005.png)'
  prefs: []
  type: TYPE_IMG
- en: This observation is important and we'll be referring to this screenshot in future
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, all the data is in string format. We need to convert it into appropriate
    types of values. Also, the dataset currently consists of just one DataFrame; we
    will break it into two parts—the training columns and the labels column—with the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we need to lose some of the columns as we only want to use features in
    the dataset that are relevant to our task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With this done, we are now ready to proceed with tokenizing the request body.
    Tokenizing is a method where we break large paragraphs down into sentences and
    sentences into words. We can perform tokenization with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With the tokenization done, we convert each request body entry into vectors.
    We do so because we need a numerical representation of the data for the computer
    to be able to perform calculations on it. After that, we further split the dataset
    into two more parts—75% of the dataset is for training and the rest is for testing
    purposes. Similarly, the labels column is split using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Remember from step 2 that this data mainly contained text. When it comes to
    text data, there is most likely a context and a specific order associated with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the words of this sentence—*Sachin Tendulkar is a great
    cricketer*. The order of the words must not be changed in order to convey the
    expected meaning. This is where the importance of maintaining order and context
    comes into the picture when you deal with text data in machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we will use a special type of recurrent neural network—**Long Short-Term
    Memory** (**LSTM**)—which will learn to recognize the regular user behavior.
  prefs: []
  type: TYPE_NORMAL
- en: A detailed discussion on LSTM is beyond the scope of this book but if you are
    interested, you can refer to [http://bit.ly/2m0RWnx](http://bit.ly/2m0RWnx) to
    learn about it in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now add the layers, along with the word embeddings, which helps maintain
    the relationship between the numerically encoded text and the actual words, using
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our output is a single neuron that either holds `0` or `1` in the case of a
    non-anomalous or an anomalous login attempt, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then compile the model and print a summary using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The summary of the model is produced, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a057f86-a447-49f8-a185-d82dc84ada58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we are ready to move on to training the model:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `fit()` method of the model as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will quickly check the accuracy achieved by the model. We can see that the
    model is more than 96% accurate on the validation data. This score is quite impressive
    given that this is our first model. We can check the accuracy of the model using
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output as in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15fc01ad-104b-40c0-a6f4-5490fed2bbf6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s save these weights. We will use them to create an API that is used for
    authenticating the users. We can save the model using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With the model ready, we can now move on to hosting it as a Flask API.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting the custom authentication validation model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now create the API that will accept the login attempt from the user
    and return its confidence in the validity of the login:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by importing the required modules for creating a Flask server, as
    shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to import the saved model and weights from the `model` training
    step. Once we do so, we need to recompile the model and make its `predict` function
    using the `make_predict_function()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be using a data cleaning function to strip out numbers and other non-useful
    text in the incoming queries from the client app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create the `/login` route in the app, which will accept the login credentials
    and other request header details from the client app when the user attempts to
    log in. Notice that we still drop out some extra request headers as we did during
    the training.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we clean the data, we tokenize and vectorize it. These steps are the same
    as the preprocessing we did during training. This is to ensure that the incoming
    request is processed exactly as it was during the training phase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the app returns its confidence in the user being authenticated in the
    form of a JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the server on the desired port, we need to add the following lines at
    the end of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we save the server script file as `main.py`. We will get the server
    running by using the following command on the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will start the Flask server, which listens in on the loopback IP `127.0.0.1`,
    and at port `9000`. You can easily host this script on a virtual machine in the
    cloud and make it available to all your apps and websites as a common security
    checkpoint API.
  prefs: []
  type: TYPE_NORMAL
- en: We can now move on to creating our web app that runs on the Django framework.
  prefs: []
  type: TYPE_NORMAL
- en: A Django-based app for using an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The website that we are creating to consume the user-authentication check API
    will be a simple billboard demo. The website will have provisions for users to
    log in and then post bills to a billboard. While the app is simple, it contains
    two major features of deep learning-based security integrations—anomaly detection
    during user authentication and the implementation of reCAPTCHA during posting
    bills—to avoid spam.
  prefs: []
  type: TYPE_NORMAL
- en: The steps to create the application are discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The Django project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll be working with Django. Make sure that you have a working
    Django installation on your system before proceeding with this section. You can
    find installation instructions for Django in the *A brief introduction to Django
    web development* section in [Chapter 8](3bf31fe1-d41c-4410-a83c-1651da439c70.xhtml)*,
    Deep Learning on Microsoft Azure Using Python*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a Django project. To do so, we use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create the `webapp` directory in the current folder. We will be adding
    all of our future code in this directory. The current directory structure looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With this done, we are now ready to create an app inside the project, which
    is shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an app in the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed in [Chapter 8](3bf31fe1-d41c-4410-a83c-1651da439c70.xhtml), *Deep
    Learning on Microsoft Azure Using Python*, we must now add apps to the website
    project. To do so, we use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will create an app called `billboard` in the project.
    However, we still have to link this app to the project.
  prefs: []
  type: TYPE_NORMAL
- en: Linking the app to the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add the app to the project, we need to add the app name to the list of apps
    in `settings.py` in the project settings file, as in the following code. In `settings.py`,
    add the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With this, we are ready to create the routes on the website.
  prefs: []
  type: TYPE_NORMAL
- en: Adding routes to the website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add routes to the project, we edit the `urls.py` file of `webapp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: However, the `billboard.urls` path does not exist. We'll create the path to
    proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the route handling file in the billboard app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new file, called `urls.py`, in the `billboard` folder, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Save this as `webapp/billboard/urls.py`. Notice that we have imported some `views` items
    to this route handling file. Also, we have used the `login_required` method. This
    indicates that we can start working on the authentication of the website.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication routes and configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add the routes for authentication, add the following at the end of the `webapp/settings.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: These lines indicate that we will need a `/login` and a `/logout` route.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the login page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the login page, we''ll need to add the `/login` route to `urls.py`
    in the billboard app. However, we''ve already done that. Next, we need to add
    the `loginView` view to the `views.py` file of the billboard app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function first checks whether the username and password being
    passed to it exist in the user database. So, we'll need a user model, in the future,
    to store users in the database file, `db.sqlite3`, which was created during the
    project creation step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function will then make a call to the authentication check model API to
    validate whether the user login is of normal behavior. The validation is carried
    out as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code block validates the user login and, if it's found to be invalid,
    performs a logout action and redirects the user back to log in again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to add some necessary imports to the `view.py` file for this, as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we also imported the `logout` method from `django.contrib.auth`.
    This will be used to create a `logout` view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a logout view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s create the `logout` view. This is very simple to do, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's create a template of the login page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a login page template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a template, we first need to create the folders required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called `templates` in the `billboard` directory. The directory
    structure will now look as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `templates` folder, we'll place our template files. Let's first create `base.html`,
    which we will extend in all other templates. This will contain the `CSS` and `JS`
    includes, along with the general block structure of the page.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided a sample of this file at [https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/webapp/billboard/templates/base.html](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/webapp/billboard/templates/base.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, we''re ready to create the `login.html` file, which will
    carry out the process of sending the login values to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have extended the `base.html` template in the preceding view
    template.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about extending Django templates at [https://tutorial.djangogirls.org/en/template_extending/](https://tutorial.djangogirls.org/en/template_extending/).
  prefs: []
  type: TYPE_NORMAL
- en: The form in this login page makes a `POST` request and so requires the passing
    of the CSRF token. We can now create the page that renders after the login is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: The billboard page template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we''ve already set up the `base.html` file, we can simply extend it in
    the `board.html` template file to create the billboard display page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding block of code, we have iterated over all the available `bills` items
    in the billboard's database and displayed them using a `for` loop in the template.
    The use of the `base.html` template allows us to reduce the amount of repeated
    code in the view templates.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we will create the page that will have the code to add a new bill
    to the billboard.
  prefs: []
  type: TYPE_NORMAL
- en: Adding to Billboard page template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the page template that adds a bill to the billboard, we use the following
    code to create the `add.html` template file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding block of code, we have extended the `base.html` template to
    add a form that allows us to add bills. Notice the use of the CSRF token in the
    `form` element. In Django, we always need to pass valid CSRF tokens while making
    POST requests.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about CSRF tokens in Django at [https://docs.djangoproject.com/en/3.0/ref/csrf/](https://docs.djangoproject.com/en/3.0/ref/csrf/).
  prefs: []
  type: TYPE_NORMAL
- en: But wait, we've not yet added the views to handle the billboard page and the
    addition of the bills page. Let's add them now!
  prefs: []
  type: TYPE_NORMAL
- en: The billboard model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to add the views to see all the bills on the billboard page. However,
    for this, we first need to create the model to hold all the bills.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `models.py` file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a new model called `Bills`. This will store
    the details for all of the bills added by users on the billboard. The `user` model
    is linked with this model as a foreign key. Save this file as `webapp/billboard/models.py`.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about foreign keys and other keys at [https://www.sqlite.org/foreignkeys.html](https://www.sqlite.org/foreignkeys.html).
  prefs: []
  type: TYPE_NORMAL
- en: With this done, we can now use the `Bills` model in the views.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the billboard view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start using the `Bills` model in the app, we first need to import it to the
    `views.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line at the top of the `view.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can add the view for the billboard, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to create the view for adding the bills.
  prefs: []
  type: TYPE_NORMAL
- en: Creating bills and adding views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this view, we will create the bills. If a valid `POST` request is made to
    the route served by the `addbill` method, we create a new `Bill` object and save
    it to the database. Otherwise, we display the form for adding bills to the user.
    Let''s see how we can do this in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: However, we still need to create the admin user before using the app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the admin user and testing it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the admin user, we use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now migrate the database change by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'An output similar to the following is produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0506807-c8f7-4fa1-b8c1-2b79d7600dd8.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's secure the billboard postings using the reCAPTCHA tool.
  prefs: []
  type: TYPE_NORMAL
- en: Using reCAPTCHA in web applications with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add the reCAPTCHA to the website, we first need to obtain the API keys from
    the Google reCAPTCHA console:'
  prefs: []
  type: TYPE_NORMAL
- en: First, log in to your Google account and go to [https://www.google.com/recaptcha](https://www.google.com/recaptcha).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on Admin Console at the top-right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add your site to the console by following the steps shown on your screen. If
    you're testing on your local system, you'll have to specify `127.0.0.1` as one
    of the URLs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain the API keys for your domain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The screen that you get your domain''s API keys on should look similar to the
    following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/fee62e08-e223-469d-a77e-82bac332aa67.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, add the secret key to the `settings.py` file of the web app, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add the scripts to be loaded to the `add.html` template. We''ll
    add it to the billboard app page template, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that the key used in this step is the client/site key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to validate the reCAPTCHA in the add billboard view, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You can grab the full working version of the `addbill` method in the previous
    code block from [https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/webapp/billboard/views.py](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/webapp/billboard/views.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'With the previous changes made, we''re finally ready to test run the website
    with all its security measures in place. Run the following command to start the
    website server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be able to see the website''s login page, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6be54474-9af3-4242-a2ac-c55719a38b51.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that at this point, you'll need to have the Flask server, which performs
    the login validation, running at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon login, you''ll see the billboard page with bills posted on it. Head over
    to the Add Bill button to add a new bill, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d28fc58c-b859-4882-869e-c5c3d783772d.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice the reCAPTCHA logo at the bottom-right corner of the screen. This indicates
    that the page is protected against spamming by using reCAPTCHA. If you are able
    to post successfully, the billboard is displayed again with the submitted bill.
    If not, you'll be presented with a reCAPTCHA verify challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Website security with Cloudflare
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloudflare is the industry's leading web infrastructure and website security
    provider. It creates a layer of security and fast content delivery between a website
    and its users, hence routing all the traffic through its servers, which enables
    security and other features on websites. In 2017, Cloudflare provided DNS services
    to over 12 million websites. These services include content delivery networks,
    **Distributed Denial of Service** (**DDoS**) attack protection, hacking attempt
    protection, and other internet security services, such as leeching protection.
  prefs: []
  type: TYPE_NORMAL
- en: In 2014, Cloudflare reported mitigating a 400 Gib/s DDoS attack on a customer,
    which was soon followed by a 500 Gib/s attack the next year. The largest attack
    on any website recorded has been on GitHub, where it faced a DDoS of 1.4Tb/s flooding.
    GitHub was using Akamai Prolexic (an alternative to Cloudflare) and was able to
    withstand the attack, going down only for 10 minutes before coming back up entirely.
    Cloudflare offers DDoS protection to all its users free of charge.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with deploying the services of Cloudflare on your website, you
    need to set up Cloudflare as an intermediate layer between your users and the
    hosting server. The following diagram depicts how Cloudflare sits on the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ada2acb7-d8a7-4b38-8329-e7e64ba13a85.png)'
  prefs: []
  type: TYPE_IMG
- en: So, the detection of spam and malicious users that we created the previous custom
    solutions for, with the help of Google's reCAPTCHA, is automatically taken care
    of by Cloudflare to a basic extent (in the free tier, with more powerful solutions
    in the higher tiers as you upgrade). It is, therefore, very intuitive and simple
    for a small team of developers to push off their security needs to Cloudflare's
    systems and to rest assured that they are protected against a number of security
    breaches.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how we can provide security to websites using Cloudflare's
    services. We also saw how to create security APIs that can be used in integration
    with web applications and other security services such as reCAPTCHA. It is crucial
    for any website—small or large—to have these security measures in place in order
    for their website services to function properly. There have been major breaches
    in recent times, and countless others that have been attempted by AI-powered systems
    that do not make it onto the news because they were not an issue. Security using
    deep learning is a burning topic of research and it is believed that in the near
    future, security systems will all rely strongly on deep learning to recognize
    and eliminate threats.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how to set up a production-grade deep learning
    environment. We will discuss the architecture designs you could follow, depending
    on their size requirements, and the state-of-the-art service providers and tools.
  prefs: []
  type: TYPE_NORMAL
